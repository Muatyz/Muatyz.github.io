<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ITensor基础语法说明 | 无处惹尘埃</title>
<meta name="keywords" content="physics, DMRG">
<meta name="description" content="介绍以DMRG算法为核心的itensor库使用方法">
<meta name="author" content="Muartz">
<link rel="canonical" href="https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://Muatyz.github.io/img/Head32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://Muatyz.github.io/img/Head16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Muatyz.github.io/img/Head32.png">
<link rel="apple-touch-icon" href="https://Muatyz.github.io/img/Head32.png">
<link rel="mask-icon" href="https://Muatyz.github.io/img/Head32.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "www.muartz.com"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  CommonHTML: {
  scale: 100
  },
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
  
  
  
  var all = MathJax.Hub.getAllJax(), i;
  for(i = 0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>

<style>
  code.has-jax {
      font: "LXGW WenKai Screen", sans-serif, Arial;
      scale: 1;
      background: "LXGW WenKai Screen", sans-serif, Arial;
      border: "LXGW WenKai Screen", sans-serif, Arial;
      color: #515151;
  }
</style>
  

<meta property="og:title" content="ITensor基础语法说明" />
<meta property="og:description" content="介绍以DMRG算法为核心的itensor库使用方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-05T00:18:23+08:00" />
<meta property="article:modified_time" content="2022-05-05T00:18:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ITensor基础语法说明"/>
<meta name="twitter:description" content="介绍以DMRG算法为核心的itensor库使用方法"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://Muatyz.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "🧱 PHY",
          "item": "https://Muatyz.github.io/posts/phy/"
        },

        {
          "@type": "ListItem",
          "position":  3 ,
          "name": "💻 Computation Physics",
          "item": "https://Muatyz.github.io/posts/phy/calphy/"
        }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "ITensor基础语法说明",
      "item": "https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ITensor基础语法说明",
  "name": "ITensor基础语法说明",
  "description": "介绍以DMRG算法为核心的itensor库使用方法",
  "keywords": [
    "physics", "DMRG"
  ],
  "articleBody": "one site 单节点 Site\n意指\"节点\".\n单节点的自旋为 $\\frac{1}{2}$ 的波函数,有两个基底.\n$|s=1\\rangle=|\\uparrow\\rangle;|s=2\\rangle=|\\downarrow\\rangle$\n对于一般的自旋为 $\\frac{1}{2}$ 的波函数,可以写成如下形式:\n$|\\psi\\rangle=\\sum_{s=1}^{2}\\psi_s|s\\rangle(\\psi_s\\in\\mathcal{C})$\n使用张量数学来处理这个单节点波函数, 即 $|\\psi_s\\rangle$ 对应一个有一个\"触手\"的结点.展开形式为 $(^{\\psi_1}_{\\psi_2})$ , $\\psi_1,\\psi_2$ 又各自是一个单\"触手\"的结点.\nIndex s(\"s\",2); //\"s\"代表的是Index的命名 //2是Index的维度 ITensor psi(s); //由于只声明不定义,所以初始值为0 Index 指标\n指的是表示某种物理量的符号.这个符号 可以是矢量, 张量, 算符.\nIndex s(2,\"s\"); Index t(3,\"t\"); ITensor T(s,t); 这个表示的就是创建了一个二维的物理量,我们用$s$来标记它;物理量t则是三维的. 而Itensor的大小则是 $2\\times 3$.\n对 $|\\psi_s\\rangle$ 进行初始化操作.我们不妨将其初始化为基矢:\n$|\\psi_s\\rangle=|\\uparrow\\rangle$\nIndex s(2,\"s\"); //在最新的ITensor语法规范中,Index (string, int)的语法已经被弃用 //目前的语法应当是Index (int, string) ITensor psi(s); psi(s(1)) = 1; PrintData(psi); 本示例代码应该会输出:\npsi = ITensor ord=1: (dim=2|id=414|\"s\") {norm=1.00 (Dense Real)} (1) 1.0000000 Operators 操作符/算子 $\\hat{A}$ 算子体现在张量网络上就是一个拥有两个\"触手\"的结点, 它可以和只有一个\"触手\"的结点结合, 从而生成一个新的只有一个触手的结点.\nITensor Sz(s,prime(s)); ITensor Sx(s,prime(s)); //prime(s)是指的对s进行共轭操作 如果要对一个向量或者矩阵进行转置,共轭等操作,我们可以用被称为上下标的操作来表示.比如, $A_{ij}^{’}=A_{ji}$, $A_{ij}^{\\dagger}=A_{ji}$ 等.\nprime(s)就代表了对指标进行上标操作所得到的量.\nPrime Level 上标级别\n指标有一个属性被称为prime level, 表示是否被某个操作升降级.默认情况下指标的上标级别为0.\n这个量的作用是用来对两个张量进行比较, 在进行某些操作时, 上标必须要满足某些需求运算才能够成立.\n比如\nIndex s(2,\"s\"); Index t(2,\"2\"); ITensor A(s,t); ITensor B(s,t);// s, t 都是上标级别为 0 的指标 C = A * prime(B);// prime(B) 表示将 B 中的所有指标上标级别加 1 在这里, A * prime(B)就是一个不允许指标重复的操作.所以为了完成这个计算,我们需要对B进行上标级别升级的操作,也就是使用prime()函数.\n现在我们来对 $\\hat{S}_z,\\hat{S}_x$ 算子进行定义.\nITensor Sz(s,prime(s)),Sx(s,prime(s)); // commaInit(Sz,s,prime(s)) = 0.5, 0.0, // 0.0,-0.5; // commaInit(Sx,s,prime(s)) = 0.0, 0.5, // 0.5, 0.0; //commaInit的语法已经被弃用, 应当使用.set() //Sz Sz.set(s(1),prime(s)(1),0.5); Sz.set(s(2),prime(s)(2),-0.5); //Sx Sx.set(s(1),prime(s)(2),0.5); Sx.set(s(2),prime(s)(1),0.5);//设置分量 现在我们尝试对波函数 $|\\psi\\rangle$ 进行求某方向自旋的操作.\n即方程上的\n$$ (\\hat{S_{x}})_{s’}^{s}\\psi_{s} $$\n对应的是\nITensor phi = Sx * psi; (注意算符的上标要和波函数的下标相同, 这样的操作才是被允许的. $s$和$s’$的上标等级不同, 所以是不匹配的)\n为了研究经过求自旋的量 $|\\phi\\rangle$ 的具体情况, 我们将其输出在终端:\nITensor phi = Sx * psi; PrintData(phi); 输出的结果应该是:\nphi = ITensor ord=1: (dim=2|id=816|\"s\")' {norm=0.50 (Dense Real)} (2) 0.5000000 我们来看看更多的结果. 如果有 $|\\psi_s\\rangle=(|^{\\cos{\\frac{\\theta}{2}}}_{\\sin{\\frac{\\theta}{2}}}\\rangle)_{\\theta=\\frac{\\pi}{4}}$, 那么我们可以这样描述:\nReal theta = Pi/4; // psi(s(1)) = cos(theta/2); // psi(s(2)) = sin(theta/2); //该语法已被弃用,使用.set()替代 psi.set(s(1),cos(theta/2)); psi.set(s(2),sin(theta/2)); PrintData(psi); 终端会输出\npsi = ITensor ord=1: (dim=2|id=977|\"s\") {norm=1.00 (Dense Real)} (1) 0.9238795 (2) 0.3826834 期望值 $\\langle\\hat{A}\\rangle$ 在物理上我们定义算符 $\\hat{A}$ 的期望值为 $\\langle\\psi|\\hat{A}|\\psi\\rangle$.\n我们不妨求自旋算符 $\\hat{S_z}$ 的期望值. 在张量网络上, 这个过程体现为, 作为算符的\"具有上下两个触手的结点\"的每个触手分别连接一个\"只有单触手的结点\"(也就是代表着单节点波函数).\n我们用程序语言来描述这个过程:\nITensor cpsi = dag(prime(psi)); // Real zz = (cpsi * Sz * psi).toReal(); // Real xx = (cpsi * Sx * psi).toReal(); // toReal()函数已弃用,使用.real()替代 Real zz = (cpsi * Sz * psi).real(); Real xx = (cpsi * Sx * psi).real(); // println(\"=\",zz); // println(\"=\",xx); // println()已弃用,使用printfln()替代 printfln(\"=\",zz); printfln(\"=\",xx); 其中ITensor cpsi = dag(prime(psi));就是一个将 $\\psi$ 先取转置后取共轭的过程, 所以cpsi的上标级数为$2$. 我们也可以推测得知, 算符 $\\hat{S}_x,\\hat{S}_z$的上标级数为$1$.\n终端输出为\n=0.353553 =0.353553 观察到 $\\sqrt{\\langle S_z\\rangle ^2 + \\langle S_x\\rangle ^2} = \\frac{1}{2}$\n我们可以将这个过程进行类似结合率的分析:\n$\\langle\\psi|\\hat{S}_z|\\psi\\rangle = \\langle\\psi|\\hat{S}_z\\psi\\rangle$.\n用代码来描述结合律的过程:\nITensor Zpsi = Sz * psi; //因为Sz以s为上标,psi以s为下标,所以允许运算 ITensor expect = cpsi * Zpsi; Real zz = expect.real() Quiz $1$ 解析 提示\n原文所提示的函数elt()已经弃用.所以采用的是传统的prime(A) * B方式. 如果你想使用函数而非 *来得到内积, 你应当采用函数inner()\n#include \"itensor/all.h\" #include \"itensor/util/print_macro.h\" using namespace itensor; int main(){ // Define our Index // (the space we are working with) auto s = Index(2,\"s\"); // Operators auto Sx = ITensor(s,prime(s)); Sx.set(s(1),prime(s)(2),0.5); Sx.set(s(2),prime(s)(1),0.5); PrintData(Sx); // Single-site wavefunction auto psi = ITensor(s); //initialized to zero // TODO // 1. make the above wavefunction // the (normalized) positive Sx eigenstate psi.set(s(1),1/sqrt(2)); psi.set(s(2),1/sqrt(2)); PrintData(psi); // TODO // 2. Compute |phi\u003e = Sx |psi\u003e using // the Sx and psi ITensors above // AND // compute: auto olap = // using the * operator and elt(...) method. // Print the result with PrintData(...). auto phi = Sx * psi; auto olap = prime(psi) * phi; //auto olap = elt(prime(psi),phi); PrintData(olap); // TODO // 3. Try normalizing |phi\u003e and recompute // the inner product // Print the result with PrintData(...). // HINT: use phi /= norm(phi)) to normalize. phi /= norm(phi); //auto olap2 = eltC(prime(psi),phi); auto olap2 = prime(psi) * phi; PrintData(olap2); return 0; } 输出得到:\nSx = ITensor ord=2: (dim=2|id=15|\"s\") (dim=2|id=15|\"s\")' {norm=0.71 (Dense Real)} (2,1) 0.5000000 (1,2) 0.5000000 psi = ITensor ord=1: (dim=2|id=15|\"s\") {norm=1.00 (Dense Real)} (1) 0.7071068 (2) 0.7071068 olap = ITensor ord=0: {norm=0.50 (Dense Real)} 0.5000000 olap2 = ITensor ord=0: {norm=1.00 (Dense Real)} 1.0000000 Two Sites 双节点 纠缠态 对于双自旋的波函数, 我们一般的描述方程是:\n$$ |\\Psi\\rangle = \\sum_{s_1,s_2 = 1}^{2}\\psi_{s_1s_2}|s_1\\rangle|s_2\\rangle $$\n体现在张量网络上, 就是一个结点在同一方向上同时有着两个\"触手\". 对于我们写出来的态, 我们可以分离出两个单态(Singlet).\n程序上的描述方法:\n// Index s1(2,\"s1\",Site), s2(2,\"s2\",Site); // 该语法已经被弃用,使用两步语法来替代 Index s1(2,\"s1\");s1.addTags(\"Site\"); Index s2(2,\"s2\");s1.addTags(\"Site\"); ITensor psi(s1,s2); //只声明不定义,则默认为0 // psi(s1(1),s2(2)) = 1./sqrt(2); // psi(s1(2),s2(1)) =-1./sqrt(2); // 该语法已被弃用,使用.set()来替代. psi.set(s1(1),s2(2), 1./sqrt(2)); psi.set(s1(2),s2(1),-1./sqrt(2)); PrintData(psi); Index s1(2,\"s1\");s1.addTags(\"Site\");代表的含义是创建一个维数为int,标签(或者理解为\"名字\",一般是指物理上的状态,比如自旋,粒子位置等等)为string,指标类型为Site的物理量.同时使用ITensor psi(s1,s2)将s1和s2设置为纠缠态(Entangled State).\n现在要说明的就是指标(Index)的类型:Site和Link.\nSite表示单个量子位的物理态. 适用于表示单个自旋,单个粒子的位置等等. 与之配对的维数int表示的是该量子位可以取的物理态的数量;\nLink表示的是不同量子位之间的相互作用. 这种相互作用通常表示不同量子位的链接, 适用于表示各种相互作用, 比如哈密顿量等.\n(还有表示不同于Site和Link类型的其它指标类型, 比如Bulk)\n上面的代码中我们用Site来标记两个量子位,并且使其结合为纠缠态.\n结果输出为\npsi = ITensor ord=2: (dim=2|id=324|\"s1,Site\") (dim=2|id=127|\"s2\") {norm=1.00 (Dense Real)} (2,1) -0.707107 (1,2) 0.7071068 哈密顿量$\\hat{H}$ 我们写出双自旋系统的哈密顿量方程:\n$\\hat{H}=\\hat{S}_1\\cdot\\hat{S}_2=S_1^zS_2^z+\\frac{1}{2}S_1^+S_2^-+\\frac{1}{2}S_1^-S_2^+$\n其中 $S_1^\\pm, S_2^\\pm$ 是升降算符. 我们在程序中这样创建:\nIndex s1(2,\"s1\");s1.addTags(\"Site\"); Index s2(2,\"s2\");s1.addTags(\"Site\"); ITensor Sz1(s1,prime(s1)),Sp1(s1,prime(s1)),Sm1(s1,prime(s1)); ITensor Sz2(s2,prime(s2)),Sp2(s2,prime(s2)),Sm2(s2,prime(s2)); // commaInit(Sp1,s1,prime(s1)) = 0, 1, // 0, 0; // commaInit语法已被弃用. //Sz1,Sz2 Sz1.set(s1(1),prime(s1)(1),0.5);Sz1.set(s1(2),prime(s1)(2),-0.5); Sz2.set(s2(1),prime(s2)(1),0.5);Sz2.set(s2(2),prime(s2)(2),-0.5); //Sp1,Sp2 Sp1.set(s1(1),prime(s1)(2),1);Sp2.set(s2(1),prime(s2)(2),1); //Sm1,Sm2 Sm1.set(s1(2),prime(s1)(1),1);Sm2.set(s2(2),prime(s2)(1),1); ITensor H = Sz1 * Sz2 + 0.5 * Sp1 * Sm2 + 0.5 * Sm1 * Sp2; PrintData(H);//你也可以尝试执行printfln(\"H=\",H); 执行后可以得到结果\nH = ITensor ord=4: (dim=2|id=397|\"s1,Site\") (dim=2|id=397|\"s1,Site\")' (dim=2|id=53|\"s2\") (dim=2|id=53|\"s2\")' {norm=0.87 (Dense Real)} (1,1,1,1) 0.2500000 (2,2,1,1) -0.250000 (1,2,2,1) 0.5000000 (2,1,1,2) 0.5000000 (1,1,2,2) -0.250000 (2,2,2,2) 0.2500000 这表明这是一个四阶张量,并且由索引s1, s1', s2, s2'来描述. 它们各自的维度都是$2$, 即它们可以取值为$1$或$2$.这就是(i,j,k,l)中1或者2的含义, 后面的值是对应的张量元素.\n这样计算得来的 $\\hat{H}$ 在张量网络中表示一个上下各自有两个\"触手\"的结点, 恰好可以和表现为在某一方向上拥有两个\"触手\"的纠缠态结点进行结合.\n更具体地说, 我们上面创建的 $\\hat{H}$ 的上标是s1'和s2',下标是s1和s2; 而 $\\psi$ 的上标是s1和s2,两者进行结合就可以得到只有两个上标s1'和s2'的新节点 $\\hat{H}\\psi$ .\n程序上这样描述这个结合的过程:\nITensor Hpsi = H * psi; //Hpsi.mapprime(1,0);//该语句的作用是将Hpsi中所有上标级别为1的索引全部降为0,使得之后的运算能够被允许 //该语法已被弃用. 使用.noPrime()来代替 Hpsi.noPrime(); Real E = (dag(psi) * Hpsi).real(); //Print()语法已被弃用, 使用PrintData()来代替. PrintData(E); 能够在终端得到输出\nE = -0.75 当然这个过程也可以一行语句完成:\nReal E = (dag(prime(psi)) * H * psi).real(); PrintData(E); 输出的结果同样是\nE = -0.75 Quiz $2$ 解析 这个题目的背景是, 使用虚时间演化的方式来找到哈密顿量所对应的基态. 对应的方程是\n$e^{-\\beta H/2}|0\\rangle\\propto|\\Psi_0\\rangle$\n#include \"itensor/all.h\" #include \"itensor/util/print_macro.h\" using namespace itensor; //定义生成Sp Sm Sz的函数 ITensor makeSp(Index const\u0026 s){ auto Sp = ITensor(s,prime(s)); Sp.set(s=2,prime(s)=1, 1); return Sp; } ITensor makeSm(Index const\u0026 s){ auto Sm = ITensor(s,prime(s)); Sm.set(s=1,prime(s)=2,1); return Sm; } ITensor makeSz(Index const\u0026 s){ auto Sz = ITensor(s,prime(s)); Sz.set(s=1,prime(s)=1,+0.5); Sz.set(s=2,prime(s)=2,-0.5); return Sz; } int main(){ // Initial product state auto s1 = Index(2,\"s1\");auto s2 = Index(2,\"s2\"); auto psi = ITensor(s1,s2); psi.set(s1=1,s2=2,1.0); PrintData(psi); // Single-site operators auto Sz1 = makeSz(s1);auto Sz2 = makeSz(s2); auto Sp1 = makeSp(s1);auto Sp2 = makeSp(s2); auto Sm1 = makeSm(s1);auto Sm2 = makeSm(s2); // Two-site Heisenberg Hamiltonian auto H = Sz1 * Sz2 + 0.5 * Sp1 * Sm2 + 0.5 * Sm1 * Sp2; // Initial energy expectation value auto initEn = elt(dag(prime(psi)) * H * psi); printfln(\"\\nInitial energy = %.10f\",initEn); // Make exp(-beta*H) // TODO // 3. Adjust beta to get the ground state Real beta = 0.1; auto expH = expHermitian(H,-beta); // Here we apply exp(-beta*H), normalize // and unprime auto psibeta = expH * psi; psibeta.noPrime(); psibeta /= norm(psibeta); PrintData(psibeta); auto En = elt(dag(prime(psibeta)) * H * psibeta); printfln(\"At beta=%.1f, energy = %.10f\",beta,En); // TODO // 1. Adjust the following code to // truncate to dimension 1. // HINT: use the ITensor named argument // system, e.g. {\"MaxDim=\",...} auto [U,D,V] = svd(psibeta,{s1},{\"MaxDim=\",1}); PrintData(D); // TODO // 2. Calculate the overlap of the new // wavefunction with the old wavefunction. // Print your results with PrintData(...). // HINT: use U*D*V to calculate the new, // truncated wavefunction auto newpsi = U * D * V; PrintData(newpsi); Real op = (dag(prime(newpsi)) * H * psibeta).real(); PrintData(op); // TODO // 3. Increase beta (defined above) to get the // ground state. How does the overlap // change? return 0; } 输出得到.\npsi = ITensor ord=2: (dim=2|id=311|\"s1\") (dim=2|id=239|\"s2\") {norm=1.00 (Dense Real)} (1,2) 1.0000000 Initial energy = -0.2500000000 psibeta = ITensor ord=2: (dim=2|id=311|\"s1\") (dim=2|id=239|\"s2\") {norm=1.00 (Dense Real)} (2,1) -0.049896 (1,2) 0.9987544 At beta=0.1, energy = -0.2998339973 D = ITensor ord=2: (dim=1|id=426|\"U,Link\") (dim=1|id=228|\"V,Link\") {norm=1.00 (Diag Real)} (1,1) 0.9987544 newpsi = ITensor ord=2: (dim=2|id=311|\"s1\") (dim=2|id=239|\"s2\") {norm=1.00 (Dense Real)} (1,2) 0.9987544 op = -0.274295 所以只要我们一直调整beta的取值反复编译执行, 最后就能够找到能量最低时所对应的beta值.\nSVD 奇异值分解 Singular Value Decomposition\n如果M是 $m\\times m$ 的矩阵, 那么一定存在这样一个式子:\n$M = U \\Sigma V^*$\n其中$U$是 $m\\times m$ 的酉矩阵, $\\Sigma$ 是 $m\\times n$ 非负实数对焦矩阵, $V^*$ 是 $n\\times n$ 的酉矩阵.\n其中 $\\Sigma$ 对角线上的元素 $\\Sigma_{i,i}$ 是 $M$ 的奇异值.\n密度矩阵重整化群 Density Matrix Renormalization Group\n该方法通过矩阵乘积态(Matrix Product State,MPS)来表示量子多体系统的波函数等. DMRG方法来源于密度矩阵的理论和重整化群的思想, 大幅减少系统自由度的同时保留了系统中的物理特征.\n对于\n$$ M= \\begin{bmatrix} 0.435839 \u0026 0.223707 \u0026 0.10\\\\ 0.435839 \u0026 0.223707 \u0026 -0.10 \\\\ 0.223707 \u0026 0.435839 \u0026 0.10 \\\\ 0.223707 \u0026 0.435839 \u0026 -0.10 \\\\ \\end{bmatrix} $$\n可以分解为 $A * D * B$:\n$$ \\begin{bmatrix} 0.5 \u0026-0.5 \u0026 0.5 \\\\ 0.5 \u0026-0.5 \u0026-0.5 \\\\ 0.5 \u0026 0.5 \u0026 0.5 \\\\ 0.5 \u0026 0.5 \u0026-0.5 \\\\ \\end{bmatrix}* \\begin{bmatrix} 0.933 \u0026 0 \u0026 0 \\\\ 0 \u0026 0.300 \u0026 0 \\\\ 0 \u0026 0 \u0026 0.200 \\\\ \\end{bmatrix}* \\begin{bmatrix} 0.707107 \u0026 0.707107 \u0026 0 \\\\ -0.707107 \u0026 0.707107 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\\\ \\end{bmatrix} $$\n可以看出, 两边的矩阵 $A,B$ 满足酉矩阵的定义, 即有 $A^{\\dagger}A=I,BB^{\\dagger}=I$.而对角矩阵 $D$ ,元素是非负实数且降序排列.\n如果我们从后往前一步步去除 $D$ 对角线上的元素, 即\n$$ \\begin{bmatrix} 0.933 \u0026 0 \u0026 0 \\\\ 0 \u0026 0.300 \u0026 0 \\\\ 0 \u0026 0 \u0026 0.200 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} 0.933 \u0026 0 \u0026 0 \\\\ 0 \u0026 0.300 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} 0.933 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \\\\ \\end{bmatrix} $$\n这种操作被称为截断(Truncating).\n然后依次重新进行 $M_{i} = A * D_{i} * B$ 合成, 并且使用范数 $||M_i - M||^2$ 来对合成后的矩阵产生的偏差程度进行评估.我们将可以看到:\n$$ ||M - M||^2 = 0;\\ ||M - M_1||^2 = (0.2)^2;\\ ||M - M_2||^2 = (0.2)^2 + (0.3)^2; $$\n我们不难看出, 其实截断就是在降低矩阵 $D$ 的秩, 通过把握这个截断的幅度, 我们就可以控制最后产生 $M_i$ 矩阵的偏差程度. 这是一个用精度换速度的过程.\n双自旋波函数 我们不妨用更物理一点的背景来分析奇异值分解的过程.\n对于一个纠缠态的双自旋系统, 我们已经知道可以处理为一个具有两个\"触手\"(即上标)的结点. 但是我们也可以将其作为一个矩阵来处理, 即一个拥有左右两个\"触手\"的结点.\n$-^{s_1} -\\square\\square\\square^{\\psi}-^{s_2}-$\n这样, 我们就可以对中间的结点进行SVD操作, 这样就形成了一个项链式的结构:\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n这种波函数形式, 我们将其称之为\"矩阵乘积态\"(Matrix Product State,MPS).\n为了让这个结构看上去更像是一个波函数,可以想象两侧的\"触手\"是向上的(上标).\n不妨用程序来描述这个过程.\nITensor A(s1),D,B; //先声明后使用 svd(psi,A,D,B); 我们已经知道, 对于一个寻常的双自旋波函数, 我们需要 $(2s + 1)^2$ 个参数来进行描述. 而且一般情况下, 我们对于这些参数的重要程度是无知的.无法放弃任何一个参数, 这就会急剧增加计算量.\n而SVD给了我们一种可能: 我们不仅能知道哪些参数最重要, 我们还可以很大程度上掌握它们的数量, 而且这个数量很有可能很少(有利于计算!).\n我们用方程来表达矩阵乘积态的思想:\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha,\\alpha’,s_2}A_{s_1\\alpha}D_{\\alpha\\alpha’}B_{\\alpha’s_2}|s_1\\rangle|s_2\\rangle $$\n当然我们也可以将矩阵 $A,D$ 预先相乘形成新矩阵 $\\psi$, 张量网络的形式即为:\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n$\\downarrow$\n$-^{s_1} -\\square\\square^{\\psi}-\\square^{B}-^{s_2}-$\n这样我们就得到了\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha’,s_2}\\psi_{s_1\\alpha’}B_{\\alpha’s_2}|s_1\\rangle|s_2\\rangle $$\n同理, 我们也可以将矩阵 $D,B$ 预先相乘形成新矩阵 $\\psi$, 张量积算网络的形式为\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n$\\downarrow$\n$-^{s_1} -\\square^{A}-\\square\\square^{\\psi}-^{s_2}-$\n这样我们就得到了\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha,s_2}A_{s_1\\alpha}\\psi_{\\alpha s_2}|s_1\\rangle|s_2\\rangle $$\nQuiz $3$ 解析 #include \"itensor/all.h\" #include \"itensor/util/print_macro.h\" using namespace itensor; int main(){ // SVD of matrix M int Nrow = 4;int Ncol = 3; auto maxdim = std::min(Nrow,Ncol);//确定截断维度 auto M = Matrix(Nrow,Ncol); M(0,0) = 0.435839; M(0,1) = 0.223707; M(0,2) = 0.10; M(1,0) = 0.435839; M(1,1) = 0.223707; M(1,2) = -0.10; M(2,0) = 0.223707; M(2,1) = 0.435839; M(2,2) = 0.10; M(3,0) = 0.223707; M(3,1) = 0.435839; M(3,2) = -0.10;//初始化矩阵 Print(M); //声明变量的数据类型 Matrix U,V; Vector d;//用来接收对角元素,即奇异值 SVD(M,U,d,V); Print(U);Print(d);Print(V); int nkeep = 2;//取矩阵的截断维度 auto Dtrunc = Matrix(maxdim,maxdim);//只声明不定义,则初始化为0 for(auto j : range(nkeep)){ Dtrunc(j,j) = d(j); }//在对角线上填上截断保留的奇异值 auto Mtrunc = U*Dtrunc*transpose(V);//重新结合形成采取截断后的矩阵 Print(Mtrunc); auto diff = norm(M-Mtrunc);auto diff2 = sqr(diff);//取矩阵差的范数来评估截断的效果(diff) printfln(\"|M-Mtrunc|^2 = %.2f\",diff2); // SVD of two-site wavefunction auto s1 = Index(2,\"s1\");auto s2 = Index(2,\"s2\");//声明指标 auto sing = ITensor(s1,s2);auto prod = ITensor(s1,s2); //Make sing a singlet sing.set(s1=1,s2=2, 1./sqrt(2));sing.set(s1=2,s2=1,-1./sqrt(2)); //Make prod a product state prod.set(s1=1,s2=2,1.); for(Real mix = 0; mix \u003c= 1.; mix += 0.1){ // TODO: ADD CODE here to create // a new wavefunction that is // (1-mix) times a product state plus (mix) // times a singlet (i.e. maximally entangled state). auto wf = (1. - mix) * prod + mix * sing; wf /= norm(wf); //PrintData(wf); // SVD this wavefunction and analyze the results. // Try computing and plotting the entanglement entropy. ITensor A(s1),D,B; Spectrum spec = svd(wf,A,D,B); //PrintData(U);PrintData(D);PrintData(V); auto ent = 0.; //.eig(n)返回的是第(n+1)个本征值,这是因为数组下标从0开始;.numEigsKept()则是表示的特征值的数目 for(int n = 0;n \u003c spec.numEigsKept();n++){ auto P = sqr(spec.eig(n)); if(P \u003e 0) ent -= P*log(P); } //分别以两位小数和六位小数的形式输出 printfln(\"mix = %.2f, entropy = %.6f\\n\", mix, ent); } return 0; } 为了节省篇幅,原本需要多次执行的PrintData()函数被注释了. 如果你有查看其具体数值的需要可以在自己使用的时候启用.\n编译完成执行,在终端输出:\nM = |0.4358390 0.2237070 0.1000000| |0.4358390 0.2237070 -0.100000| |0.2237070 0.4358390 0.1000000| |0.2237070 0.4358390 -0.100000| U = |0.5000000 0.5000000 0.5000000| |0.5000000 0.5000000 -0.500000| |0.5000000 -0.500000 0.5000000| |0.5000000 -0.500000 -0.500000| d = 0.932739 0.3 0.2 V = |0.7071068 0.7071068 1.11671818E-16| |0.7071068 -0.707107 -8.81355030E-17| |-1.66426876E-17 -1.41285111E-16 1.0000000| Mtrunc = |0.4358390 0.2237070 -2.89544043E-17| |0.4358390 0.2237070 -2.89544043E-17| |0.2237070 0.4358390 1.34311222E-17| |0.2237070 0.4358390 1.34311222E-17| |M-Mtrunc|^2 = 0.04 mix = 0.00, entropy = 0.000000 mix = 0.10, entropy = 0.010473 mix = 0.20, entropy = 0.042683 mix = 0.30, entropy = 0.094817 mix = 0.40, entropy = 0.160729 mix = 0.50, entropy = 0.230729 mix = 0.60, entropy = 0.293765 mix = 0.70, entropy = 0.340279 mix = 0.80, entropy = 0.364548 mix = 0.90, entropy = 0.365602 mix = 1.00, entropy = 0.346574 Four 四结点 对于四节点的矩阵乘积态，我们可以用这样一个方程式来描述：\n$$ |\\Psi\\rangle=\\sum_{{s},{\\alpha}}M_{\\alpha_1}^{s_1}M_{\\alpha_1\\alpha_2}^{s_2}M_{\\alpha_2\\alpha_3}^{s_3}M_{\\alpha_4}^{s_4}|s_1s_2s_3s_4\\rangle $$\n前面我们已经学习过怎么处理将两个单节点结合为纠缠态的双节点. 所以我们这里可以将具有 $s_3$ 和 $s_4$ 上标的两个单节点组合形成具有 $s_3$ 和 $s_4$ 上标的纠缠态双节点.\n然后就是刚才所学的将双节点进行SVD分解, 而这里我们要分解的对象就是刚才合成的纠缠态双节点。\n为了继续保持四节点的性质，我们将分解出的A,D和B中的A与D结合,其上标是 $s_3$ ,而剩下来的B则单独作为结点, 其上标是 $s_4$.\n以这种方式得到的新的四节点张量, 我们称之为\"右正交\"(Right Orthogonal)或者说\"右规范\", 这是因为单独作为结点的 $B$ 是 酉的 ($BB^{\\dagger}=I$).\n显然, 这种右正交的性质是可以向左传递的. 比如, 我们取已经完成了SVD和AD结合的四节点张量中的具有 $s_2$ 和 $s_3$ 上标的单节点重复上述操作, 便可以让具有上标 $s_3$ 的单节点也具有右正交的性质.依此类推, 使得除了 $s_1$ 之外的所有单节点都具有右正交的性质.\n期望值 $\\langle\\hat{A}_1\\rangle$ 我们考虑一个具有4量子位的纠缠态波函数求第一量子位算符的期望值的过程.\n在一般情况下,我们通常是这样求解的(假设 $|\\psi\\rangle$ 已经规一化):\n$$ \\langle\\hat{A_1}\\rangle=\\sum_{s}\\overline{\\psi}_{s’_{1}s_{2}s_{3}s_{4}}A_{s’_{1}s_{1}}\\psi_{s_{1}s_{2}s_{3}s_{4}} $$\n这个过程显然是及其繁杂的, 在这种情况下时间复杂度以 $O(2^n)$ 的速度增长, 如果不以某种算法进行简化必然极其耗时.\n如果是已经经过了 SVD 分解的纠缠态波函数, 除了第一量子位 $s_1$ , 其余的所有单节点全部都具有右正交性质, 而我们求的是第一量子位的算符的期望值, 这也意味着其余量子位结合不会对第一量子位的运算产生任何影响.\n通过这样的算法, 计算量得到了大量简化.\n用程序语言来描述这个过程:\nSpinHalf sites(N); //表示sites是N个1/2自旋量子位的体系 MPS psi(sites); //以矩阵乘积态表示sites体系的波函数, 并且用psi来称呼这个波函数 computeGroundState(H,psi);//寻找哈密顿量H下的基态, psi被用以进行初始化 psi.position(2);//将psi的正则位置设置为第二个位置. Real sz_expect = (dag(prime(psi.A(2),Site)) * sites.op(\"Sz\",2) * psi.A(2)).real(); 正则位置Canonical Position\n在前面的SVD和regroup过程中我们只提到了\"右规范\", 实际上我们也很容易将其推广到\"左规范\", 这样的话我们就可以将正则位置定义为\"左规范\"和\"右规范\"同时成立的位置.\n在上面的例子中,因为我们要求的是第二量子位的自旋期望值, 为了简化我们就要将其左右的全部结点都规范化(具体结合的方向看正则位置的左右).\nQuiz $4$ 解析 矩阵乘积算子Matrix Product Operator(MPO)\n和矩阵乘积态(MPS)相似, MPO也是一种张量网络的表示方法. 它可以用来描述复杂量子系统的哈密顿量.\n#include \"itensor/all.h\" #include \"itensor/util/print_macro.h\" using namespace itensor; using std::vector; int main(){ int N = 50;//定义一个包含50个1/2自旋的系统'sites' auto sites = SpinHalf(N,{\"ConserveQNs=\",false});//\"ConserveQNs=\"设为false,表示不考虑量子数守恒. // TODO // 3. Adjust the external field to see how the // magnetization changes Real h = 0.5; //调整h来找到相变点.h = 1 时,系统从磁性相变无序相. // Create the MPO for the transverse field // Ising model auto ampo = AutoMPO(sites); //创建一个自动构造MPO的对象'ampo' //依次赋值 for(int j = 1; j \u003c N; ++j){ ampo += -4.0,\"Sz\",j,\"Sz\",j+1; } for(int j = 1; j \u003c= N; ++j){ ampo += -2*h,\"Sx\",j; } //哈密顿量的类型是MPO, 利用toMPO()函数将ampo里蕴含的信息转化为哈密顿量 auto H = toMPO(ampo); // Create a random starting state // For DMRG //随机生成一个初始态 auto psi0 = randomMPS(sites); // Run DMRG to get the ground state auto sweeps = Sweeps(5); //设置密度矩阵重整化群算法(DMRG)的最大迭代次数 sweeps.maxdim() = 5,10,20; //设置密度矩阵重整化群算法(DMRG)的最大纠缠矩阵维度的序列 sweeps.cutoff() = 1E-10; //设置奇异值的截断精度, 只有大于该值的奇异值才会被保留 auto [E,psi] = dmrg(H,psi0,sweeps,{\"Quiet\",true}); //H为系统的哈密顿量, 以psi0作为迭代起点运行算法, //'sweeps'是迭代的参数, //'{\"Quiet\",true}'表示静默运行(不输出详细的迭代信息) //返回值为基态能量和基态波函数, 以量 E 和 psi 对计算结果进行存储 //在终端查看基态能量值 printfln(\"Ground state energy = \",E); // 对psi进行共轭转置. 此时psidag上标级别为2. auto psidag = dag(prime(psi)); // A vector holding the operators used // in the expectation value. // All set to identity operators to start. // Note: this is one-indexed // (O[n] is the operator on site n) //创建长为N+1的向量, 用于存储测量算符.O[j]代表在第j个量子位上的测量算符 auto O = vector\u003cITensor\u003e(N+1); //对O进行初始化,方法是将所有的测量算符都设为单位算符 for(auto j : range1(N)){ O[j] = op(sites,\"Id\",j); //\"Id\"意指\"Identity\", 即单位算符 } // Position we will place our operator // 将本征位置选为正中, 即N/2.以这个位置来执行测量 int Npos = N/2; // TODO // 1. Add an operator to measure the magnetization // in the z direction at Npos. // HINT: use the op(...) function. // It provides spin operators \"Sx\", \"Sy\", \"Sz\", // you may want to scale your operator // to make it a Pauli matrix auto op_z = 2.0 * op(sites,\"Sz\",Npos); O[Npos] = op_z; // TODO // 2. Complete the following code // to measure the magnetization. // Print your results with PrintData(...) auto o = psidag(1) * O[1] * psi(1); for(auto j : range1(2,N)){ o *= psidag(j) * O[j] * psi(j); } PrintData(o); // TODO // 3. Adjust the transverse field h at the top of the // file to find the critical point. // HINT: think about the field limits h -\u003e 0 // and h -\u003e infinity return 0; } 编译执行后终端输出：\nvN Entropy at center bond b=25 = 0.002062540436 Eigs at center bond b=25: 0.9998 Largest link dim during sweep 1/5 was 4 Largest truncation error: 4.11222e-11 Energy after sweep 1/5 is -51.205898332822 Sweep 1/5 CPU time = 0.0146s (Wall time = 0.0177s) vN Entropy at center bond b=25 = 0.006828488484 Eigs at center bond b=25: 0.9992 Largest link dim during sweep 2/5 was 10 Largest truncation error: 1.88078e-08 Energy after sweep 2/5 is -51.298393038956 Sweep 2/5 CPU time = 0.0181s (Wall time = 0.0181s) vN Entropy at center bond b=25 = 0.002920154202 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 3/5 was 18 Largest truncation error: 9.69913e-11 Energy after sweep 3/5 is -52.306536772989 Sweep 3/5 CPU time = 0.0210s (Wall time = 0.0210s) vN Entropy at center bond b=25 = 0.002920148259 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 4/5 was 6 Largest truncation error: 9.45633e-11 Energy after sweep 4/5 is -52.306549436787 Sweep 4/5 CPU time = 0.0179s (Wall time = 0.0180s) vN Entropy at center bond b=25 = 0.002920145615 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 5/5 was 5 Largest truncation error: 9.18628e-11 Energy after sweep 5/5 is -52.306549436806 Sweep 5/5 CPU time = 0.0168s (Wall time = 0.0168s) Ground state energy = -52.3065 o = ITensor ord=0: {norm=0.96 (Dense Real)} -0.964679 “小车” Trotter – Suzuki formula 上一章中我们测量的是单个量子位的期望值, 当我们增加有效算子(指在该量子位上并非单位算符\"Id\")的数量, 张量网络看上去就如同小车一般.\n上述语句均为强行解释.事实上这个算法来源于模拟哈密顿量动力学中的Trotter – Suzuki formula, Trotter到底是形容\"小车\"还是人名实际上并不太清楚.\n现在我们设想一个已经对于相邻的两个量子位的左/右都已经完成左/右规范化,那么现在要做的就是计算这两个相邻量子位上对应算符的期望值.\n和前面章节中处理二量子位的纠缠态类似, 我们可以将这两个量子位进行合并, 进行SVD分解, 再重组(至于是AD组合还是DB组合,可以根据自己需求来调整).\n注意: 这种算法仅适用于相邻量子位并不属于同一方向规范的情况(比如并不是两个正则位置, 而是在正则位置的同一边), 否则以截断SVD方法计算得到的结果并非全局最优.\nTrotter算法的精髓在于,将哈密顿量(也就是我们所用的算子)分解为若干个可以独立演化的小块, 而且如果哈密顿量是短程相互作用, 那么这种分解的效果就更好. 对于长程作用的哈密顿量Trotter算法的效率就会明显降低.在上面我们所举的例子里, 有效的哈密顿量仅涉及两个相邻的量子位, 可以说是符合短程的定义.\n如果哈密顿量中的相互作用都是短程的, 我们可以将哈密顿量分解为小块, 用自旋系统为例, 我们可以用这样的方程来描述:\n$$ \\begin{equation} \\hat{H}=\\hat{H_1}+\\hat{H_2}+\\hat{H_3}+\\dots \\\\ =\\sum_{j}\\hat{S_{j}}\\cdot\\hat{S_{j+1}} \\\\ =(\\hat{S_{1}}\\cdot\\hat{S_{2}})+(\\hat{S_{2}}\\cdot\\hat{S_{3}})+(\\hat{S_{3}}\\cdot\\hat{S_{4}})\\dots \\end{equation} $$\n那么假设系统演化了一极短的虚时间 $\\tau$,我们可以将系统的演化写作:\n$$ \\begin{aligned} e^{-\\tau\\hat{H}}\\approxeq \u0026e^{-\\tau\\hat{H_1}/2}e^{-\\tau\\hat{H_2}/2}e^{-\\tau\\hat{H}_3/2}\\dots\\ \u0026\\dots e^{-\\tau\\hat{H}_3/2}e^{-\\tau\\hat{H_2}/2}e^{-\\tau\\hat{H_1}/2}+O(\\tau^3) \\end{aligned} $$\n虚时演化\n对于一个一般的表达式 $|\\psi’\\rangle=e^{-\\tau\\hat{H}}|\\psi\\rangle$ (省略了 $\\hbar$ ),有两种情况:\n$\\tau$ 是实数, 那么相当于 $\\tau = i\\tau’$, 其中 $\\tau’$是虚时间. 那么我们只要执行足够多步, 就可以搜索到基态. $\\tau$ 是虚数, 那么就是一般的动力学表述, 相当于 $\\tau = it$, 原方程变为 $|\\psi’\\rangle=e^{-it\\hat{H}}|\\psi\\rangle$ 对于第一种情况, 有一种应用的例子, 即通过取 $\\beta/2=1/(2T)$ 的虚时演化来模拟有限温度.\n更详细的说, 就是取 $\\tau = \\frac{1}{k_BT}$ ,就相当于进行了一次虚时间演化. 在每一步执行完成后我们要对系统的状态进行记录, 从而对系统的在温度T下的性质进行统计平均.\n我们用.gif 来演示这一过程:\n因为我们每一步都只取了每个量子位对应分块哈密顿量的 $\\frac{1}{2}$ ,所以通过往返执行一遍可以不改变纠缠态的规范性.\nQuiz 5 解析 #include \"itensor/all.h\" #include \"itensor/util/print_macro.h\" using std::vector; using std::move; using namespace itensor; struct TGate{ int i1 = 0;int i2 = 0; //i1, i2是用来指定虚时演化算子中产生作用的两个自旋量子位编号 ITensor G; //G被声明为ITensor类型，用来存储具体的虚时演化算子值 TGate() { } TGate(int i1_, int i2_, ITensor G_) : i1(i1_), i2(i2_), G(G_) { } }; int main(){ int N = 20; auto sites = SpinHalf(N);//声明系统是20个1/2自旋子的系统 auto init = InitState(sites); for(auto n : range1(N)){ init.set(n, n%2 == 1 ? \"Up\" : \"Dn\"); }//并且将该系统初始化为Neel态(相邻自旋总相反) //将该状态init通过MPS()转译为矩阵乘积态(MPS)的形式 auto psi = MPS(init); //定义虚时演化的总时间和时间间隔(步长) Real ttotal = 2;Real tstep = 0.1; //检查时间步长和总时间是否合法 auto nt = int(ttotal/tstep+(1e-9*(ttotal/tstep))); if(std::fabs(nt*tstep-ttotal) \u003e 1E-9){ Error(\"Timestep not commensurate with total time\"); } //Create Trotter gates (imaginary time) //定义数据类型为TGate的vector容器，用来存储虚时演化算子 auto gates = vector\u003cTGate\u003e{}; for(int b = 1; b \u003c N; ++b){ //从头开始构建哈密顿量 auto hh = op(sites,\"Sz\",b)*op(sites,\"Sz\",b+1); hh += 0.5*op(sites,\"Sp\",b)*op(sites,\"Sm\",b+1); hh += 0.5*op(sites,\"Sm\",b)*op(sites,\"Sp\",b+1); //计算半步长的虚时演化算子 auto G = expHermitian(hh,-tstep/2.); //将虚时演化算子存储到名为gates的容器中(序列尾部) //b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置. gates.emplace_back(b,b+1,move(G)); } for(int b = N-1; b \u003e= 1; --b){ //从尾开始构建哈密顿量 ITensor hh = op(sites,\"Sz\",b)*op(sites,\"Sz\",b+1); hh += 0.5*op(sites,\"Sp\",b)*op(sites,\"Sm\",b+1); hh += 0.5*op(sites,\"Sm\",b)*op(sites,\"Sp\",b+1); //计算半步长的虚时演化算子 auto G = expHermitian(hh,-tstep/2.); //将虚时演化算子存储到名为gates的容器中(序列尾部) //b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置. gates.emplace_back(b,b+1,move(G)); } for(int step = 1; step \u003c= nt; ++step){ //将之前计算存储好的分块算子一一取出 for(auto\u0026 gate : gates){ //读取分块算子对应的作用位置 auto b = gate.i1; //读取分块算子的具体值 auto\u0026 G = gate.G; //设置正则位置为当前循环中的b psi.position(b); //将相邻量子位b和b+1合成为新张量AA auto AA = psi(b) * psi(b+1); // TODO: ADD CODE here that applies // the gate G to the MPS bond // tensor \"AA\" by multiplying // G and AA using the * operator // G is an ITensor // with index structure: // s_{b}' s_{b+1}' // | | // ======== // | | // s_{b} s_{b+1} // After applying G to AA, don't forget // to reset the prime level to 0 by using // the noPrime method. //将G和AA相乘 AA *= G; AA.noPrime();//将AA的上标级别降为0, 因为SVD操作要求上标级别是一致的 //Normalize AA after applying G AA /= norm(AA); //SVD AA to restore MPS form auto [U,D,V] = svd(AA,inds(psi(b)),{\"Cutoff\",1E-10}); psi.set(b,U); psi.set(b+1,D*V); } printfln(\"Step %d/%d\",step,nt); } //Make Heisenberg H to //conveniently measure energy auto ampo = AutoMPO(sites); for(auto j : range1(N-1)){ ampo += 0.5,\"S+\",j,\"S-\",j+1; ampo += 0.5,\"S-\",j,\"S+\",j+1; ampo += \"Sz\",j,\"Sz\",j+1; } auto H = toMPO(ampo); printfln(\"Energy = %.20f\",inner(psi,H,psi)); // Exact ground state energy of N=20 // Heisenberg model:E0 = -8.6824733306 return 0; } 编译执行后, 在终端输出的结果:\nStep 1/20 Step 2/20 Step 3/20 Step 4/20 Step 5/20 Step 6/20 Step 7/20 Step 8/20 Step 9/20 Step 10/20 Step 11/20 Step 12/20 Step 13/20 Step 14/20 Step 15/20 Step 16/20 Step 17/20 Step 18/20 Step 19/20 Step 20/20 Energy = -8.51422469470028886462 最后的结果和理论上计算得到的 $-8.6824733306$ 相差约为 $1.94%$, 可以说差距不大.\n矩阵乘积算子 MPO 我们已经知道, 在张量网络中, 一个哈密顿量 $\\hat{H}$ 看上去大概是这个样子:\n$$ \\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|} $$\n而一个对应量子位数的纠缠态波函数 $|\\Psi\\rangle$ 则是这样:\n$$ \\sum^{|}-\\sum^{|}-\\sum^{|}-\\sum^{|}-\\sum^{|} $$\n在上面的学习中我们已经知道, 要让 $\\hat{H}$ 作用到 $|\\Psi\\rangle$ 上, 其实就是将上下标进行结合的过程.\n那么既然 $|\\Psi\\rangle$ 能够写作矩阵乘积的形式, 我们自然也可以对 $\\hat{H}$ 进行同样的要求,将其化为张量网络中的这种形式:\n$$ \\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|} $$\n我们取其中一个张量进行分析:\n$$ ^{1}-\\sum_{|_{4}}^{|^{3}}-^{2} $$\n这里面的$1$和$2$代表的时张量左右的指标, 而$3$和$4$代表的是张量上下的指标(通常和作用与某量子位或其它物理量有关). 多个这样的张量乘在一起就能化成矩阵乘积算子的形式.\n我们不妨用一个更具体的例子:\n$$\\hat{H} = \\begin{bmatrix} 0 \u0026 1\\\\ \\end{bmatrix}_{A} \\begin{bmatrix} \\hat{I} \u0026 \\\\ \\hat{\\sigma}^{z} \u0026 \\hat{I}\\\\ \\end{bmatrix}_{B} \\begin{bmatrix} \\hat{I} \u0026 \\\\ \\hat{\\sigma}^{z} \u0026 \\hat{I}\\\\ \\end{bmatrix}_{C} \\begin{bmatrix} 1 \\\\ 0\\\\ \\end{bmatrix}_{D} $$\n在矩阵的右下角使用A B C D来进行标记.它们以张量网络画出的形式大概像这样:\n$$ \\sum{A}-\\sum_{|}^{|}{B}-\\sum_{|}^{|}{C}-\\sum{D} $$\n不难看出实际上A和B,以及C和D是能够各自结合形成新矩阵的, 我们写出相乘得到的结果:\n$$ \\hat{H} = \\begin{bmatrix} \\hat{\\sigma}^{z} \u0026 \\hat{I}\\\\ \\end{bmatrix}_{A’} \\begin{bmatrix} \\hat{I}\\\\ \\hat{\\sigma}^{z} \\\\ \\end{bmatrix}_{B’} $$\n在方程上我们这样表述:\n$$ \\hat{H} = \\hat{\\sigma_{1}}^{z}\\bigotimes\\hat{I_{2}} + \\hat{I_{1}}\\bigotimes\\hat{\\sigma_{2}}^{z} $$\n当然这一个式子我们还可以进行继续的简化, 完成最后一步的乘法:\n$$ \\hat{H} = \\hat{\\sigma_{1}}^{z}+\\hat{\\sigma_{2}}^{z} =\\sum_{i}\\hat{\\sigma_{i}}^{z} $$\n现在再动手算更复杂的例子.\n$$\\hat{H}= \\begin{bmatrix} 0 \u0026 0 \u0026 1\\\\ \\end{bmatrix} \\begin{bmatrix} \\hat{I} \u0026 \u0026 \\\\ \\hat{\\sigma}^{z} \u0026 \u0026 \\\\ -h\\hat{\\sigma}^{x} \u0026 \\hat{\\sigma}^{z} \u0026 \\hat{I}\\\\ \\end{bmatrix} \\begin{bmatrix} \\hat{I} \u0026 \u0026 \\\\ \\hat{\\sigma}^{z} \u0026 \u0026 \\\\ -h\\hat{\\sigma}^{x} \u0026 \\hat{\\sigma}^{z} \u0026 \\hat{I}\\\\ \\end{bmatrix} \\begin{bmatrix} 1\\\\ 0\\\\ 0\\\\ \\end{bmatrix} $$\n先算两边, 再算中间, 即有\n$$ \\hat{H}=[-h\\hat{\\sigma}^{x},\\hat{\\sigma}^{z},\\hat{I}][\\hat{I},\\hat{\\sigma}^{z},-h\\hat{\\sigma}^{x}]^{T}=\\sum_{j}\\hat{\\sigma_{j}}^{z}\\hat{\\sigma_{j+1}}^{z}-h\\hat{\\sigma_{j}}^{x} $$\n本章没有对应的Quiz\nDMRG 密度矩阵重整化群 警告\n以下部分内容, 可能仅适用于1D的情况, 虽然ITensor开发了一些基于基于DMRG算法的扩展用以应对二维情况下系统, 但是这些方法的实现复杂度通常较高, 需要较长的计算时间和更高的计算资源.\n如果你想要对二维系统进行计算, 请考虑使用PEPS(投影纠缠对态算法)或者MERA(Multi-scale Entanglement Renormalization Ansatz,多尺度嵌套正交模型)算法, 除了ITensor外你也可以考虑使用Qiskit, PyQuante等计算库, 从而实现基于哈密顿量对角化的能带计算.\n所以为什么要学ITensor呢? 直接用matlab模拟不就好了\n如果我们想要求解一维哈密顿量的基态, DMRG 将是最好的方法.\n方程式的形式如下:\n$\\hat{H}|\\Psi\\rangle = E|\\Psi\\rangle$\n其中 $\\hat{H}$ 和 $|\\Psi\\rangle$ 都化为对应量子位数的 矩阵乘积形式(MPO 和 MPS).\nMPS的构造中不只是用到了我们之前所学的SVD和ReGroup, 它还包括了一些我们没有提到的处理操作, 这些操作被统称为\"规范化变换\", 比如对张量进行单位化(unitarization).\n这些处理是为了MPS在计算时具有良好性质, 比如计算物理量时具有最小误差.\nImporttant: MPS should be in definite gauge. I.e.most tensors unitary.\n就是在要求矩阵乘积态应当已经被规范化, 也就是大多数量子位的张量都是幺正的.\n幺正 Unitary\n幺正本身是一个线性代数里的概念, 在这里我们用更物理一些的语言来描述这个性质.\n如果一个算子 $\\hat{U}$ , 还有一个态矢量 $|\\psi\\rangle$ ,能够满足以下条件:\n$\\hat{U}|\\psi\\rangle\\neq 0$; $||\\hat{U}|\\psi\\rangle|| = ||\\psi\\rangle||$; $\\langle\\Phi|\\hat{U}|\\psi\\rangle = \\langle\\Phi|\\psi\\rangle$ 其中 $||\\psi\\rangle||$ 代表态势 $|\\psi\\rangle$ 的长度, 这个量可以通过求内积来得到. 那么我们就可以称这个算子是幺正的. 所以我们可以选定一个特定的位置(正则位置), 将其左右两边的张量全部都规范化处理, 从而定义出正交归一的基.\n这样, 我们就可以计算出期望值 $\\langle\\Psi|\\hat{H}|\\Psi\\rangle$ .其中 $|\\Psi\\rangle$ 和 $\\hat{H}$ 都是矩阵乘积形式. 按照我们前面所说的,\nMERA算法 Multi-scale Entanglement Renormalization Ansatz\n多尺度嵌套正交矩形模型. 这是对重整化群方法的扩展. MERA将系统分解为一系列的张量, 每个张量代表了系统不同尺度下的状态. 每个张量的大小表示该尺度的自由度数目.\n这些张量通过特定的变化相互连接, 从而形成具有分形结构的网络. 这样, 我们就可以将系统的纠缠结构表示为不同尺度上的简单张量网络.\n具体来说, 每个张量被分为两个部分, 即上部分和下部分. 上部分表示的是低尺度的信息, 下部分表示的是高尺度的信息. 通过重复应用加密和解密操作, 就可以得到不同尺度下的系统状态.\n",
  "wordCount" : "11181",
  "inLanguage": "zh",
  "datePublished": "2022-05-05T00:18:23+08:00",
  "dateModified": "2022-05-05T00:18:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "Muartz"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "无处惹尘埃",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Muatyz.github.io/img/Head32.png"
    }
  }
}
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  CommonHTML: {
  scale: 100
  },
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
  
  
  
  var all = MathJax.Hub.getAllJax(), i;
  for(i = 0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>

<style>
  code.has-jax {
      font: "LXGW WenKai Screen", sans-serif, Arial;
      scale: 1;
      background: "LXGW WenKai Screen", sans-serif, Arial;
      border: "LXGW WenKai Screen", sans-serif, Arial;
      color: #515151;
  }
</style>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Muatyz.github.io/" accesskey="h" title="计算物理学习日志 (Alt + H)">
            <img src="https://Muatyz.github.io/img/Head64.png" alt="logo" aria-label="logo"
                 height="35">计算物理学习日志</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Muatyz.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://Muatyz.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://Muatyz.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://Muatyz.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://Muatyz.github.io/posts/phy/">🧱 PHY</a>&nbsp;»&nbsp;<a href="https://Muatyz.github.io/posts/phy/calphy/">💻 Computation Physics</a></div>
            <h1 class="post-title">
                ITensor基础语法说明
            </h1>
            <div class="post-description">
                介绍以DMRG算法为核心的itensor库使用方法
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2022-05-05
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>11181字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>23分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Muartz
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://Muatyz.github.io/tags/physics/" style="color: var(--secondary)!important;">Physics</a>
                &nbsp;<a href="https://Muatyz.github.io/tags/numerical-calculation/" style="color: var(--secondary)!important;">Numerical Calculation</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://Muatyz.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId: "https://www.muartz.com", 
                                region: "ap-shanghai", 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#one-site-%e5%8d%95%e8%8a%82%e7%82%b9" aria-label="one site 单节点">one site 单节点</a><ul>
                        
                <li>
                    <a href="#operators-%e6%93%8d%e4%bd%9c%e7%ac%a6%e7%ae%97%e5%ad%90-hata" aria-label="Operators 操作符/算子 $\hat{A}$">Operators 操作符/算子 $\hat{A}$</a></li>
                <li>
                    <a href="#%e6%9c%9f%e6%9c%9b%e5%80%bc-langlehatarangle" aria-label="期望值 $\langle\hat{A}\rangle$">期望值 $\langle\hat{A}\rangle$</a></li>
                <li>
                    <a href="#quiz-1-%e8%a7%a3%e6%9e%90" aria-label="Quiz $1$ 解析">Quiz $1$ 解析</a></li></ul>
                </li>
                <li>
                    <a href="#two-sites-%e5%8f%8c%e8%8a%82%e7%82%b9" aria-label="Two Sites 双节点">Two Sites 双节点</a><ul>
                        
                <li>
                    <a href="#%e7%ba%a0%e7%bc%a0%e6%80%81" aria-label="纠缠态">纠缠态</a></li>
                <li>
                    <a href="#%e5%93%88%e5%af%86%e9%a1%bf%e9%87%8fhath" aria-label="哈密顿量$\hat{H}$">哈密顿量$\hat{H}$</a></li>
                <li>
                    <a href="#quiz-2-%e8%a7%a3%e6%9e%90" aria-label="Quiz $2$ 解析">Quiz $2$ 解析</a></li></ul>
                </li>
                <li>
                    <a href="#svd-%e5%a5%87%e5%bc%82%e5%80%bc%e5%88%86%e8%a7%a3" aria-label="SVD 奇异值分解">SVD 奇异值分解</a><ul>
                        
                <li>
                    <a href="#%e5%8f%8c%e8%87%aa%e6%97%8b%e6%b3%a2%e5%87%bd%e6%95%b0" aria-label="双自旋波函数">双自旋波函数</a></li>
                <li>
                    <a href="#quiz-3-%e8%a7%a3%e6%9e%90" aria-label="Quiz $3$ 解析">Quiz $3$ 解析</a></li></ul>
                </li>
                <li>
                    <a href="#four-%e5%9b%9b%e7%bb%93%e7%82%b9" aria-label="Four 四结点">Four 四结点</a><ul>
                        
                <li>
                    <a href="#%e6%9c%9f%e6%9c%9b%e5%80%bc-langlehata_1rangle" aria-label="期望值 $\langle\hat{A}_1\rangle$">期望值 $\langle\hat{A}_1\rangle$</a></li>
                <li>
                    <a href="#quiz-4-%e8%a7%a3%e6%9e%90" aria-label="Quiz $4$ 解析">Quiz $4$ 解析</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e8%bd%a6-trotter--suzuki-formula" aria-label="&ldquo;小车&rdquo; Trotter – Suzuki formula"><del>&ldquo;小车&rdquo;</del> Trotter – Suzuki formula</a></li>
                <li>
                    <a href="#quiz-5-%e8%a7%a3%e6%9e%90" aria-label="Quiz 5 解析">Quiz 5 解析</a></li>
                <li>
                    <a href="#%e7%9f%a9%e9%98%b5%e4%b9%98%e7%a7%af%e7%ae%97%e5%ad%90-mpo" aria-label="矩阵乘积算子 MPO">矩阵乘积算子 <strong>MPO</strong></a></li>
                <li>
                    <a href="#dmrg-%e5%af%86%e5%ba%a6%e7%9f%a9%e9%98%b5%e9%87%8d%e6%95%b4%e5%8c%96%e7%be%a4" aria-label="DMRG 密度矩阵重整化群"><strong>DMRG</strong> 密度矩阵重整化群</a></li>
                <li>
                    <a href="#mera%e7%ae%97%e6%b3%95" aria-label="MERA算法"><strong>MERA</strong>算法</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="one-site-单节点">one site 单节点<a hidden class="anchor" aria-hidden="true" href="#one-site-单节点">#</a></h1>
<blockquote>
<p>Site</p>
<p>意指&quot;节点&quot;.</p>
</blockquote>
<p>单节点的自旋为 $\frac{1}{2}$ 的波函数,有两个基底.</p>
<p>$|s=1\rangle=|\uparrow\rangle;|s=2\rangle=|\downarrow\rangle$</p>
<p>对于一般的自旋为 $\frac{1}{2}$ 的波函数,可以写成如下形式:</p>
<p>$|\psi\rangle=\sum_{s=1}^{2}\psi_s|s\rangle(\psi_s\in\mathcal{C})$</p>
<p>使用张量数学来处理这个单节点波函数,
即 $|\psi_s\rangle$ 对应一个有一个&quot;触手&quot;的结点.展开形式为 $(^{\psi_1}_{\psi_2})$ , $\psi_1,\psi_2$ 又各自是一个单&quot;触手&quot;的结点.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Index <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;s&#34;</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//&#34;s&#34;代表的是Index的命名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2是Index的维度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ITensor <span style="color:#a6e22e">psi</span>(s);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//由于只声明不定义,所以初始值为0
</span></span></span></code></pre></div><blockquote>
<p><strong>Index 指标</strong></p>
<p>指的是表示某种物理量的符号.这个符号
可以是矢量, 张量, 算符.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Index <span style="color:#a6e22e">s</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s&#34;</span>);
</span></span><span style="display:flex;"><span>Index <span style="color:#a6e22e">t</span>(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#34;t&#34;</span>);
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">T</span>(s,t);
</span></span></code></pre></div><p>这个表示的就是创建了一个二维的物理量,我们用$s$来标记它;物理量t则是三维的.
而Itensor的大小则是 $2\times 3$.</p>
</blockquote>
<p>对 $|\psi_s\rangle$ 进行初始化操作.我们不妨将其初始化为基矢:</p>
<p>$|\psi_s\rangle=|\uparrow\rangle$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Index <span style="color:#a6e22e">s</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//在最新的ITensor语法规范中,Index (string, int)的语法已经被弃用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//目前的语法应当是Index (int, string)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ITensor <span style="color:#a6e22e">psi</span>(s);
</span></span><span style="display:flex;"><span>psi(s(<span style="color:#ae81ff">1</span>)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>PrintData(psi);
</span></span></code></pre></div><p>本示例代码应该会输出:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>psi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>1: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>414|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> 1.0000000
</span></span></code></pre></div><h2 id="operators-操作符算子-hata">Operators 操作符/算子 $\hat{A}$<a hidden class="anchor" aria-hidden="true" href="#operators-操作符算子-hata">#</a></h2>
<p>算子体现在张量网络上就是一个拥有两个&quot;触手&quot;的结点, 它可以和只有一个&quot;触手&quot;的结点结合, 从而生成一个新的只有一个触手的结点.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">Sz</span>(s,prime(s));
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">Sx</span>(s,prime(s));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//prime(s)是指的对s进行共轭操作
</span></span></span></code></pre></div><p>如果要对一个向量或者矩阵进行转置,共轭等操作,我们可以用被称为<strong>上下标</strong>的操作来表示.比如, $A_{ij}^{&rsquo;}=A_{ji}$, $A_{ij}^{\dagger}=A_{ji}$ 等.</p>
<p><code>prime(s)</code>就代表了对指标进行上标操作所得到的量.</p>
<blockquote>
<p><strong>Prime Level</strong> 上标级别</p>
<p>指标有一个属性被称为<strong>prime level</strong>, 表示是否被某个操作升降级.默认情况下指标的上标级别为0.</p>
<p>这个量的作用是用来对两个张量进行比较, 在进行某些操作时, 上标必须要满足某些需求运算才能够成立.</p>
<p>比如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Index <span style="color:#a6e22e">s</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s&#34;</span>);
</span></span><span style="display:flex;"><span>Index <span style="color:#a6e22e">t</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;2&#34;</span>);
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">A</span>(s,t);
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">B</span>(s,t);<span style="color:#75715e">// s, t 都是上标级别为 0 的指标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>C <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> prime(B);<span style="color:#75715e">// prime(B) 表示将 B 中的所有指标上标级别加 1
</span></span></span></code></pre></div><p>在这里, <code>A * prime(B)</code>就是一个不允许指标重复的操作.所以为了完成这个计算,我们需要对<code>B</code>进行上标级别升级的操作,也就是使用<code>prime()</code>函数.</p>
</blockquote>
<p>现在我们来对 $\hat{S}_z,\hat{S}_x$ 算子进行定义.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">Sz</span>(s,prime(s)),Sx(s,prime(s));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// commaInit(Sz,s,prime(s)) =  0.5, 0.0,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                             0.0,-0.5;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// commaInit(Sx,s,prime(s)) =  0.0, 0.5,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                             0.5, 0.0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//commaInit的语法已经被弃用, 应当使用.set()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Sz
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Sz.set(s(<span style="color:#ae81ff">1</span>),prime(s)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>Sz.set(s(<span style="color:#ae81ff">2</span>),prime(s)(<span style="color:#ae81ff">2</span>),<span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Sx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Sx.set(s(<span style="color:#ae81ff">1</span>),prime(s)(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>Sx.set(s(<span style="color:#ae81ff">2</span>),prime(s)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0.5</span>);<span style="color:#75715e">//设置分量
</span></span></span></code></pre></div><p>现在我们尝试对波函数 $|\psi\rangle$ 进行求某方向自旋的操作.</p>
<p>即方程上的</p>
<p>$$
(\hat{S_{x}})_{s&rsquo;}^{s}\psi_{s}
$$</p>
<p>对应的是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor phi <span style="color:#f92672">=</span> Sx <span style="color:#f92672">*</span> psi;
</span></span></code></pre></div><p>(注意算符的上标要和波函数的下标相同, 这样的操作才是被允许的. $s$和$s&rsquo;$的上标等级不同, 所以是不匹配的)</p>
<p>为了研究经过求自旋的量 $|\phi\rangle$ 的具体情况, 我们将其输出在终端:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor phi <span style="color:#f92672">=</span> Sx <span style="color:#f92672">*</span> psi;
</span></span><span style="display:flex;"><span>PrintData(phi);
</span></span></code></pre></div><p>输出的结果应该是:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>phi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>1: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>816|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>0.50 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span> 0.5000000
</span></span></code></pre></div><p>我们来看看更多的结果. 如果有 $|\psi_s\rangle=(|^{\cos{\frac{\theta}{2}}}_{\sin{\frac{\theta}{2}}}\rangle)_{\theta=\frac{\pi}{4}}$, 那么我们可以这样描述:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Real theta <span style="color:#f92672">=</span> Pi<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// psi(s(1)) = cos(theta/2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// psi(s(2)) = sin(theta/2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//该语法已被弃用,使用.set()替代
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>psi.set(s(<span style="color:#ae81ff">1</span>),cos(theta<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>psi.set(s(<span style="color:#ae81ff">2</span>),sin(theta<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>PrintData(psi);
</span></span></code></pre></div><p>终端会输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>psi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>1: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>977|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> 0.9238795
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span> 0.3826834
</span></span></code></pre></div><h2 id="期望值-langlehatarangle">期望值 $\langle\hat{A}\rangle$<a hidden class="anchor" aria-hidden="true" href="#期望值-langlehatarangle">#</a></h2>
<p>在物理上我们定义算符 $\hat{A}$ 的期望值为 $\langle\psi|\hat{A}|\psi\rangle$.</p>
<p>我们不妨求自旋算符 $\hat{S_z}$ 的期望值. 在张量网络上, 这个过程体现为, 作为算符的&quot;具有上下两个触手的结点&quot;的每个触手分别连接一个&quot;只有单触手的结点&quot;(也就是代表着单节点波函数).</p>
<p>我们用程序语言来描述这个过程:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor cpsi <span style="color:#f92672">=</span> dag(prime(psi));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Real zz = (cpsi * Sz * psi).toReal();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Real xx = (cpsi * Sx * psi).toReal();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// toReal()函数已弃用,使用.real()替代
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Real zz <span style="color:#f92672">=</span> (cpsi <span style="color:#f92672">*</span> Sz <span style="color:#f92672">*</span> psi).real();
</span></span><span style="display:flex;"><span>Real xx <span style="color:#f92672">=</span> (cpsi <span style="color:#f92672">*</span> Sx <span style="color:#f92672">*</span> psi).real();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// println(&#34;&lt;Sz&gt;=&#34;,zz);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// println(&#34;&lt;Sx&gt;=&#34;,xx);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// println()已弃用,使用printfln()替代
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>printfln(<span style="color:#e6db74">&#34;&lt;Sz&gt;=&#34;</span>,zz);
</span></span><span style="display:flex;"><span>printfln(<span style="color:#e6db74">&#34;&lt;Sx&gt;=&#34;</span>,xx);
</span></span></code></pre></div><p>其中<code>ITensor cpsi = dag(prime(psi));</code>就是一个将 $\psi$ 先取转置后取共轭的过程, 所以<code>cpsi</code>的上标级数为$2$. 我们也可以推测得知, 算符 $\hat{S}_x,\hat{S}_z$的上标级数为$1$.</p>
<p>终端输出为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;Sz&gt;<span style="color:#f92672">=</span>0.353553
</span></span><span style="display:flex;"><span>&lt;Sx&gt;<span style="color:#f92672">=</span>0.353553
</span></span></code></pre></div><p>观察到 $\sqrt{\langle S_z\rangle ^2 + \langle S_x\rangle ^2} = \frac{1}{2}$</p>
<p>我们可以将这个过程进行类似结合率的分析:</p>
<p>$\langle\psi|\hat{S}_z|\psi\rangle = \langle\psi|\hat{S}_z\psi\rangle$.</p>
<p>用代码来描述结合律的过程:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor Zpsi <span style="color:#f92672">=</span> Sz <span style="color:#f92672">*</span> psi;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//因为Sz以s为上标,psi以s为下标,所以允许运算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ITensor expect <span style="color:#f92672">=</span> cpsi <span style="color:#f92672">*</span> Zpsi;
</span></span><span style="display:flex;"><span>Real zz <span style="color:#f92672">=</span> expect.real()
</span></span></code></pre></div><h2 id="quiz-1-解析">Quiz $1$ 解析<a hidden class="anchor" aria-hidden="true" href="#quiz-1-解析">#</a></h2>
<blockquote>
<p>提示</p>
<p>原文所提示的函数<code>elt()</code>已经弃用.所以采用的是传统的<code>prime(A) * B</code>方式. 如果你想使用函数而非 <code>*</code>来得到内积, 你应当采用函数<code>inner()</code></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/all.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/util/print_macro.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> itensor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Define our Index 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// (the space we are working with)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> s <span style="color:#f92672">=</span> Index(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Operators 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> Sx <span style="color:#f92672">=</span> ITensor(s,prime(s));
</span></span><span style="display:flex;"><span>    Sx.set(s(<span style="color:#ae81ff">1</span>),prime(s)(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>    Sx.set(s(<span style="color:#ae81ff">2</span>),prime(s)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>    PrintData(Sx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Single-site wavefunction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> psi <span style="color:#f92672">=</span> ITensor(s); <span style="color:#75715e">//initialized to zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. make the above wavefunction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    the (normalized) positive Sx eigenstate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    psi.set(s(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>    psi.set(s(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>    PrintData(psi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. Compute |phi&gt; = Sx |psi&gt; using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    the Sx and psi ITensors above
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    AND
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    compute: auto olap = &lt;psi|phi&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    using the * operator and elt(...) method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    Print the result with PrintData(...).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> phi <span style="color:#f92672">=</span> Sx <span style="color:#f92672">*</span> psi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> olap <span style="color:#f92672">=</span> prime(psi) <span style="color:#f92672">*</span> phi;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//auto olap = elt(prime(psi),phi);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PrintData(olap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. Try normalizing |phi&gt; and recompute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    the inner product &lt;psi|phi&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    Print the result with PrintData(...).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    HINT: use phi /= norm(phi)) to normalize.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    phi <span style="color:#f92672">/=</span> norm(phi);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//auto olap2 = eltC(prime(psi),phi);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> olap2 <span style="color:#f92672">=</span> prime(psi) <span style="color:#f92672">*</span> phi;
</span></span><span style="display:flex;"><span>    PrintData(olap2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出得到:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Sx <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>15|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>15|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>0.71 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,1<span style="color:#f92672">)</span> 0.5000000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2<span style="color:#f92672">)</span> 0.5000000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>psi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>1: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>15|<span style="color:#e6db74">&#34;s&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> 0.7071068
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span> 0.7071068
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>olap <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>0: 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>0.50 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span>  0.5000000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>olap2 <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>0: 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span>  1.0000000
</span></span></code></pre></div><h1 id="two-sites-双节点">Two Sites 双节点<a hidden class="anchor" aria-hidden="true" href="#two-sites-双节点">#</a></h1>
<h2 id="纠缠态">纠缠态<a hidden class="anchor" aria-hidden="true" href="#纠缠态">#</a></h2>
<p>对于双自旋的波函数, 我们一般的描述方程是:</p>
<p>$$
|\Psi\rangle = \sum_{s_1,s_2 = 1}^{2}\psi_{s_1s_2}|s_1\rangle|s_2\rangle
$$</p>
<p>体现在张量网络上, 就是一个结点在同一方向上同时有着两个&quot;触手&quot;.
对于我们写出来的态, 我们可以分离出两个单态(Singlet).</p>
<p>程序上的描述方法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Index s1(2,&#34;s1&#34;,Site), s2(2,&#34;s2&#34;,Site);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 该语法已经被弃用,使用两步语法来替代
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Index <span style="color:#a6e22e">s1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s1&#34;</span>);s1.addTags(<span style="color:#e6db74">&#34;Site&#34;</span>);
</span></span><span style="display:flex;"><span>Index <span style="color:#a6e22e">s2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s2&#34;</span>);s1.addTags(<span style="color:#e6db74">&#34;Site&#34;</span>);
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">psi</span>(s1,s2);                 <span style="color:#75715e">//只声明不定义,则默认为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// psi(s1(1),s2(2)) = 1./sqrt(2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// psi(s1(2),s2(1)) =-1./sqrt(2);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 该语法已被弃用,使用.set()来替代.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>psi.set(s1(<span style="color:#ae81ff">1</span>),s2(<span style="color:#ae81ff">2</span>), <span style="color:#ae81ff">1.</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>psi.set(s1(<span style="color:#ae81ff">2</span>),s2(<span style="color:#ae81ff">1</span>),<span style="color:#f92672">-</span><span style="color:#ae81ff">1.</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>PrintData(psi);
</span></span></code></pre></div><blockquote>
<p><code>Index s1(2,&quot;s1&quot;);s1.addTags(&quot;Site&quot;);</code>代表的含义是创建一个维数为<code>int</code>,标签(或者理解为&quot;名字&quot;,一般是指物理上的状态,比如自旋,粒子位置等等)为<code>string</code>,指标类型为<code>Site</code>的物理量.同时使用<code>ITensor psi(s1,s2)</code>将<code>s1</code>和<code>s2</code>设置为纠缠态(<strong>Entangled State</strong>).</p>
</blockquote>
<p>现在要说明的就是指标(<code>Index</code>)的类型:<code>Site</code>和<code>Link</code>.</p>
<p><code>Site</code>表示单个量子位的物理态. 适用于表示单个自旋,单个粒子的位置等等. 与之配对的维数<code>int</code>表示的是该量子位可以取的物理态的数量;</p>
<p><code>Link</code>表示的是不同量子位之间的相互作用. 这种相互作用通常表示不同量子位的链接, 适用于表示各种相互作用, 比如哈密顿量等.</p>
<p><del>(还有表示不同于<code>Site</code>和<code>Link</code>类型的其它指标类型, 比如<code>Bulk</code>)</del></p>
<p>上面的代码中我们用<code>Site</code>来标记两个量子位,并且使其结合为纠缠态.</p>
<p>结果输出为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>psi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>324|<span style="color:#e6db74">&#34;s1,Site&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>127|<span style="color:#e6db74">&#34;s2&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,1<span style="color:#f92672">)</span> -0.707107
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2<span style="color:#f92672">)</span> 0.7071068
</span></span></code></pre></div><h2 id="哈密顿量hath">哈密顿量$\hat{H}$<a hidden class="anchor" aria-hidden="true" href="#哈密顿量hath">#</a></h2>
<p>我们写出双自旋系统的哈密顿量方程:</p>
<p>$\hat{H}=\hat{S}_1\cdot\hat{S}_2=S_1^zS_2^z+\frac{1}{2}S_1^+S_2^-+\frac{1}{2}S_1^-S_2^+$</p>
<p>其中 $S_1^\pm, S_2^\pm$ 是升降算符. 我们在程序中这样创建:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Index <span style="color:#a6e22e">s1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s1&#34;</span>);s1.addTags(<span style="color:#e6db74">&#34;Site&#34;</span>);
</span></span><span style="display:flex;"><span>Index <span style="color:#a6e22e">s2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s2&#34;</span>);s1.addTags(<span style="color:#e6db74">&#34;Site&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">Sz1</span>(s1,prime(s1)),Sp1(s1,prime(s1)),Sm1(s1,prime(s1));
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">Sz2</span>(s2,prime(s2)),Sp2(s2,prime(s2)),Sm2(s2,prime(s2));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// commaInit(Sp1,s1,prime(s1)) =   0, 1,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                                 0, 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// commaInit语法已被弃用.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Sz1,Sz2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Sz1.set(s1(<span style="color:#ae81ff">1</span>),prime(s1)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0.5</span>);Sz1.set(s1(<span style="color:#ae81ff">2</span>),prime(s1)(<span style="color:#ae81ff">2</span>),<span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>Sz2.set(s2(<span style="color:#ae81ff">1</span>),prime(s2)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0.5</span>);Sz2.set(s2(<span style="color:#ae81ff">2</span>),prime(s2)(<span style="color:#ae81ff">2</span>),<span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Sp1,Sp2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Sp1.set(s1(<span style="color:#ae81ff">1</span>),prime(s1)(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">1</span>);Sp2.set(s2(<span style="color:#ae81ff">1</span>),prime(s2)(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Sm1,Sm2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Sm1.set(s1(<span style="color:#ae81ff">2</span>),prime(s1)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">1</span>);Sm2.set(s2(<span style="color:#ae81ff">2</span>),prime(s2)(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ITensor H <span style="color:#f92672">=</span> Sz1 <span style="color:#f92672">*</span> Sz2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> Sp1 <span style="color:#f92672">*</span> Sm2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> Sm1 <span style="color:#f92672">*</span> Sp2;
</span></span><span style="display:flex;"><span>PrintData(H);<span style="color:#75715e">//你也可以尝试执行printfln(&#34;H=&#34;,H);
</span></span></span></code></pre></div><p>执行后可以得到结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>H <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>4: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>397|<span style="color:#e6db74">&#34;s1,Site&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>397|<span style="color:#e6db74">&#34;s1,Site&#34;</span><span style="color:#f92672">)</span><span style="color:#e6db74">&#39; (dim=2|id=53|&#34;s2&#34;) (dim=2|id=53|&#34;s2&#34;)&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>0.87 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,1,1,1<span style="color:#f92672">)</span> 0.2500000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,2,1,1<span style="color:#f92672">)</span> -0.250000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2,2,1<span style="color:#f92672">)</span> 0.5000000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,1,1,2<span style="color:#f92672">)</span> 0.5000000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,1,2,2<span style="color:#f92672">)</span> -0.250000
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,2,2,2<span style="color:#f92672">)</span> 0.2500000
</span></span></code></pre></div><blockquote>
<p>这表明这是一个四阶张量,并且由索引<code>s1</code>, <code>s1'</code>, <code>s2</code>, <code>s2'</code>来描述. 它们各自的维度都是$2$, 即它们可以取值为$1$或$2$.这就是<code>(i,j,k,l)</code>中<code>1</code>或者<code>2</code>的含义, 后面的值是对应的张量元素.</p>
</blockquote>
<p>这样计算得来的 $\hat{H}$ 在张量网络中表示一个上下各自有两个&quot;触手&quot;的结点, 恰好可以和表现为在某一方向上拥有两个&quot;触手&quot;的纠缠态结点进行结合.</p>
<p>更具体地说, 我们上面创建的 $\hat{H}$ 的上标是<code>s1'</code>和<code>s2'</code>,下标是<code>s1</code>和<code>s2</code>;
而 $\psi$ 的上标是<code>s1</code>和<code>s2</code>,两者进行结合就可以得到只有两个上标<code>s1'</code>和<code>s2'</code>的新节点 $\hat{H}\psi$ .</p>
<p>程序上这样描述这个结合的过程:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor Hpsi <span style="color:#f92672">=</span> H <span style="color:#f92672">*</span> psi;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Hpsi.mapprime(1,0);//该语句的作用是将Hpsi中所有上标级别为1的索引全部降为0,使得之后的运算能够被允许
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//该语法已被弃用. 使用.noPrime()来代替
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Hpsi.noPrime();
</span></span><span style="display:flex;"><span>Real E <span style="color:#f92672">=</span> (dag(psi) <span style="color:#f92672">*</span> Hpsi).real();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Print()语法已被弃用, 使用PrintData()来代替.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>PrintData(E);
</span></span></code></pre></div><p>能够在终端得到输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">=</span> -0.75
</span></span></code></pre></div><p>当然这个过程也可以一行语句完成:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Real E <span style="color:#f92672">=</span> (dag(prime(psi)) <span style="color:#f92672">*</span> H <span style="color:#f92672">*</span> psi).real();
</span></span><span style="display:flex;"><span>PrintData(E);
</span></span></code></pre></div><p>输出的结果同样是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>E <span style="color:#f92672">=</span> -0.75
</span></span></code></pre></div><h2 id="quiz-2-解析">Quiz $2$ 解析<a hidden class="anchor" aria-hidden="true" href="#quiz-2-解析">#</a></h2>
<blockquote>
<p>这个题目的背景是, 使用虚时间演化的方式来找到哈密顿量所对应的基态. 对应的方程是</p>
<p>$e^{-\beta H/2}|0\rangle\propto|\Psi_0\rangle$</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/all.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/util/print_macro.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> itensor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//定义生成Sp Sm Sz的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ITensor <span style="color:#a6e22e">makeSp</span>(Index <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Sp <span style="color:#f92672">=</span> ITensor(s,prime(s));
</span></span><span style="display:flex;"><span>    Sp.set(s<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,prime(s)<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Sp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">makeSm</span>(Index <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Sm <span style="color:#f92672">=</span> ITensor(s,prime(s));
</span></span><span style="display:flex;"><span>    Sm.set(s<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,prime(s)<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Sm;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">makeSz</span>(Index <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Sz <span style="color:#f92672">=</span> ITensor(s,prime(s));
</span></span><span style="display:flex;"><span>    Sz.set(s<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,prime(s)<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">+</span><span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>    Sz.set(s<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,prime(s)<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Sz;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initial product state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> s1 <span style="color:#f92672">=</span> Index(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s1&#34;</span>);<span style="color:#66d9ef">auto</span> s2 <span style="color:#f92672">=</span> Index(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s2&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> psi <span style="color:#f92672">=</span> ITensor(s1,s2);
</span></span><span style="display:flex;"><span>    psi.set(s1<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,s2<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    PrintData(psi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Single-site operators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> Sz1 <span style="color:#f92672">=</span> makeSz(s1);<span style="color:#66d9ef">auto</span> Sz2 <span style="color:#f92672">=</span> makeSz(s2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Sp1 <span style="color:#f92672">=</span> makeSp(s1);<span style="color:#66d9ef">auto</span> Sp2 <span style="color:#f92672">=</span> makeSp(s2);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Sm1 <span style="color:#f92672">=</span> makeSm(s1);<span style="color:#66d9ef">auto</span> Sm2 <span style="color:#f92672">=</span> makeSm(s2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Two-site Heisenberg Hamiltonian
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> H <span style="color:#f92672">=</span> Sz1 <span style="color:#f92672">*</span> Sz2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> Sp1 <span style="color:#f92672">*</span> Sm2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> Sm1 <span style="color:#f92672">*</span> Sp2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initial energy expectation value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> initEn <span style="color:#f92672">=</span> elt(dag(prime(psi)) <span style="color:#f92672">*</span> H <span style="color:#f92672">*</span> psi);
</span></span><span style="display:flex;"><span>    printfln(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Initial energy = %.10f&#34;</span>,initEn);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Make exp(-beta*H)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. Adjust beta to get the ground state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Real beta <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> expH <span style="color:#f92672">=</span> expHermitian(H,<span style="color:#f92672">-</span>beta);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Here we apply exp(-beta*H), normalize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// and unprime
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> psibeta <span style="color:#f92672">=</span> expH <span style="color:#f92672">*</span> psi;
</span></span><span style="display:flex;"><span>    psibeta.noPrime();
</span></span><span style="display:flex;"><span>    psibeta <span style="color:#f92672">/=</span> norm(psibeta);
</span></span><span style="display:flex;"><span>    PrintData(psibeta);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> En <span style="color:#f92672">=</span> elt(dag(prime(psibeta)) <span style="color:#f92672">*</span> H <span style="color:#f92672">*</span> psibeta);
</span></span><span style="display:flex;"><span>    printfln(<span style="color:#e6db74">&#34;At beta=%.1f, energy = %.10f&#34;</span>,beta,En);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. Adjust the following code to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    truncate to dimension 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    HINT: use the ITensor named argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    system, e.g. {&#34;MaxDim=&#34;,...}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> [U,D,V] <span style="color:#f92672">=</span> svd(psibeta,{s1},{<span style="color:#e6db74">&#34;MaxDim=&#34;</span>,<span style="color:#ae81ff">1</span>});
</span></span><span style="display:flex;"><span>    PrintData(D);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. Calculate the overlap of the new
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    wavefunction with the old wavefunction.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    Print your results with PrintData(...).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    HINT: use U*D*V to calculate the new,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    truncated wavefunction 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> newpsi <span style="color:#f92672">=</span> U <span style="color:#f92672">*</span> D <span style="color:#f92672">*</span> V;
</span></span><span style="display:flex;"><span>    PrintData(newpsi);
</span></span><span style="display:flex;"><span>    Real op <span style="color:#f92672">=</span> (dag(prime(newpsi)) <span style="color:#f92672">*</span> H <span style="color:#f92672">*</span> psibeta).real();
</span></span><span style="display:flex;"><span>    PrintData(op);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. Increase beta (defined above) to get the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    ground state. How does the overlap 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    change?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出得到.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>psi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>311|<span style="color:#e6db74">&#34;s1&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>239|<span style="color:#e6db74">&#34;s2&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2<span style="color:#f92672">)</span> 1.0000000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Initial energy <span style="color:#f92672">=</span> -0.2500000000
</span></span><span style="display:flex;"><span>psibeta <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>311|<span style="color:#e6db74">&#34;s1&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>239|<span style="color:#e6db74">&#34;s2&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>2,1<span style="color:#f92672">)</span> -0.049896
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2<span style="color:#f92672">)</span> 0.9987544
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>At beta<span style="color:#f92672">=</span>0.1, energy <span style="color:#f92672">=</span> -0.2998339973
</span></span><span style="display:flex;"><span>D <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>1|id<span style="color:#f92672">=</span>426|<span style="color:#e6db74">&#34;U,Link&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>1|id<span style="color:#f92672">=</span>228|<span style="color:#e6db74">&#34;V,Link&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Diag Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,1<span style="color:#f92672">)</span> 0.9987544
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newpsi <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>2: <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>311|<span style="color:#e6db74">&#34;s1&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>dim<span style="color:#f92672">=</span>2|id<span style="color:#f92672">=</span>239|<span style="color:#e6db74">&#34;s2&#34;</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>1.00 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>1,2<span style="color:#f92672">)</span> 0.9987544
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>op <span style="color:#f92672">=</span> -0.274295
</span></span></code></pre></div><p>所以只要我们一直调整<code>beta</code>的取值反复编译执行, 最后就能够找到能量最低时所对应的<code>beta</code>值.</p>
<h1 id="svd-奇异值分解">SVD 奇异值分解<a hidden class="anchor" aria-hidden="true" href="#svd-奇异值分解">#</a></h1>
<blockquote>
<p><strong>Singular Value Decomposition</strong></p>
<p>如果M是 $m\times m$ 的矩阵, 那么一定存在这样一个式子:</p>
<p>$M = U \Sigma V^*$</p>
<p>其中$U$是 $m\times m$ 的酉矩阵,
$\Sigma$ 是 $m\times n$ 非负实数对焦矩阵,
$V^*$ 是 $n\times n$ 的酉矩阵.</p>
<p>其中 $\Sigma$ 对角线上的元素 $\Sigma_{i,i}$ 是 $M$ 的奇异值.</p>
</blockquote>
<blockquote>
<p>密度矩阵重整化群 <strong>Density Matrix Renormalization Group</strong></p>
<p>该方法通过矩阵乘积态(Matrix Product State,MPS)来表示量子多体系统的波函数等.
DMRG方法来源于密度矩阵的理论和重整化群的思想, 大幅减少系统自由度的同时保留了系统中的物理特征.</p>
</blockquote>
<p>对于</p>
<p>$$
M=
\begin{bmatrix}
0.435839 &amp; 0.223707 &amp; 0.10\\
0.435839 &amp; 0.223707 &amp; -0.10 \\
0.223707 &amp; 0.435839 &amp; 0.10 \\
0.223707 &amp; 0.435839 &amp; -0.10 \\
\end{bmatrix}
$$</p>
<p>可以分解为 $A * D * B$:</p>
<p>$$
\begin{bmatrix}
0.5 &amp;-0.5 &amp; 0.5 \\
0.5 &amp;-0.5 &amp;-0.5 \\
0.5 &amp; 0.5 &amp; 0.5 \\
0.5 &amp; 0.5 &amp;-0.5 \\
\end{bmatrix}*
\begin{bmatrix}
0.933 &amp; 0 &amp; 0 \\
0 &amp; 0.300 &amp; 0 \\
0 &amp; 0 &amp; 0.200 \\
\end{bmatrix}*
\begin{bmatrix}
0.707107 &amp; 0.707107 &amp; 0 \\
-0.707107 &amp; 0.707107 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{bmatrix}
$$</p>
<p>可以看出, 两边的矩阵 $A,B$ 满足酉矩阵的定义, 即有 $A^{\dagger}A=I,BB^{\dagger}=I$.而对角矩阵 $D$ ,元素是非负实数且降序排列.</p>
<p>如果我们从后往前一步步去除 $D$ 对角线上的元素, 即</p>
<p>$$
\begin{bmatrix}
0.933 &amp; 0 &amp; 0 \\
0 &amp; 0.300 &amp; 0 \\
0 &amp; 0 &amp; 0.200 \\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0.933 &amp; 0 &amp; 0 \\
0 &amp; 0.300 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0.933 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
\end{bmatrix}
$$</p>
<p>这种操作被称为截断(Truncating).</p>
<p>然后依次重新进行 $M_{i} = A * D_{i} * B$ 合成,
并且使用范数 $||M_i - M||^2$ 来对合成后的矩阵产生的偏差程度进行评估.我们将可以看到:</p>
<p>$$
||M - M||^2 = 0;\
||M - M_1||^2 =  (0.2)^2;\
||M - M_2||^2 = (0.2)^2 + (0.3)^2;
$$</p>
<p>我们不难看出, 其实截断就是在降低矩阵 $D$ 的秩, 通过把握这个截断的幅度, 我们就可以控制最后产生 $M_i$ 矩阵的偏差程度. 这是一个用精度换速度的过程.</p>
<h2 id="双自旋波函数">双自旋波函数<a hidden class="anchor" aria-hidden="true" href="#双自旋波函数">#</a></h2>
<p>我们不妨用更物理一点的背景来分析奇异值分解的过程.</p>
<p>对于一个纠缠态的双自旋系统, 我们已经知道可以处理为一个具有两个&quot;触手&quot;(即上标)的结点. 但是我们也可以将其作为一个矩阵来处理, 即一个拥有左右两个&quot;触手&quot;的结点.</p>
<p>$-^{s_1} -\square\square\square^{\psi}-^{s_2}-$</p>
<p>这样, 我们就可以对中间的结点进行SVD操作, 这样就形成了一个项链式的结构:</p>
<p>$-^{s_1} -\square^{A}-\square^{D}-\square^{B}-^{s_2}-$</p>
<p>这种波函数形式, 我们将其称之为&quot;矩阵乘积态&quot;(<strong>Matrix Product State,MPS</strong>).</p>
<p>为了让这个结构看上去更像是一个波函数,可以想象两侧的&quot;触手&quot;是向上的(上标).</p>
<p>不妨用程序来描述这个过程.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ITensor <span style="color:#a6e22e">A</span>(s1),D,B;  <span style="color:#75715e">//先声明后使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>svd(psi,A,D,B);
</span></span></code></pre></div><p>我们已经知道, 对于一个寻常的双自旋波函数, 我们需要 $(2s + 1)^2$ 个参数来进行描述. 而且一般情况下, 我们对于这些参数的重要程度是无知的.无法放弃任何一个参数, 这就会急剧增加计算量.</p>
<p>而SVD给了我们一种可能: 我们不仅能知道哪些参数最重要, 我们还可以很大程度上掌握它们的数量, 而且这个数量很有可能很少(有利于计算!).</p>
<p>我们用方程来表达矩阵乘积态的思想:</p>
<p>$$
|\Psi\rangle=\sum_{s_1,\alpha,\alpha&rsquo;,s_2}A_{s_1\alpha}D_{\alpha\alpha&rsquo;}B_{\alpha&rsquo;s_2}|s_1\rangle|s_2\rangle
$$</p>
<blockquote>
<p>当然我们也可以将矩阵 $A,D$ 预先相乘形成新矩阵 $\psi$, 张量网络的形式即为:</p>
<p>$-^{s_1} -\square^{A}-\square^{D}-\square^{B}-^{s_2}-$</p>
<p>$\downarrow$</p>
<p>$-^{s_1} -\square\square^{\psi}-\square^{B}-^{s_2}-$</p>
<p>这样我们就得到了</p>
<p>$$
|\Psi\rangle=\sum_{s_1,\alpha&rsquo;,s_2}\psi_{s_1\alpha&rsquo;}B_{\alpha&rsquo;s_2}|s_1\rangle|s_2\rangle
$$</p>
</blockquote>
<blockquote>
<p>同理, 我们也可以将矩阵 $D,B$ 预先相乘形成新矩阵 $\psi$, 张量积算网络的形式为</p>
<p>$-^{s_1} -\square^{A}-\square^{D}-\square^{B}-^{s_2}-$</p>
<p>$\downarrow$</p>
<p>$-^{s_1} -\square^{A}-\square\square^{\psi}-^{s_2}-$</p>
<p>这样我们就得到了</p>
<p>$$
|\Psi\rangle=\sum_{s_1,\alpha,s_2}A_{s_1\alpha}\psi_{\alpha s_2}|s_1\rangle|s_2\rangle
$$</p>
</blockquote>
<h2 id="quiz-3-解析">Quiz $3$ 解析<a hidden class="anchor" aria-hidden="true" href="#quiz-3-解析">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/all.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/util/print_macro.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> itensor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// SVD of matrix M
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> Nrow <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;<span style="color:#66d9ef">int</span> Ncol <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> maxdim <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(Nrow,Ncol);<span style="color:#75715e">//确定截断维度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> M <span style="color:#f92672">=</span> Matrix(Nrow,Ncol);
</span></span><span style="display:flex;"><span>    M(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.435839</span>; M(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.223707</span>; M(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.10</span>;
</span></span><span style="display:flex;"><span>    M(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.435839</span>; M(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.223707</span>; M(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.10</span>;
</span></span><span style="display:flex;"><span>    M(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.223707</span>; M(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.435839</span>; M(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.10</span>;
</span></span><span style="display:flex;"><span>    M(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.223707</span>; M(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.435839</span>; M(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.10</span>;<span style="color:#75715e">//初始化矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Print(M);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//声明变量的数据类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Matrix U,V;
</span></span><span style="display:flex;"><span>    Vector d;<span style="color:#75715e">//用来接收对角元素,即奇异值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SVD(M,U,d,V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Print(U);Print(d);Print(V);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nkeep <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//取矩阵的截断维度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> Dtrunc <span style="color:#f92672">=</span> Matrix(maxdim,maxdim);<span style="color:#75715e">//只声明不定义,则初始化为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : range(nkeep)){
</span></span><span style="display:flex;"><span>        Dtrunc(j,j) <span style="color:#f92672">=</span> d(j);
</span></span><span style="display:flex;"><span>    }<span style="color:#75715e">//在对角线上填上截断保留的奇异值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> Mtrunc <span style="color:#f92672">=</span> U<span style="color:#f92672">*</span>Dtrunc<span style="color:#f92672">*</span>transpose(V);<span style="color:#75715e">//重新结合形成采取截断后的矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Print(Mtrunc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> diff <span style="color:#f92672">=</span> norm(M<span style="color:#f92672">-</span>Mtrunc);<span style="color:#66d9ef">auto</span> diff2 <span style="color:#f92672">=</span> sqr(diff);<span style="color:#75715e">//取矩阵差的范数来评估截断的效果(diff)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    printfln(<span style="color:#e6db74">&#34;|M-Mtrunc|^2 = %.2f&#34;</span>,diff2);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// SVD of two-site wavefunction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> s1 <span style="color:#f92672">=</span> Index(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s1&#34;</span>);<span style="color:#66d9ef">auto</span> s2 <span style="color:#f92672">=</span> Index(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;s2&#34;</span>);<span style="color:#75715e">//声明指标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sing <span style="color:#f92672">=</span> ITensor(s1,s2);<span style="color:#66d9ef">auto</span> prod <span style="color:#f92672">=</span> ITensor(s1,s2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Make sing a singlet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sing.set(s1<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,s2<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1.</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));sing.set(s1<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,s2<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.</span><span style="color:#f92672">/</span>sqrt(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Make prod a product state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    prod.set(s1<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,s2<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(Real mix <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; mix <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1.</span>; mix <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: ADD CODE here to create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// a new wavefunction that is 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// (1-mix) times a product state plus (mix)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// times a singlet (i.e. maximally entangled state).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> wf <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1.</span> <span style="color:#f92672">-</span> mix) <span style="color:#f92672">*</span> prod <span style="color:#f92672">+</span> mix <span style="color:#f92672">*</span> sing;
</span></span><span style="display:flex;"><span>        wf <span style="color:#f92672">/=</span> norm(wf);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//PrintData(wf);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// SVD this wavefunction and analyze the results.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Try computing and plotting the entanglement entropy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        ITensor A(s1),D,B;
</span></span><span style="display:flex;"><span>        Spectrum spec <span style="color:#f92672">=</span> svd(wf,A,D,B);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//PrintData(U);PrintData(D);PrintData(V);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> ent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//.eig(n)返回的是第(n+1)个本征值,这是因为数组下标从0开始;.numEigsKept()则是表示的特征值的数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;n <span style="color:#f92672">&lt;</span> spec.numEigsKept();n<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> P <span style="color:#f92672">=</span> sqr(spec.eig(n));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(P <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) ent <span style="color:#f92672">-=</span> P<span style="color:#f92672">*</span>log(P);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//分别以两位小数和六位小数的形式输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        printfln(<span style="color:#e6db74">&#34;mix = %.2f, entropy = %.6f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, mix, ent);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了节省篇幅,原本需要多次执行的<code>PrintData()</code>函数被注释了. 如果你有查看其具体数值的需要可以在自己使用的时候启用.</p>
<p>编译完成执行,在终端输出:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>M <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>|0.4358390 0.2237070 0.1000000|
</span></span><span style="display:flex;"><span>|0.4358390 0.2237070 -0.100000|
</span></span><span style="display:flex;"><span>|0.2237070 0.4358390 0.1000000|
</span></span><span style="display:flex;"><span>|0.2237070 0.4358390 -0.100000|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>U <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>|0.5000000 0.5000000 0.5000000|
</span></span><span style="display:flex;"><span>|0.5000000 0.5000000 -0.500000|
</span></span><span style="display:flex;"><span>|0.5000000 -0.500000 0.5000000|
</span></span><span style="display:flex;"><span>|0.5000000 -0.500000 -0.500000|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>d <span style="color:#f92672">=</span> 0.932739 0.3 0.2 
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>|0.7071068 0.7071068 1.11671818E-16|
</span></span><span style="display:flex;"><span>|0.7071068 -0.707107 -8.81355030E-17|
</span></span><span style="display:flex;"><span>|-1.66426876E-17 -1.41285111E-16 1.0000000|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Mtrunc <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>|0.4358390 0.2237070 -2.89544043E-17|
</span></span><span style="display:flex;"><span>|0.4358390 0.2237070 -2.89544043E-17|
</span></span><span style="display:flex;"><span>|0.2237070 0.4358390 1.34311222E-17|
</span></span><span style="display:flex;"><span>|0.2237070 0.4358390 1.34311222E-17|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>|M-Mtrunc|^2 <span style="color:#f92672">=</span> 0.04
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.00, entropy <span style="color:#f92672">=</span> 0.000000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.10, entropy <span style="color:#f92672">=</span> 0.010473
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.20, entropy <span style="color:#f92672">=</span> 0.042683
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.30, entropy <span style="color:#f92672">=</span> 0.094817
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.40, entropy <span style="color:#f92672">=</span> 0.160729
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.50, entropy <span style="color:#f92672">=</span> 0.230729
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.60, entropy <span style="color:#f92672">=</span> 0.293765
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.70, entropy <span style="color:#f92672">=</span> 0.340279
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.80, entropy <span style="color:#f92672">=</span> 0.364548
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 0.90, entropy <span style="color:#f92672">=</span> 0.365602
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mix <span style="color:#f92672">=</span> 1.00, entropy <span style="color:#f92672">=</span> 0.346574
</span></span></code></pre></div><h1 id="four-四结点">Four 四结点<a hidden class="anchor" aria-hidden="true" href="#four-四结点">#</a></h1>
<p>对于四节点的矩阵乘积态，我们可以用这样一个方程式来描述：</p>
<p>$$
|\Psi\rangle=\sum_{{s},{\alpha}}M_{\alpha_1}^{s_1}M_{\alpha_1\alpha_2}^{s_2}M_{\alpha_2\alpha_3}^{s_3}M_{\alpha_4}^{s_4}|s_1s_2s_3s_4\rangle
$$</p>
<p>前面我们已经学习过怎么处理将两个单节点结合为纠缠态的双节点. 所以我们这里可以将具有 $s_3$ 和 $s_4$ 上标的两个单节点组合形成具有 $s_3$ 和 $s_4$ 上标的纠缠态双节点.</p>
<p>然后就是刚才所学的将双节点进行SVD分解, 而这里我们要分解的对象就是刚才合成的纠缠态双节点。</p>
<p>为了继续保持四节点的性质，我们将分解出的<code>A</code>,<code>D</code>和<code>B</code>中的<code>A</code>与<code>D</code>结合,其上标是 $s_3$ ,而剩下来的<code>B</code>则单独作为结点, 其上标是 $s_4$.</p>
<p>以这种方式得到的新的四节点张量, 我们称之为&quot;右正交&quot;(<strong>Right Orthogonal</strong>)或者说&quot;右规范&quot;, 这是因为单独作为结点的 $B$ 是 酉的 ($BB^{\dagger}=I$).</p>
<p>显然, 这种右正交的性质是可以向左传递的. 比如, 我们取已经完成了<strong>SVD</strong>和<strong>AD</strong>结合的四节点张量中的具有 $s_2$ 和 $s_3$ 上标的单节点重复上述操作, 便可以让具有上标 $s_3$ 的单节点也具有右正交的性质.依此类推, 使得除了 $s_1$ 之外的所有单节点都具有右正交的性质.</p>
<h2 id="期望值-langlehata_1rangle">期望值 $\langle\hat{A}_1\rangle$<a hidden class="anchor" aria-hidden="true" href="#期望值-langlehata_1rangle">#</a></h2>
<p>我们考虑一个具有4量子位的纠缠态波函数求第一量子位算符的期望值的过程.</p>
<p>在一般情况下,我们通常是这样求解的(假设 $|\psi\rangle$ 已经规一化):</p>
<p>$$
\langle\hat{A_1}\rangle=\sum_{s}\overline{\psi}_{s&rsquo;_{1}s_{2}s_{3}s_{4}}A_{s&rsquo;_{1}s_{1}}\psi_{s_{1}s_{2}s_{3}s_{4}}
$$</p>
<p>这个过程显然是及其繁杂的, 在这种情况下时间复杂度以 $O(2^n)$ 的速度增长, 如果不以某种算法进行简化必然极其耗时.</p>
<p>如果是已经经过了 SVD 分解的纠缠态波函数, 除了第一量子位 $s_1$ , 其余的所有单节点全部都具有右正交性质, 而我们求的是第一量子位的算符的期望值, 这也意味着其余量子位结合不会对第一量子位的运算产生任何影响.</p>
<p>通过这样的算法, 计算量得到了大量简化.</p>
<p>用程序语言来描述这个过程:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>SpinHalf <span style="color:#a6e22e">sites</span>(N);  <span style="color:#75715e">//表示sites是N个1/2自旋量子位的体系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MPS <span style="color:#a6e22e">psi</span>(sites);     <span style="color:#75715e">//以矩阵乘积态表示sites体系的波函数, 并且用psi来称呼这个波函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>computeGroundState(H,psi);<span style="color:#75715e">//寻找哈密顿量H下的基态, psi被用以进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>psi.position(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">//将psi的正则位置设置为第二个位置.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Real sz_expect <span style="color:#f92672">=</span> (dag(prime(psi.A(<span style="color:#ae81ff">2</span>),Site)) <span style="color:#f92672">*</span> sites.op(<span style="color:#e6db74">&#34;Sz&#34;</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> psi.A(<span style="color:#ae81ff">2</span>)).real();
</span></span></code></pre></div><blockquote>
<p>正则位置<strong>Canonical Position</strong></p>
<p>在前面的SVD和regroup过程中我们只提到了&quot;右规范&quot;, 实际上我们也很容易将其推广到&quot;左规范&quot;, 这样的话我们就可以将正则位置定义为&quot;左规范&quot;和&quot;右规范&quot;同时成立的位置.</p>
<p>在上面的例子中,因为我们要求的是第二量子位的自旋期望值, 为了简化我们就要将其左右的全部结点都规范化(具体结合的方向看正则位置的左右).</p>
</blockquote>
<h2 id="quiz-4-解析">Quiz $4$ 解析<a hidden class="anchor" aria-hidden="true" href="#quiz-4-解析">#</a></h2>
<blockquote>
<p>矩阵乘积算子<strong>Matrix Product Operator</strong>(<strong>MPO</strong>)</p>
<p>和矩阵乘积态(<strong>MPS</strong>)相似, <strong>MPO</strong>也是一种张量网络的表示方法.
它可以用来描述复杂量子系统的哈密顿量.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/all.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/util/print_macro.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> itensor;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>vector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>;<span style="color:#75715e">//定义一个包含50个1/2自旋的系统&#39;sites&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> sites <span style="color:#f92672">=</span> SpinHalf(N,{<span style="color:#e6db74">&#34;ConserveQNs=&#34;</span>,false});<span style="color:#75715e">//&#34;ConserveQNs=&#34;设为false,表示不考虑量子数守恒.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. Adjust the external field to see how the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    magnetization changes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Real h <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//调整h来找到相变点.h = 1 时,系统从磁性相变无序相. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the MPO for the transverse field
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Ising model
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> ampo <span style="color:#f92672">=</span> AutoMPO(sites); <span style="color:#75715e">//创建一个自动构造MPO的对象&#39;ampo&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//依次赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>j){
</span></span><span style="display:flex;"><span>        ampo <span style="color:#f92672">+=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4.0</span>,<span style="color:#e6db74">&#34;Sz&#34;</span>,j,<span style="color:#e6db74">&#34;Sz&#34;</span>,j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> N; <span style="color:#f92672">++</span>j){
</span></span><span style="display:flex;"><span>        ampo <span style="color:#f92672">+=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>h,<span style="color:#e6db74">&#34;Sx&#34;</span>,j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//哈密顿量的类型是MPO, 利用toMPO()函数将ampo里蕴含的信息转化为哈密顿量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> H <span style="color:#f92672">=</span> toMPO(ampo);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create a random starting state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// For DMRG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//随机生成一个初始态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> psi0 <span style="color:#f92672">=</span> randomMPS(sites);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run DMRG to get the ground state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> sweeps <span style="color:#f92672">=</span> Sweeps(<span style="color:#ae81ff">5</span>);        <span style="color:#75715e">//设置密度矩阵重整化群算法(DMRG)的最大迭代次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sweeps.maxdim() <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>;      <span style="color:#75715e">//设置密度矩阵重整化群算法(DMRG)的最大纠缠矩阵维度的序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sweeps.cutoff() <span style="color:#f92672">=</span> <span style="color:#ae81ff">1E-10</span>;        <span style="color:#75715e">//设置奇异值的截断精度, 只有大于该值的奇异值才会被保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> [E,psi] <span style="color:#f92672">=</span> dmrg(H,psi0,sweeps,{<span style="color:#e6db74">&#34;Quiet&#34;</span>,true});
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//H为系统的哈密顿量, 以psi0作为迭代起点运行算法,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//&#39;sweeps&#39;是迭代的参数,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//&#39;{&#34;Quiet&#34;,true}&#39;表示静默运行(不输出详细的迭代信息)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//返回值为基态能量和基态波函数, 以量 E 和 psi 对计算结果进行存储
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//在终端查看基态能量值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    printfln(<span style="color:#e6db74">&#34;Ground state energy = &#34;</span>,E);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对psi进行共轭转置. 此时psidag上标级别为2.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> psidag <span style="color:#f92672">=</span> dag(prime(psi));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A vector holding the operators used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// in the expectation value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// All set to identity operators to start.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Note: this is one-indexed 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//       (O[n] is the operator on site n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//创建长为N+1的向量, 用于存储测量算符.O[j]代表在第j个量子位上的测量算符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> O <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>ITensor<span style="color:#f92672">&gt;</span>(N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//对O进行初始化,方法是将所有的测量算符都设为单位算符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : range1(N)){
</span></span><span style="display:flex;"><span>        O[j] <span style="color:#f92672">=</span> op(sites,<span style="color:#e6db74">&#34;Id&#34;</span>,j);      <span style="color:#75715e">//&#34;Id&#34;意指&#34;Identity&#34;, 即单位算符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Position we will place our operator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将本征位置选为正中, 即N/2.以这个位置来执行测量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> Npos <span style="color:#f92672">=</span> N<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. Add an operator to measure the magnetization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    in the z direction at Npos.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    HINT: use the op(...) function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//          It provides spin operators &#34;Sx&#34;, &#34;Sy&#34;, &#34;Sz&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//          you may want to scale your operator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//          to make it a Pauli matrix
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> op_z <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> op(sites,<span style="color:#e6db74">&#34;Sz&#34;</span>,Npos);
</span></span><span style="display:flex;"><span>    O[Npos] <span style="color:#f92672">=</span> op_z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. Complete the following code 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    to measure the magnetization.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    Print your results with PrintData(...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> o <span style="color:#f92672">=</span> psidag(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> O[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> psi(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : range1(<span style="color:#ae81ff">2</span>,N)){
</span></span><span style="display:flex;"><span>        o <span style="color:#f92672">*=</span> psidag(j) <span style="color:#f92672">*</span> O[j] <span style="color:#f92672">*</span> psi(j);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    PrintData(o);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 3. Adjust the transverse field h at the top of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    file to find the critical point.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    HINT: think about the field limits h -&gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//          and h -&gt; infinity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译执行后终端输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vN Entropy at center bond b<span style="color:#f92672">=</span>25 <span style="color:#f92672">=</span> 0.002062540436
</span></span><span style="display:flex;"><span>    Eigs at center bond b<span style="color:#f92672">=</span>25: 0.9998 
</span></span><span style="display:flex;"><span>    Largest link dim during sweep 1/5 was <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    Largest truncation error: 4.11222e-11
</span></span><span style="display:flex;"><span>    Energy after sweep 1/5 is -51.205898332822
</span></span><span style="display:flex;"><span>    Sweep 1/5 CPU time <span style="color:#f92672">=</span> 0.0146s <span style="color:#f92672">(</span>Wall time <span style="color:#f92672">=</span> 0.0177s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vN Entropy at center bond b<span style="color:#f92672">=</span>25 <span style="color:#f92672">=</span> 0.006828488484
</span></span><span style="display:flex;"><span>    Eigs at center bond b<span style="color:#f92672">=</span>25: 0.9992 
</span></span><span style="display:flex;"><span>    Largest link dim during sweep 2/5 was <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    Largest truncation error: 1.88078e-08
</span></span><span style="display:flex;"><span>    Energy after sweep 2/5 is -51.298393038956
</span></span><span style="display:flex;"><span>    Sweep 2/5 CPU time <span style="color:#f92672">=</span> 0.0181s <span style="color:#f92672">(</span>Wall time <span style="color:#f92672">=</span> 0.0181s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vN Entropy at center bond b<span style="color:#f92672">=</span>25 <span style="color:#f92672">=</span> 0.002920154202
</span></span><span style="display:flex;"><span>    Eigs at center bond b<span style="color:#f92672">=</span>25: 0.9997 
</span></span><span style="display:flex;"><span>    Largest link dim during sweep 3/5 was <span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span>    Largest truncation error: 9.69913e-11
</span></span><span style="display:flex;"><span>    Energy after sweep 3/5 is -52.306536772989
</span></span><span style="display:flex;"><span>    Sweep 3/5 CPU time <span style="color:#f92672">=</span> 0.0210s <span style="color:#f92672">(</span>Wall time <span style="color:#f92672">=</span> 0.0210s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vN Entropy at center bond b<span style="color:#f92672">=</span>25 <span style="color:#f92672">=</span> 0.002920148259
</span></span><span style="display:flex;"><span>    Eigs at center bond b<span style="color:#f92672">=</span>25: 0.9997 
</span></span><span style="display:flex;"><span>    Largest link dim during sweep 4/5 was <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>    Largest truncation error: 9.45633e-11
</span></span><span style="display:flex;"><span>    Energy after sweep 4/5 is -52.306549436787
</span></span><span style="display:flex;"><span>    Sweep 4/5 CPU time <span style="color:#f92672">=</span> 0.0179s <span style="color:#f92672">(</span>Wall time <span style="color:#f92672">=</span> 0.0180s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vN Entropy at center bond b<span style="color:#f92672">=</span>25 <span style="color:#f92672">=</span> 0.002920145615
</span></span><span style="display:flex;"><span>    Eigs at center bond b<span style="color:#f92672">=</span>25: 0.9997 
</span></span><span style="display:flex;"><span>    Largest link dim during sweep 5/5 was <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    Largest truncation error: 9.18628e-11
</span></span><span style="display:flex;"><span>    Energy after sweep 5/5 is -52.306549436806
</span></span><span style="display:flex;"><span>    Sweep 5/5 CPU time <span style="color:#f92672">=</span> 0.0168s <span style="color:#f92672">(</span>Wall time <span style="color:#f92672">=</span> 0.0168s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Ground state energy <span style="color:#f92672">=</span> -52.3065
</span></span><span style="display:flex;"><span>o <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>ITensor ord<span style="color:#f92672">=</span>0: 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>norm<span style="color:#f92672">=</span>0.96 <span style="color:#f92672">(</span>Dense Real<span style="color:#f92672">)}</span>
</span></span><span style="display:flex;"><span>  -0.964679
</span></span></code></pre></div><h1 id="小车-trotter--suzuki-formula"><del>&ldquo;小车&rdquo;</del> Trotter – Suzuki formula<a hidden class="anchor" aria-hidden="true" href="#小车-trotter--suzuki-formula">#</a></h1>
<p>上一章中我们测量的是单个量子位的期望值, 当我们增加有效算子(指在该量子位上并非单位算符<code>&quot;Id&quot;</code>)的数量, 张量网络看上去就如同小车一般.</p>
<blockquote>
<p><del>上述语句均为强行解释</del>.事实上这个算法来源于模拟哈密顿量动力学中的<strong>Trotter – Suzuki formula</strong>, <strong>Trotter</strong>到底是形容&quot;小车&quot;还是人名实际上并不太清楚.</p>
</blockquote>
<p>现在我们设想一个已经对于相邻的两个量子位的左/右都已经完成左/右规范化,那么现在要做的就是计算这两个相邻量子位上对应算符的期望值.</p>
<p>和前面章节中处理二量子位的纠缠态类似, 我们可以将这两个量子位进行合并, 进行SVD分解, 再重组(至于是<code>AD</code>组合还是<code>DB</code>组合,可以根据自己需求来调整).</p>
<blockquote>
<p>注意: 这种算法仅适用于相邻量子位并不属于同一方向规范的情况(比如并不是两个正则位置, 而是在正则位置的同一边), 否则以截断SVD方法计算得到的结果并非全局最优.</p>
</blockquote>
<p>Trotter算法的精髓在于,将哈密顿量(也就是我们所用的算子)分解为若干个可以独立演化的小块, 而且如果哈密顿量是短程相互作用, 那么这种分解的效果就更好. 对于长程作用的哈密顿量Trotter算法的效率就会明显降低.在上面我们所举的例子里, 有效的哈密顿量仅涉及两个相邻的量子位, 可以说是符合短程的定义.</p>
<p>如果哈密顿量中的相互作用都是短程的, 我们可以将哈密顿量分解为小块, 用自旋系统为例, 我们可以用这样的方程来描述:</p>
<p>$$
\begin{equation}
\hat{H}=\hat{H_1}+\hat{H_2}+\hat{H_3}+\dots \\
=\sum_{j}\hat{S_{j}}\cdot\hat{S_{j+1}} \\
=(\hat{S_{1}}\cdot\hat{S_{2}})+(\hat{S_{2}}\cdot\hat{S_{3}})+(\hat{S_{3}}\cdot\hat{S_{4}})\dots
\end{equation}
$$</p>
<p>那么假设系统演化了一极短的虚时间 $\tau$,我们可以将系统的演化写作:</p>
<p>$$
\begin{aligned}
e^{-\tau\hat{H}}\approxeq &amp;e^{-\tau\hat{H_1}/2}e^{-\tau\hat{H_2}/2}e^{-\tau\hat{H}_3/2}\dots\
&amp;\dots e^{-\tau\hat{H}_3/2}e^{-\tau\hat{H_2}/2}e^{-\tau\hat{H_1}/2}+O(\tau^3)
\end{aligned}
$$</p>
<blockquote>
<p><strong>虚时演化</strong></p>
<p>对于一个一般的表达式 $|\psi&rsquo;\rangle=e^{-\tau\hat{H}}|\psi\rangle$ (省略了 $\hbar$ ),有两种情况:</p>
<ul>
<li>$\tau$ 是实数, 那么相当于 $\tau = i\tau&rsquo;$, 其中 $\tau&rsquo;$是虚时间. 那么我们只要执行足够多步, 就可以搜索到基态.</li>
<li>$\tau$ 是虚数, 那么就是一般的<strong>动力学</strong>表述, 相当于 $\tau = it$, 原方程变为 $|\psi&rsquo;\rangle=e^{-it\hat{H}}|\psi\rangle$</li>
</ul>
<p>对于第一种情况, 有一种应用的例子, 即通过取 $\beta/2=1/(2T)$ 的虚时演化来模拟有限温度.</p>
<p>更详细的说, 就是取 $\tau = \frac{1}{k_BT}$ ,就相当于进行了一次虚时间演化. 在每一步执行完成后我们要对系统的状态进行记录, 从而对系统的在温度T下的性质进行统计平均.</p>
</blockquote>
<p>我们用.gif 来演示这一过程:</p>
<iframe src="https://giphy.com/embed/y5zirGH4lWCGE9j6SL" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
<p>因为我们每一步都只取了每个量子位对应分块哈密顿量的 $\frac{1}{2}$ ,所以通过往返执行一遍可以不改变纠缠态的规范性.</p>
<h1 id="quiz-5-解析">Quiz 5 解析<a hidden class="anchor" aria-hidden="true" href="#quiz-5-解析">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/all.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;itensor/util/print_macro.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>vector;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>move;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> itensor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TGate</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">int</span> i2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//i1, i2是用来指定虚时演化算子中产生作用的两个自旋量子位编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ITensor G;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//G被声明为ITensor类型，用来存储具体的虚时演化算子值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    TGate() { }
</span></span><span style="display:flex;"><span>    TGate(<span style="color:#66d9ef">int</span> i1_, <span style="color:#66d9ef">int</span> i2_, ITensor G_) 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> i1(i1_), i2(i2_), G(G_) { }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sites <span style="color:#f92672">=</span> SpinHalf(N);<span style="color:#75715e">//声明系统是20个1/2自旋子的系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> init <span style="color:#f92672">=</span> InitState(sites);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> n : range1(N)){
</span></span><span style="display:flex;"><span>        init.set(n, n<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Up&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Dn&#34;</span>);
</span></span><span style="display:flex;"><span>    }<span style="color:#75715e">//并且将该系统初始化为Neel态(相邻自旋总相反)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//将该状态init通过MPS()转译为矩阵乘积态(MPS)的形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> psi <span style="color:#f92672">=</span> MPS(init);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//定义虚时演化的总时间和时间间隔(步长)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Real ttotal <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;Real tstep <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//检查时间步长和总时间是否合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> nt <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>(ttotal<span style="color:#f92672">/</span>tstep<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1e-9</span><span style="color:#f92672">*</span>(ttotal<span style="color:#f92672">/</span>tstep)));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(std<span style="color:#f92672">::</span>fabs(nt<span style="color:#f92672">*</span>tstep<span style="color:#f92672">-</span>ttotal) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1E-9</span>){
</span></span><span style="display:flex;"><span>        Error(<span style="color:#e6db74">&#34;Timestep not commensurate with total time&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Create Trotter gates (imaginary time)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//定义数据类型为TGate的vector容器，用来存储虚时演化算子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> gates <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>TGate<span style="color:#f92672">&gt;</span>{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; b <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>b){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//从头开始构建哈密顿量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> hh <span style="color:#f92672">=</span> op(sites,<span style="color:#e6db74">&#34;Sz&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sz&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        hh <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sp&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sm&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        hh <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sm&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sp&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//计算半步长的虚时演化算子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> G <span style="color:#f92672">=</span> expHermitian(hh,<span style="color:#f92672">-</span>tstep<span style="color:#f92672">/</span><span style="color:#ae81ff">2.</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将虚时演化算子存储到名为gates的容器中(序列尾部)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        gates.emplace_back(b,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,move(G));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; b <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>b){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//从尾开始构建哈密顿量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ITensor hh <span style="color:#f92672">=</span> op(sites,<span style="color:#e6db74">&#34;Sz&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sz&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        hh <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sp&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sm&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        hh <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sm&#34;</span>,b)<span style="color:#f92672">*</span>op(sites,<span style="color:#e6db74">&#34;Sp&#34;</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//计算半步长的虚时演化算子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> G <span style="color:#f92672">=</span> expHermitian(hh,<span style="color:#f92672">-</span>tstep<span style="color:#f92672">/</span><span style="color:#ae81ff">2.</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将虚时演化算子存储到名为gates的容器中(序列尾部)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        gates.emplace_back(b,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,move(G));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> step <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; step <span style="color:#f92672">&lt;=</span> nt; <span style="color:#f92672">++</span>step){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将之前计算存储好的分块算子一一取出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> gate : gates){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//读取分块算子对应的作用位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> b <span style="color:#f92672">=</span> gate.i1;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//读取分块算子的具体值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> G <span style="color:#f92672">=</span> gate.G;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//设置正则位置为当前循环中的b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            psi.position(b);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//将相邻量子位b和b+1合成为新张量AA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> AA <span style="color:#f92672">=</span> psi(b) <span style="color:#f92672">*</span> psi(b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// TODO: ADD CODE here that applies 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// the gate G to the MPS bond
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// tensor &#34;AA&#34; by multiplying
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// G and AA using the * operator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// G is an ITensor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// with index structure:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//   s_{b}&#39; s_{b+1}&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//    |      |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//    ========
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//    |      |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//   s_{b}  s_{b+1}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// After applying G to AA, don&#39;t forget
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// to reset the prime level to 0 by using
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// the noPrime method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//将G和AA相乘
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            AA <span style="color:#f92672">*=</span> G;
</span></span><span style="display:flex;"><span>            AA.noPrime();<span style="color:#75715e">//将AA的上标级别降为0, 因为SVD操作要求上标级别是一致的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//Normalize AA after applying G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            AA <span style="color:#f92672">/=</span> norm(AA);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//SVD AA to restore MPS form
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> [U,D,V] <span style="color:#f92672">=</span> svd(AA,inds(psi(b)),{<span style="color:#e6db74">&#34;Cutoff&#34;</span>,<span style="color:#ae81ff">1E-10</span>});
</span></span><span style="display:flex;"><span>            psi.set(b,U);
</span></span><span style="display:flex;"><span>            psi.set(b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,D<span style="color:#f92672">*</span>V);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        printfln(<span style="color:#e6db74">&#34;Step %d/%d&#34;</span>,step,nt);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Make Heisenberg H to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//conveniently measure energy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> ampo <span style="color:#f92672">=</span> AutoMPO(sites);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : range1(N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)){
</span></span><span style="display:flex;"><span>        ampo <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span>,<span style="color:#e6db74">&#34;S+&#34;</span>,j,<span style="color:#e6db74">&#34;S-&#34;</span>,j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        ampo <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.5</span>,<span style="color:#e6db74">&#34;S-&#34;</span>,j,<span style="color:#e6db74">&#34;S+&#34;</span>,j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        ampo <span style="color:#f92672">+=</span>     <span style="color:#e6db74">&#34;Sz&#34;</span>,j,<span style="color:#e6db74">&#34;Sz&#34;</span>,j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> H <span style="color:#f92672">=</span> toMPO(ampo);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printfln(<span style="color:#e6db74">&#34;Energy = %.20f&#34;</span>,inner(psi,H,psi));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Exact ground state energy of N=20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Heisenberg model:E0 = -8.6824733306
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译执行后, 在终端输出的结果:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Step 1/20
</span></span><span style="display:flex;"><span>Step 2/20
</span></span><span style="display:flex;"><span>Step 3/20
</span></span><span style="display:flex;"><span>Step 4/20
</span></span><span style="display:flex;"><span>Step 5/20
</span></span><span style="display:flex;"><span>Step 6/20
</span></span><span style="display:flex;"><span>Step 7/20
</span></span><span style="display:flex;"><span>Step 8/20
</span></span><span style="display:flex;"><span>Step 9/20
</span></span><span style="display:flex;"><span>Step 10/20
</span></span><span style="display:flex;"><span>Step 11/20
</span></span><span style="display:flex;"><span>Step 12/20
</span></span><span style="display:flex;"><span>Step 13/20
</span></span><span style="display:flex;"><span>Step 14/20
</span></span><span style="display:flex;"><span>Step 15/20
</span></span><span style="display:flex;"><span>Step 16/20
</span></span><span style="display:flex;"><span>Step 17/20
</span></span><span style="display:flex;"><span>Step 18/20
</span></span><span style="display:flex;"><span>Step 19/20
</span></span><span style="display:flex;"><span>Step 20/20
</span></span><span style="display:flex;"><span>Energy <span style="color:#f92672">=</span> -8.51422469470028886462
</span></span></code></pre></div><p>最后的结果和理论上计算得到的 $-8.6824733306$ 相差约为 $1.94%$, 可以说差距不大.</p>
<h1 id="矩阵乘积算子-mpo">矩阵乘积算子 <strong>MPO</strong><a hidden class="anchor" aria-hidden="true" href="#矩阵乘积算子-mpo">#</a></h1>
<p>我们已经知道, 在张量网络中, 一个哈密顿量 $\hat{H}$ 看上去大概是这个样子:</p>
<p>$$
\sum_{|}^{|}\sum_{|}^{|}\sum_{|}^{|}\sum_{|}^{|}\sum_{|}^{|}
$$</p>
<p>而一个对应量子位数的纠缠态波函数 $|\Psi\rangle$ 则是这样:</p>
<p>$$
\sum^{|}-\sum^{|}-\sum^{|}-\sum^{|}-\sum^{|}
$$</p>
<p>在上面的学习中我们已经知道, 要让 $\hat{H}$ 作用到 $|\Psi\rangle$ 上, 其实就是将上下标进行结合的过程.</p>
<p>那么既然 $|\Psi\rangle$ 能够写作矩阵乘积的形式, 我们自然也可以对 $\hat{H}$ 进行同样的要求,将其化为张量网络中的这种形式:</p>
<p>$$
\sum_{|}^{|}-\sum_{|}^{|}-\sum_{|}^{|}-\sum_{|}^{|}-\sum_{|}^{|}
$$</p>
<p>我们取其中一个张量进行分析:</p>
<p>$$
^{1}-\sum_{|_{4}}^{|^{3}}-^{2}
$$</p>
<p>这里面的$1$和$2$代表的时张量左右的指标, 而$3$和$4$代表的是张量上下的指标(通常和作用与某量子位或其它物理量有关). 多个这样的张量乘在一起就能化成矩阵乘积算子的形式.</p>
<p>我们不妨用一个更具体的例子:</p>
<p>$$\hat{H} =
\begin{bmatrix}
0 &amp; 1\\
\end{bmatrix}_{A}
\begin{bmatrix}
\hat{I} &amp; \\
\hat{\sigma}^{z} &amp; \hat{I}\\
\end{bmatrix}_{B}
\begin{bmatrix}
\hat{I} &amp; \\
\hat{\sigma}^{z} &amp; \hat{I}\\
\end{bmatrix}_{C}
\begin{bmatrix}
1 \\
0\\
\end{bmatrix}_{D}
$$</p>
<p>在矩阵的右下角使用<code>A</code> <code>B</code> <code>C</code> <code>D</code>来进行标记.它们以张量网络画出的形式大概像这样:</p>
<p>$$
\sum{A}-\sum_{|}^{|}{B}-\sum_{|}^{|}{C}-\sum{D}
$$</p>
<p>不难看出实际上<code>A</code>和<code>B</code>,以及<code>C</code>和<code>D</code>是能够各自结合形成新矩阵的, 我们写出相乘得到的结果:</p>
<p>$$
\hat{H} =
\begin{bmatrix}
\hat{\sigma}^{z} &amp; \hat{I}\\
\end{bmatrix}_{A&rsquo;}
\begin{bmatrix}
\hat{I}\\
\hat{\sigma}^{z} \\
\end{bmatrix}_{B&rsquo;}
$$</p>
<p>在方程上我们这样表述:</p>
<p>$$
\hat{H} = \hat{\sigma_{1}}^{z}\bigotimes\hat{I_{2}} + \hat{I_{1}}\bigotimes\hat{\sigma_{2}}^{z}
$$</p>
<p>当然这一个式子我们还可以进行继续的简化, 完成最后一步的乘法:</p>
<p>$$
\hat{H} = \hat{\sigma_{1}}^{z}+\hat{\sigma_{2}}^{z}
=\sum_{i}\hat{\sigma_{i}}^{z}
$$</p>
<p>现在再动手算更复杂的例子.</p>
<p>$$\hat{H}=
\begin{bmatrix}
0 &amp; 0 &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
\hat{I} &amp;  &amp; \\
\hat{\sigma}^{z} &amp;  &amp; \\
-h\hat{\sigma}^{x} &amp; \hat{\sigma}^{z} &amp; \hat{I}\\
\end{bmatrix}
\begin{bmatrix}
\hat{I} &amp;  &amp; \\
\hat{\sigma}^{z} &amp;  &amp; \\
-h\hat{\sigma}^{x} &amp; \hat{\sigma}^{z} &amp; \hat{I}\\
\end{bmatrix}
\begin{bmatrix}
1\\
0\\
0\\
\end{bmatrix}
$$</p>
<p>先算两边, 再算中间, 即有</p>
<p>$$
\hat{H}=[-h\hat{\sigma}^{x},\hat{\sigma}^{z},\hat{I}][\hat{I},\hat{\sigma}^{z},-h\hat{\sigma}^{x}]^{T}=\sum_{j}\hat{\sigma_{j}}^{z}\hat{\sigma_{j+1}}^{z}-h\hat{\sigma_{j}}^{x}
$$</p>
<blockquote>
<p>本章没有对应的Quiz</p>
</blockquote>
<h1 id="dmrg-密度矩阵重整化群"><strong>DMRG</strong> 密度矩阵重整化群<a hidden class="anchor" aria-hidden="true" href="#dmrg-密度矩阵重整化群">#</a></h1>
<blockquote>
<p>警告</p>
<p>以下部分内容, 可能仅适用于<strong>1D</strong>的情况, 虽然ITensor开发了一些基于基于<strong>DMRG</strong>算法的扩展用以应对二维情况下系统, 但是这些方法的实现复杂度通常较高, 需要较长的计算时间和更高的计算资源.</p>
<p>如果你想要对二维系统进行计算, 请考虑使用<strong>PEPS</strong>(投影纠缠对态算法)或者<strong>MERA</strong>(<strong>Multi-scale Entanglement Renormalization Ansatz</strong>,多尺度嵌套正交模型)算法,
除了<strong>ITensor</strong>外你也可以考虑使用<strong>Qiskit, PyQuante</strong>等计算库, 从而实现基于哈密顿量对角化的能带计算.</p>
<p><span title="你知道的太多了" style="background-color: black; color: black;">所以为什么要学ITensor呢? 直接用matlab模拟不就好了</span></p>
</blockquote>
<p>如果我们想要求解<strong>一维</strong>哈密顿量的基态, <strong>DMRG</strong> 将是最好的方法.</p>
<p>方程式的形式如下:</p>
<p>$\hat{H}|\Psi\rangle = E|\Psi\rangle$</p>
<p>其中 $\hat{H}$ 和 $|\Psi\rangle$ 都化为对应量子位数的 矩阵乘积形式(<code>MPO</code> 和 <code>MPS</code>).</p>
<p>MPS的构造中不只是用到了我们之前所学的SVD和ReGroup, 它还包括了一些我们没有提到的处理操作, 这些操作被统称为&quot;规范化变换&quot;, 比如对张量进行单位化(unitarization).</p>
<p>这些处理是为了MPS在计算时具有良好性质, 比如计算物理量时具有最小误差.</p>
<blockquote>
<p>Importtant: MPS should be in definite gauge. I.e.most tensors unitary.</p>
</blockquote>
<p>就是在要求矩阵乘积态应当已经被规范化, 也就是大多数量子位的张量都是幺正的.</p>
<blockquote>
<p><strong>幺正 Unitary</strong></p>
<p>幺正本身是一个线性代数里的概念, 在这里我们用更物理一些的语言来描述这个性质.</p>
<p>如果一个算子 $\hat{U}$ , 还有一个态矢量 $|\psi\rangle$ ,能够满足以下条件:</p>
<ul>
<li>$\hat{U}|\psi\rangle\neq 0$;</li>
<li>$||\hat{U}|\psi\rangle|| = ||\psi\rangle||$;</li>
<li>$\langle\Phi|\hat{U}|\psi\rangle = \langle\Phi|\psi\rangle$
其中 $||\psi\rangle||$ 代表态势 $|\psi\rangle$ 的长度, 这个量可以通过求内积来得到.
那么我们就可以称这个算子是幺正的.</li>
</ul>
</blockquote>
<p>所以我们可以选定一个特定的位置(正则位置), 将其左右两边的张量全部都规范化处理, 从而定义出正交归一的基.</p>
<p>这样, 我们就可以计算出期望值 $\langle\Psi|\hat{H}|\Psi\rangle$ .其中 $|\Psi\rangle$ 和 $\hat{H}$ 都是矩阵乘积形式. 按照我们前面所说的,</p>
<h1 id="mera算法"><strong>MERA</strong>算法<a hidden class="anchor" aria-hidden="true" href="#mera算法">#</a></h1>
<blockquote>
<p><strong>Multi-scale Entanglement Renormalization Ansatz</strong></p>
<p>多尺度嵌套正交矩形模型. 这是对重整化群方法的扩展.
MERA将系统分解为一系列的张量, 每个张量代表了系统不同尺度下的状态. 每个张量的大小表示该尺度的自由度数目.</p>
<p>这些张量通过特定的变化相互连接, 从而形成具有分形结构的网络. 这样, 我们就可以将系统的纠缠结构表示为不同尺度上的简单张量网络.</p>
<p>具体来说, 每个张量被分为两个部分, 即上部分和下部分. 上部分表示的是低尺度的信息, 下部分表示的是高尺度的信息. 通过重复应用加密和解密操作, 就可以得到不同尺度下的系统状态.</p>
</blockquote>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://Muatyz.github.io/posts/phy/hcmp/tbg-fig-python/">
    <span class="title">« 上一页</span>
    <br>
    <span>使用Python绘制转角石墨烯</span>
  </a>
  <a class="next" href="https://Muatyz.github.io/posts/phy/calphy/itensor-donwload/">
    <span class="title">下一页 »</span>
    <br>
    <span>ITensor库安装说明</span>
  </a>
</nav>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>





<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>
    <div id="tcomment"></div>
    <script src="https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js"></script>
    <script>
        twikoo.init({
            envId: "https://twikoo-api-one-xi.vercel.app",  
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-shanghai',  
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        });
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>Muartz</span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script><script>

    let detail = document.getElementsByClassName('details')
   
    details = [].slice.call(detail);
   
    for (let index = 0; index < details.length; index++) {
   
    let element = details[index]
   
    const summary = element.getElementsByClassName('details-summary')[0];
   
    if (summary) {
   
    summary.addEventListener('click', () => {
   
    element.classList.toggle('open');
   
    }, false);
   
    }
   
    }
   
   </script>   

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"无处惹尘埃"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"无处惹尘埃"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"无处惹尘埃"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>

<script>
    $("code[class^=language] ").on("mouseover", function () {
        if (this.clientWidth < this.scrollWidth) {
            $(this).css("width", "135%")
            $(this).css("border-top-right-radius", "var(--radius)")
        }
    }).on("mouseout", function () {
        $(this).css("width", "100%")
        $(this).css("border-top-right-radius", "unset")
    })
</script>


<script>
    
    document.addEventListener('keydown', function(event) {
      
      if (event.key === 'j') {
        
        var nextPageLink = document.querySelector('.pagination-item.pagination-next > a');
        if (nextPageLink) {
          nextPageLink.click();
        }
      } else if (event.key === 'k') {
        
        var prevPageLink = document.querySelector('.pagination-item.pagination-previous > a');
        if (prevPageLink) {
          prevPageLink.click();
        }
      }
    });
  </script>
  

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fz6m/Private-web@1.2/js/custom/click.min.js"></script>

</body>





<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
  </head>


<body>
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
</body>


</html>
