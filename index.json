[{"content":"能带中的电子有效质量 电子的群速度:\n$$ \\vec{v}_{g} = \\nabla_{\\vec{k}}\\omega(\\vec{k})= \\frac{1}{\\hbar}\\nabla_{\\vec{k}}E(\\vec{k}) $$\n在一维情况下, 电子因为外力做功而获得能量 $\\delta E$\n$$ \\delta E = F v_{g}\\cdot\\delta t\\\\ \\Rightarrow \\delta E = \\frac{\\mathrm{d}E}{\\mathrm{d}k}\\cdot\\delta k = \\hbar v_{g}\\cdot\\delta k $$\n所以我们可以观察到一个类似于质量的参数在方程中产生作用:\n$$ \\hbar\\frac{\\mathrm{d}k}{\\mathrm{d}t} = F(\\hbar\\frac{\\mathrm{d}\\vec{k}}{\\mathrm{d}t}=\\vec{F})\\\\ \\frac{\\mathrm{d}v_{g}}{\\mathrm{d}t} = \\frac{1}{\\hbar}\\frac{\\mathrm{d}}{\\mathrm{d}t}(\\frac{\\mathrm{d}E}{\\mathrm{d}k}) = \\frac{1}{\\hbar}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k^2}\\frac{\\mathrm{d}k}{\\mathrm{d}t} = \\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k^{2}}F = \\frac{1}{m^{*}} $$\n所以我们就可以定义有效质量 $m^{*}$:\n$$ \\frac{1}{m^{*}} = \\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^2 E}{\\mathrm{d}k^2} $$\n而针对某个特定方向时, 即有\n$$ \\left(\\frac{1}{m{*}}\\right)_{\\mu\\nu}=\\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k_{\\mu}\\mathrm{d}k_{\\nu}} $$\n一些半定量的性质\n能带越平, 有效质量越大; 有效质量是多变量函数(动量位置, 能量位置)而非常数; 如果色散关系是严格的抛物线($E = a(\\vec{k}-\\vec{k}_{0})^{2}$), 则有效质量 $m^{*}$ 为常数. 线性色散对应的等效质量 如果色散呈现线性关系 $$ E = a(|\\vec{k}-\\vec{k}_{0}|), $$\n那么我们会得到一个荒谬的结果:\n$$ m^{*} = \\hbar^{2} \\frac{1}{\\nabla_{k}^{2}E}\\rightarrow \\infty $$\n正确的处理方法是使用另一种有效质量的定义方法:\n$$ m^{*} = \\hbar^{2}k\\left(\\frac{\\partial E}{\\partial k}\\right)^{-1} $$\n现在我们就有了对于线性色散的等效质量:\n$$ m^{*} = \\frac{\\hbar|\\vec{k}|}{v_{g}} = \\frac{\\hbar}{v_{g}}|\\vec{k}-\\vec{k}_{0}| $$\n我们已经知道能量为 $0$ 对应的 $k_{0}$ 为 \u0026ldquo;狄拉克点\u0026rdquo;, 在狄拉克点的位置有效质量严格为 $0$, 而狄拉克点附近的位置则是约为 $0$.\n对于质量为 $0$ 的电子, 我们的处理思路和无质量的光子类似, 也是利用相对论的能量关系解出电子群速度, 不同的是将原本的光速 $c$ 替换为电子群速度的 $v_{g}$:\n$$ E^{2} = (\\hbar k v_{g})^{2} + (m^{*}v_{g}^{2})^{2}\\\\ \\Rightarrow E^{2} = (\\hbar k v_{g})^{2}\\\\ \\Rightarrow E = \\pm \\hbar k v_{g} $$\n在上面的讨论中, 如果等效质量 $m^{*} = m_{0}$ 不为 $0$, 那么我们已经知道\n$$ E^{2} = (\\hbar k v_{g})^{2} + (m_{0}v_{g}^{2})^{2}\\\\ \\Rightarrow E = \\pm\\sqrt{(\\hbar k v_{g})^{2} + (m_{0}v_{g}^{2})^{2}} $$\n我们引入能隙符号 $\\Delta$, 且\n$$ \\Delta = 2m_{0}v_{g}^{2} $$\n同理, 如果我们预先知道了能隙 $\\Delta$, 那么我们可以得到等效质量 $m^{*}$: $$ m_{0} = \\frac{\\Delta}{2v_{g}^{2}} $$\n可以观察到, 电子和轻空穴的有效质量约正比于能隙大小.\n空穴的定义 对于全满的价带, 其电子总动量的关系为\n$$ \\sum\\vec{k} = \\vec{0} $$\n所以移去一个电子(其动量为 $\\vec{k}_{e}$), 价带的总动量变为\n$$ \\sum\\vec{k} = -\\vec{k}_{e} $$\n我们就可以看待满价带移去电子后剩下的空位为空穴.\n空穴的性质\n空穴动量: $\\vec{k}_{h} = -\\vec{k}_{e}$ 空穴能量: $E_{h}(\\vec{k}_{h}) = - E_{e}(\\vec{k}_{e})$ 空穴速度: $\\vec{v}_{h} = -\\frac{1}{\\hbar}\\nabla_{\\vec{k}_{h}}E_{h}(\\vec{k}_{h}) = \\frac{1}{\\hbar}\\nabla_{\\vec{k}_{e}}E_{e}(\\vec{k}_{e}) = \\vec{v}_{e}$ 和处理电子的等效质量类似, 我们也可以给出空穴的等效质量:\n$$ \\left(\\frac{1}{m^{*}}\\right)_{\\mu\\nu} = \\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k_{\\mu}\\mathrm{d}k_{\\nu}}\\\\ m_{h}^{*} = - m_{e}^{*} $$\n对于电子的受力方程一般为\n$$ \\hbar\\frac{\\mathrm{d}\\vec{k}_{e}}{\\mathrm{d}t} = -e(\\vec{E} + \\vec{v}_{e}\\times\\vec{B}) $$\n将里面的符号进行等效替代, 就有了\n$$ \\hbar\\frac{\\mathrm{d}\\vec{k}_{h}}{\\mathrm{d}t} = e(\\vec{E} + \\vec{v}_{h}\\times \\vec{B}) $$\n半导体中的跃迁 半导体可以直接跃迁, 也可以间接跃迁. 间接跃迁需要声子动量作为辅助. 因此直接跃迁的效率远大于间接跃迁.\n重空穴带中态密度高, 光吸收时哦那个重空穴带激发电子的数目会远高于轻空穴带中的.\n在直接跃迁中, 可能会出现光吸收谱的尖峰, 这个尖峰被称作 Exciton 峰(激子峰). 这是因为电子被激发后形成空穴, 而电子和空穴之间仍然存在库伦相互作用. 这种电子-空穴对被称作激子.\nFrenkel 激子: 电子空穴距离在晶格常数左右. 常见于有机物, 量级为 $\\text{eV}$; Wannier 激子: 电子空穴距离远大于晶格常数, 常见于无机半导体. 量级为 $\\text{meV}$. 我们先看 Wannier 激子. 激子的结构可以类比于氢原子, 但是电子和空穴的质量相对差会更小. 我们使用调和定义激子的有效质量:\n$$ \\frac{1}{\\mu^{*}} = \\frac{1}{m_{C}^{*}} + \\frac{1}{m_{hh}^{*}}\\\\ (m_{C}^{*} = 0.067m_{e}, m_{hh}^{*} = 0.45m_{e}) $$\n对于氢原子的能量公式我们已经很熟了:\n$$ E(n) = -\\frac{m_{e}e^{4}}{8\\epsilon_{0}^{2}h^{2}n^{2}} = -\\frac{13.6}{n^{2}}\\text{eV} $$\n对于激子, 要做出的替换即质量, 材料的介电常数:\n$$ E(n) = -\\frac{\\mu^{*}}{m_{e}}\\cdot\\frac{1}{\\epsilon_{r}^{2}}\\times\\frac{13.6}{n^{2}}\\text{eV} $$\n因为这里我们使用的是氢原子能量公式, 所以相应地, 能量的参考点也应该取为导带底的能量.\n同理, 对于氢原子的玻尔半径, 有 $$ a_{0} = \\frac{\\epsilon_{0}h^{2}}{\\pi m_{e}e^{2}} \\approx 0.53\\text{Å} $$\n替换为激子的有效质量并且引入相对介电常数:\n$$ a_{0}^{*} = \\frac{\\epsilon_{r}m_{e}}{\\mu^{*}}\\cdot 0.53 $$\n能带中的粒子浓度 本征半导体\n本征半导体被称为 \u0026ldquo;晶格完美的半导体\u0026rdquo;, 即 $T = 0$ 时, 电子全部都在价带, 导带中完全没有电子.\n我们已经知道, 金属载流子浓度基本不随温度变化, 而半导体载流子浓度则为强烈依赖于温度.\n单位能量范围内的载流子浓度为\n$$ \\mathrm{d}n = f(E, T)g(E)\\mathrm{d}E $$\n$f(E, T)$ 为 Fermi-Dirac 分布: $$ f(E,T) = \\frac{1}{1+e^{(E-\\color{red}{\\mu})/k_{B}T}} $$ $g(E)$ 为态密度.\n如果化学势离带边都很远, 即采用极限 $E - \\mu\\gg k_{B}T$, 那么 Fermi-Dirac 分布可以近似为 Boltzmann 分布:\n$$ f(E, T) \\approx e^{-(E-\\mu)/k_{B}T} $$\n所以在导带中找到一个电子的概率为\n$$ f_{C}\\approx e^{-(E-\\mu)/k_{B}T} $$\n相应的, 在价带中找到一个空穴的概率为\n$$ f_{h} = 1 - f_{V} = 1 - \\frac{1}{1 + e^{(E - \\mu)/k_{B}T}} = \\frac{1}{1 + e^{\\mu - E}/k_{B}T}\\\\ \\Rightarrow\\lim_{\\mu-E\\gg k_{B}T}f_{h} = e^{-(\\mu-E)/k_{B}T} $$\n而对于微分式中的另一部分, 即 $g(E)$, 我们通常将其近似为抛物线色散关系.\n$$ \\text{导带底附近: }E - E_{C} = \\frac{(k-k_{C})^{2}}{2m_{C}^{*}}\\\\ \\text{价带顶附近: }E - E_{V} =-\\frac{(k-k_{V})^{2}}{2m_{h}^{*}} $$\n而对于类抛物线的能带, 我们可以移植自由电子部分的结论:\n$$ g(\\epsilon) = \\frac{1}{\\pi^{2}\\hbar^{3}}(2m^{3}E)^{\\frac{1}{2}}\\\\ \\Rightarrow g_{C}(E) = a(m_{C}^{*})^{\\frac{3}{2}}(E - E_{C})^{\\frac{1}{2}}\\\\ \\Rightarrow g_{V}(E) = a(m_{h}^{*})^{\\frac{3}{2}}(E_{V} - E)^{\\frac{1}{2}} $$\n对微分式进行积分, 就能够得到导带中的电子浓度:\n$$ n = \\int_{E_{C}}^{\\infty}\\underbrace{f_{C}}_{e^{-(E-\\mu)/k_{B}T}}\\overbrace{g_{C}}^{a(m_{C}^{*})^\\frac{3}{2}(E-E{C})^{\\frac{1}{2}}}\\mathrm{d}E\\\\ \\Rightarrow n \\approx a(m_{C}^{*})^{\\frac{3}{2}}\\int_{E_{C}}^{\\infty}(E-E_{C})^{\\frac{1}{2}}e^{-\\frac{E-\\mu}{k_{B}T}}\\mathrm{d}E\\\\ = N_{c} e^{-\\frac{E_{C}-\\mu}{k_{B}T}} $$\n$$ N_{C} = 2(\\frac{k_{B}}{2\\pi\\hbar^{2}})^{\\frac{3}{2}}(m_{C}^{*}T)^{\\frac{3}{2}} $$\n同理我们可以计算得到价带中空穴浓度:\n$$ p \\approx N_{V}e^{-\\frac{\\mu - E_{V}}{k_{B}T}} $$\n$$ N_{V} = 2(\\frac{k_{B}}{2\\pi\\hbar^{2}})^{\\frac{3}{2}}(m_{h}^{*}T)^{\\frac{3}{2}} $$\n我们可以看到 $n$ 和 $p$ 的函数形式类似, 而且做积有\n$$ np\\approx WT^{3}e^{-\\frac{E_{g}}{k_{B}T}} $$\n上面的这个式子被称为 \u0026ldquo;Law of Mass Action\u0026rdquo;. 当然在使用这个结论前, 我们需要牢记其前提条件: $|\\mu - E|\\gg k_{B}T$\n半导体中的化学势 我们已经求解出电子浓度和空穴浓度的表达式:\n$$ n = N_{C}e^{-\\frac{E_{C}-\\mu}{k_{B}T}}, p = N_{V}e^{-\\frac{\\mu-E_{V}}{k_{B}T}} $$\n对于本征半导体, $n = p$. 即有 $$ \\frac{N_{V}}{N_{C}} = e^{\\frac{2\\mu-E_{C}-E_{V}}{k_{B}T}} $$ 而又已知 $$ N_{C}\\propto (m_{C}^{*}T)^{\\frac{3}{2}}, N_{V}\\propto (m_{h}^{*}T)^{\\frac{3}{2}} $$ 带入到上式中即有 $$ \\mu = \\frac{1}{2}(E_{C}+ E_{V}) + \\frac{3}{4}k_{B}T\\ln{\\frac{m_{h}^{*}}{m_{C}^{*}}} $$ 基于以上推导, 我们可以得到一些简单推论:\n$T = 0\\text{K}$ 时, $\\mu = \\frac{1}{2}(E_{C}+E_{V})$, 即能隙的正中间; $T \u0026gt; 0\\text{K}$ 且 $m_{h}^{*} \u0026gt; m_{C}^{*}$ 时, $\\mu$ 偏向于价带. 常识: 室温下, 本征半导体的载流子浓度约为 $10^{10\\to 13}\\text{cm}^{-3}$.\n半导体的电导率 我们定义载流子的迁移率($\\mu_{e}, \\mu_{h}$):\n$$ \\mu = \\frac{|v|}{E} $$\n电荷 $q$ 的漂移速度 $v = \\frac{q\\tau E}{m}$, $\\tau$ 为碰撞时间.\n因此就有 $$ \\mu_{e/h} = \\frac{e\\tau_{e/h}}{m_{e/h}} $$\n对于半导体而言, 电导率为 $$ \\sigma = ne\\mu_e + pe\\mu_h $$\n半导体的掺杂 施主(Donors): n 型掺杂; 受主(Acceptors): p 型掺杂. 掺杂后的电子/空穴可能的状态:\n束缚在杂质的周围, 不参与导电; 进入到导带或者价带, 参与导电. 取决于掺杂电子/空穴的能量/温度\n浅掺杂能级杂质: 掺杂电子/空穴相对导带/价带边的能量较小;\n此时仍然可以使用类氢原子模型. 即有\n电子: $$ E_{d} = -\\frac{m_{C}^{*}}{m_{e}}\\cdot\\frac{1}{\\epsilon_{r}^{2}}\\times\\frac{13.6}{n^{2}}(\\text{eV}) $$\n空穴: $$ E_{a} = -\\frac{m_{V}^{*}}{m_{e}}\\cdot\\frac{1}{\\epsilon_{r}^{2}}\\times\\frac{13.6}{n^{2}}(\\text{eV}) $$\n室温下, 掺杂能级上的电子/空穴基本电离导带/价带, 从而参与到导电中.\n深掺杂能级杂质: 掺杂电子/空穴相对导带/价带边的能量较大.\n下图为杂质能级的位置示意图\n在掺杂较少的情况下, 化学势 $\\mu$ 仍然在能隙范围内. 所以此时关系\n$$ np = WT^{3}e^{-\\frac{E_{g}}{k_{B}T}} $$\n仍然成立.\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/semi-conductor/","summary":"能带中的电子有效质量 电子的群速度: $$ \\vec{v}_{g} = \\nabla_{\\vec{k}}\\omega(\\vec{k})= \\frac{1}{\\hbar}\\nabla_{\\vec{k}}E(\\vec{k}) $$ 在一维情况下, 电子因为外力做功而获得能量 $\\delta E$ $$ \\delta E = F v_{g}\\cdot\\delta t\\\\ \\Rightarrow \\delta E = \\frac{\\mathrm{d}E}{\\mathrm{d}k}\\cdot\\delta k = \\hbar v_{g}\\cdot\\delta k $$ 所以我们可以观察到一个类似于质量的参数在方程中产生作用: $$ \\hbar\\frac{\\mathrm{d}k}{\\mathrm{d}t} = F(\\hbar\\frac{\\mathrm{d}\\vec{k}}{\\mathrm{d}t}=\\vec{F})\\\\ \\frac{\\mathrm{d}v_{g}}{\\mathrm{d}t} = \\frac{1}{\\hbar}\\frac{\\mathrm{d}}{\\mathrm{d}t}(\\frac{\\mathrm{d}E}{\\mathrm{d}k}) = \\frac{1}{\\hbar}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k^2}\\frac{\\mathrm{d}k}{\\mathrm{d}t} = \\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k^{2}}F = \\frac{1}{m^{*}} $$ 所以我们就可以定义有效质量 $m^{*}$: $$ \\frac{1}{m^{*}} = \\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^2 E}{\\mathrm{d}k^2} $$ 而针对某个特定方向时, 即有 $$ \\left(\\frac{1}{m{*}}\\right)_{\\mu\\nu}=\\frac{1}{\\hbar^{2}}\\frac{\\mathrm{d}^{2}E}{\\mathrm{d}k_{\\mu}\\mathrm{d}k_{\\nu}}","title":"半导体基础"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 有意栽花花满枝 心中有光、点亮生活 宣嘉乐 致远学者 👉友链格式 名称： Blog-Name 网址： https://www.blogurl 图标： https://www.blogurl/img/Title.png 描述： Description of the site 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://Muatyz.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 有意栽花花满枝 心中有光、点亮生活 宣嘉乐 致远学者 👉友链格式 名称： Blog-Name 网址： https://www.blogurl 图标： https://www.blogurl/img/Title.png 描述： Description of the site 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":" 涉密警告 本次课设所使用的十年引航中断相关的数据均为涉密, 而本小组全体成员均已签订保密契约以进行课设工作. 因此下面所使用的代码不会展示任何具体的数据, 而只是展示其工作原理. 本文将介绍本人所负责的问题一部分, 即对十年的引航中断数据进行分析, 并且得出相应的结论.\n问题分析 项目提供的数据集给出了 2011-2020 共 10 年发生引航中断的情况统计, 其中导致引航中断的原因包括大风管制和能见度不良两类, 本题中暂不考虑能见度不良情况的分析, 只关注大风管制的分析. 请筛选出大风管制的情况统计, 统计大风管制日的风向、风级情况 注意: 风向和风级情况每日可能不是稳定的, 请设计数据处理规则, 能够有效地代表当日的风向、风级情况.\n要求运用数据可视化的方法展示统计结果, 并文字说明风向和风级的数据处理规则, 附 XLSX 文件, 包括全部大风管制日的风向和风级. (15 分)\n根据上一问中的分析, 建模分析不同风向和风级对触发引航中断的影响, 要求展现出 10 年间的影响情况, 并给出触发引航中断的风向和风级规律(可以是各因素的独立阈值, 也可以是双因素耦合的阈值). (15 分) 数据样例介绍： Sheet 1：2020年通航管制情况统计表——2020年引航中断时间的汇总, 其中本题只考虑大风管制的情况, 分别包括引航暂停的日期、暂停起止时间和暂停时长. Sheet 2：2020年1月8日洋山港海事局工作报告——使用其中的舟山附近沿海当日气象简报. Sheet 3：观测线6警戒区——经过观测线的船舶信息记录, 使用其中的船名、船舶种类、船舶长度、报告线名称、船舶航向、船舶航速、穿越时间、经度和纬度等信息. 观察发现所给的数据表格格式不一, 为了能够使用统一方式对数据进行挖掘处理, 需要将所有文件整合为 XLSX 格式.\n按年顺序读取源表格文件后, 读取首页的 sheet 并且读取对应的日期. 在这个过程中, 还涉及了对于 sheet 格式上的剪裁处理和对字符串的重整化.\n由任务要求可知, 需要整理大风管制引起的引航中断, 因此可以提取大风管制对应的日期并查询当天海面的天气情况.\n而在该任务提供的数据文件中, 天气信息都是纯粹文本, 我们需要对其中的有效信息进行提取. 所以在这里我们选择了使用正则表达式进行筛选.\n读取到各年大风管制日期下的风向风级后, 就可以使用 OriginPro 软件提供的绘图功能对(风向, 风级)信息进行统计并且总结规律.\n任务一所涉及的代码根据需求被分为两个部分:classifier.py, calcute.py. 前者进行数据的读取, 后者进行数据的整理.\n读取数据 #classifier.py #! -*- coding=utf-8 -*- from numpy import NaN import pandas as pd import re import openpyxl import pyexcel as p import xlwings as xw import shutil years=[str(x) for x in range(2011,2020+1)] for year in years: #按年读取表格文件############################################### parentpath=r\u0026#34;./Project02-Data-31/任务一-引航中断-气象统计数据\u0026#34; path=parentpath+r\u0026#39;/\u0026#39;+year+r\u0026#34;年气象统计.xlsx\u0026#34; #将新的mainsheet写入原来的表格而不删除其余的sheet if int(year)\u0026gt;=2019: #2019年和2020年文件为.xls格式, 转为.xlsx格式 p.save_book_as(file_name=path[:-1],dest_file_name=path) f=pd.ExcelFile(path) wb=xw.Book(path) SheetNames=f.sheet_names mainsheet=pd.read_excel(path,sheet_name=SheetNames[0]) #将sheet整理为和2019年以前相同的格式（即删除表头并日期列调整至第一列） mainsheet=mainsheet.iloc[1:,1:] orisht=wb.sheets(SheetNames[0]) orisht.delete() sht=wb.sheets.add(name=year+\u0026#39;年影响通航\u0026#39;,before=SheetNames[1]) sht.range(\u0026#39;A1\u0026#39;).value=mainsheet.values wb.save(year+r\u0026#34;年气象统计.xlsx\u0026#34;) wb.close() file=year+r\u0026#34;年气象统计.xlsx\u0026#34; shutil.copy(file,parentpath)#将生成的文件覆盖在源文件上 ######################################################### f=pd.ExcelFile(path) #获取工作表名称 SheetNames=f.sheet_names #检查是否读取成功 print(SheetNames) #读取第一张sheet mainsheet=pd.read_excel(path,sheet_name=year+\u0026#39;年影响通航\u0026#39;) #读取第一页的文件并获得一些基本数据 rowNum=mainsheet.shape[0] #读取第一页sheet的第一二列的有效数据 datePlus=mainsheet.iloc[2:rowNum-3,[0,1]] datePlus=datePlus.dropna(axis=0,how=\u0026#39;any\u0026#39;) #获取当年大风管制日期 date=datePlus.iloc[:,0] #检查读取的大风管制时间段 print(date) #将时间段拆分为单天 Date=[] for i in range(date.shape[0]): date.iloc[i]=date.iloc[i][5:] series=[] if \u0026#39;-\u0026#39; in date.iloc[i]: ###########对.和-进行定位############### loc1=date.iloc[i].index(\u0026#39;.\u0026#39;) loc2=date.iloc[i].index(\u0026#39;-\u0026#39;) ######注意去除日期单元格中偶尔出现的中文## begin=int(re.sub(\u0026#39;[\\u4e00-\\u9fa5]\u0026#39;, \u0026#39;\u0026#39;,date.iloc[i][loc1+1:loc2])) end=int(re.sub(\u0026#39;[\\u4e00-\\u9fa5]\u0026#39;, \u0026#39;\u0026#39;,date.iloc[i][loc2+1:])) month=str(re.sub(\u0026#39;[\\u4e00-\\u9fa5]\u0026#39;, \u0026#39;\u0026#39;,date.iloc[i][:loc1+1])) for j in range(begin,end+1): if month+str(j) not in Date: #############避免重复登记已经登记过的日期####### Date.append(month+str(j)) else: Date.append(str(re.sub(\u0026#39;[\\u4e00-\\u9fa5]\u0026#39;, \u0026#39;\u0026#39;,date.iloc[i]))) date=pd.DataFrame(date) #检查去年份是否成功 print(date) #检查真正的日期序列是否生成成功 print(Date) ########以生成的日期依次查询当年的风向风级的情况########### Time=[] Land=[] #海面的天气信息相较于陆地的对引航中断应当更直接 Sea=[] for day in Date: \u0026#34;\u0026#34;\u0026#34; 该版本为完全排除空日期(无法由Date直接查询到的日期) \u0026#34;\u0026#34;\u0026#34; if day in SheetNames: Sheet=pd.read_excel(path,sheet_name=day) Time.append(day) Land.append(Sheet.iloc[1,0]) Sea.append(Sheet.iloc[2,0]) else: #最严谨的方式是如果这一天没有读取到, 应当再读取前一天天气中\u0026#34;明天\u0026#34;的信息 #但是天气的记录格式不一, 所以这里选择若没有该天的天气记录, 就选择不录入 pass #创建时间和天气关系的字典并生成表格 dic={\u0026#39;Day\u0026#39;:Time,\u0026#39;Land\u0026#39;:Land,\u0026#39;Sea\u0026#39;:Sea} Ori=pd.DataFrame(dic) #检查生成风向风级原始数据表是否成功 print(Ori) #######文本处理程序, 读取原始数据中的风向和风级信息############### #创建空表格以备读写 tmp=pd.DataFrame() processedPath=\u0026#39;./ProcessedData/ProcessedData\u0026#39;+year+\u0026#39;.xlsx\u0026#39; tmpFile=tmp.to_excel(processedPath) #使用正则表达式进行信息读取 for orisentence in Sea: WeatherDay=str(Time[Sea.index(orisentence)]) law=r\u0026#34;([今|明|后]天)?([东|西|偏]?[南|北|东|西]?)?[到]?([东|西|偏]?[南|北|东|西|阵]?)?风(\\d)[\\-]?([\\d]?)级\u0026#34; Weather=re.findall(law,orisentence,re.S) \u0026#39;\u0026#39;\u0026#39; 此处使用的正则表达式进行天气信息的筛选, 严格来说应该编辑状态自动机进行读取. 但是由于天气信息的撰写方式实在不一, 所以选用了一个通用性较高的方法. 若用Pytorch进行语言处理应当是最专业的, 限于能力水平并未使用. \u0026#39;\u0026#39;\u0026#39; if Weather: day=[] #风向可能会发生改变, 如\u0026#34;东到东北风\u0026#34;等 diraction1=[] diraction2=[] #记录最小风级和最大风级 minscale=[] maxscale=[] for i in range(len(Weather)): day.append(Weather[i][0]) #若有空白部分, 则从另一部分复制数据# ############风向部分的空白填充############# if Weather[i][2]==\u0026#39;\u0026#39;: diraction1.append(Weather[i][1]) diraction2.append(Weather[i][1]) elif Weather[i][2]==\u0026#39;\u0026#39;: diraction1.append(Weather[i][2]) diraction2.append(Weather[i][2]) else: diraction1.append(Weather[i][1]) diraction2.append(Weather[i][2]) ##############风级部分的空白填充########## if Weather[i][4]!=\u0026#39;\u0026#39; and int(Weather[i][3])\u0026gt;int(Weather[i][4]): #排除读到10的时候将1和0拆开 minscale.append(str(Weather[i][3])+str(Weather[i][4])) maxscale.append(str(Weather[i][3])+str(Weather[i][4])) elif Weather[i][4]==\u0026#39;\u0026#39;: #对仅有一个数字的进行复制粘贴处理 minscale.append(str(Weather[i][3])) maxscale.append(str(Weather[i][3])) else: #其他情况正常入位 minscale.append(str(Weather[i][3])) maxscale.append(str(Weather[i][4])) #生成日期和天气关系的字典并生成表格 weatherdic={\u0026#39;日期\u0026#39;:day,\u0026#39;风向1\u0026#39;:diraction1,\u0026#39;风向2\u0026#39;:diraction2,\u0026#39;小风级\u0026#39;:minscale,\u0026#39;大风级\u0026#39;:maxscale} df=pd.DataFrame(weatherdic) #在该文件中依次创建新worksheet,填入相应的df with pd.ExcelWriter(processedPath,mode=\u0026#39;a\u0026#39;) as writer: df.to_excel(writer,sheet_name=WeatherDay) #清理读写期间产生的无用sheet(即Sheet1) processedExcel=openpyxl.load_workbook(processedPath) wastedSheet=processedExcel[\u0026#39;Sheet1\u0026#39;] processedExcel.remove(wastedSheet) #将读写完毕的表格存储起来 processedExcel.save(processedPath) 分析数据 风向分级确定准则 由上述的代码不难看出, 对于一段源文件的天气信息文本, 即使是同一正则表达式也可能会读出多条结果. 有的是同一天内的多条数据, 有的是不同天里的数据(这是因为某些日期的数据并不存在于对应的大风管制日期的表格中, 而是存在于某些相邻的大风管制日期.)\n所以我们收集天气的策略是: 已知大风管制期间的天气记录并不止一天, 结合正则表达式的读取效果, 将读取数据的第一天和第二天之间的所有数据； 然后风级就是风向数据的最大值和最小值, 风向则是这些数据的第一对(记录数据时, 风向可能会以\u0026quot;东到东北风\u0026quot;的方式呈现, 所以风向会以成对的形式记录下来. 至于本来就只有一个风向的, 就视为这一对风向的两个元素都是相同的).\n虽然这样的处理可能看似有些草率, 但是结合具体的天气信息文本不难看出, 出现异常情况往往都是都会是日期连报(如\u0026rsquo;今天、明天东到东北风\u0026rsquo;), 而且大风管制的日期也有可能是连续的, 所以即使按照上文所述的模糊识别方法, 也是有一定证据支撑的.\n下面是具体的代码实现:\n#! -*- coding=utf-8 -*- from numpy import NAN, NaN, nan import pandas as pd #######################读取真正的风向风级################## #逐年读取已经生成完毕的日期-天气表格 years=[str(x) for x in range(2011,2020+1)] #预先分配list以存储读取的对应数据 Time=[] Diraction1=[] Diraction2=[] minScale=[] maxScale=[] for year in years: processedPath=\u0026#39;./ProcessedData/ProcessedData\u0026#39;+year+\u0026#39;.xlsx\u0026#39; f=pd.ExcelFile(processedPath) SheetNames=f.sheet_names #按天读取当天的风向风级 for day in SheetNames: sht=pd.read_excel(processedPath,sheet_name=day) date=list(sht[\u0026#39;日期\u0026#39;].values) dira1=list(sht[\u0026#39;风向1\u0026#39;].values) dira2=list(sht[\u0026#39;风向2\u0026#39;].values) scale1=list(sht[\u0026#39;小风级\u0026#39;].values) scale2=list(sht[\u0026#39;大风级\u0026#39;].values) #去除空白日期，即记录在\u0026#39;日期\u0026#39;列里实际记录的天数(今天，明天或后天) date_brief=[sing for sing in date if sing==sing] #记录日期所在位置的索引 date_index=[] for sing in date_brief: date_index.append(date.index(sing)) if len(date_brief)==1: #若记录在列的只有一天，那么无论这一天是哪一天都将其作为当天的数据 diraction1=dira1[date_index[0]:] diraction2=dira2[date_index[0]:] minscale=min(scale1[date_index[0]:]) maxscale=max(scale2[date_index[0]:]) else: #记录的不止一天的时候，就将第一天和第二天之间的数据收集起来 #即，有可能读取到的是\u0026#34;今天，后天\u0026#34;,那么也会记录这两者之间的所有数据 diraction1=dira1[date_index[0]:date_index[1]] diraction2=dira2[date_index[0]:date_index[1]] minscale=min(scale1[date_index[0]:date_index[1]]) maxscale=max(scale2[date_index[0]:date_index[1]]) #预先分配list对风向的两个方向进行存储 d1list=[] d2list=[] #记录风向风级时先记录对应天的日期，为了避免重复还要加上年份的信息 Time.append(year+r\u0026#39;.\u0026#39;+day) #在数据中会有空格和\u0026#39;阵\u0026#39;的数据，按照我们对于地理的理解即阵风为最大风级 #所以在记录时，将两天之间的所有风级进行比较，阵风为最大值所以必定包括在比较当中 for d1 in diraction1: if str(d1)!=\u0026#39;nan\u0026#39; and str(d1)!=\u0026#39;阵\u0026#39;: d1list.append(str(d1)) for d2 in diraction2: if str(d2)!=\u0026#39;nan\u0026#39; and str(d2)!=\u0026#39;阵\u0026#39;: d2list.append(str(d2)) #完成对于数据的清理之后，读取风向的规则即为其中的第一次风向信息的结果 #即，忽略了随着时间变化风向信息随之变化的过程。 #最严谨的方法是结合天气记录档案的最下方的引航中断时间(中午或者下午)来判断 #最正确的时间，但是仅仅借助正则表达式这个任务是异常困难的 Diraction1.append(d1list[0].replace(\u0026#39;偏\u0026#39;,\u0026#39;\u0026#39;)) Diraction2.append(d2list[0].replace(\u0026#39;偏\u0026#39;,\u0026#39;\u0026#39;)) #在使用正则表达式读取风向的时候，会读进\u0026#39;偏\u0026#39;字符 #在进行数据处理时则将偏字去除以备后期进行字典代换 minScale.append(minscale) maxScale.append(maxscale) #手动写入方向和度数的对应字典 word_to_num={\u0026#39;东\u0026#39;:0,\u0026#39;西\u0026#39;:180,\u0026#39;南\u0026#39;:270,\u0026#39;北\u0026#39;:90,\u0026#39;东南\u0026#39;:315,\u0026#39;东北\u0026#39;:45,\u0026#39;西南\u0026#39;:225,\u0026#39;西北\u0026#39;:135} #预先分配读入读数的list Diraction1_num=[] Diraction2_num=[] #使用已写好的字典对方向进行代换 for i in range(len(Time)): Diraction1_num.append(word_to_num[Diraction1[i]]) Diraction2_num.append(word_to_num[Diraction2[i]]) #生成新字典并且生成表格 dira_and_scale={\u0026#39;日期\u0026#39;:Time,\u0026#39;风向1\u0026#39;:Diraction1,\u0026#39;风向1num\u0026#39;:Diraction1_num,\u0026#39;风向2\u0026#39;:Diraction2,\u0026#39;风向2num\u0026#39;:Diraction2_num,\u0026#39;小风级\u0026#39;:minScale,\u0026#39;大风级\u0026#39;:maxScale} df=pd.DataFrame(dira_and_scale) processedPath=\u0026#39;./ProcessedData/data.xlsx\u0026#39; #将生成的表格记录下 file=df.to_excel(processedPath) 结论 首先是得到一张十年尺度的日期-风向风级的表格, 其中已经包含了对风向读为度数的列.\n使用 OriginPro 的风向玫瑰图的绘制功能不难绘制出风向和风级在大风管制期间的规律. 由上述图可以分析得到的结论是:\n大风管制发生时，风向各个风向都有，但是大多集中在西北方向，而且也是西北方向的风级最大; 风级一般要达到5级及以上时才会触发满足大风管制的条件. ","permalink":"https://Muatyz.github.io/posts/cs/intro-two-cs-project2/","summary":"涉密警告 本次课设所使用的十年引航中断相关的数据均为涉密, 而本小组全体成员均已签订保密契约以进行课设工作. 因此下面所使用的代码不会展示任何具体的数据, 而只是展示其工作原理. 本文将介绍本人所负责的问题一部分, 即对十年的引航中断数据进行分析, 并且得出相应的结论. 问题分析 项目提供的数据集","title":"课设"},{"content":"绪论 已知两个长度为 $m$ 和 $n$ 的升序链表, 若将它们合并为长度为 $m + n$ 的一个降序链表, 则最坏情况下的时间复杂度为__. O(max(m,n))\n两个升序链表进行合并, 一个链表比完了, 另一个链表剩下的直接接上即可. 所以实际上的比较次数是 $m + n - 1 $ 次, 使用 max() 时就化简为答案的格式. 线性表 顺序表 顺序表上实现比在链表上实现效率更高的操作是__. I, II I. 输出第 i 元素; II. 交换第3元素与第4元素; III.顺序输出所有元素.\n顺序表能够随机读取, 所以肯定在 I 更快; 而链表的交换需要通过遍历找到前驱节点, 所以相比于顺序表的swap()操作(三次)更为繁琐. 链表 顺序存储结构和链式存储结构都可以进行顺序存取. (T/F)__ T\n注意搞清楚\"顺序存取\"和\"随机存取\"之间的联系和区别. 顺序存储两者都可实现, 而链式存储只能实现顺序存取. 与单链表相比, 双链表的优点之一是:__ D\nA. 插入删除更方便\nB. 可以进行随机访问\nC. 可以省略表头指针或表尾指针\nD. 访问前后相邻结点更灵活\nA. 都不用移动元素, 只需要改变指针. 而且双链表反而更复杂一些 一个链表最常用的操作是在末尾插入结点和删除结点, 则选用__最节省时间. A\nA. 带头结点的双循环链表 B. 单循环链表 C. 带尾指针的单循环链表 D. 单链表\n这里要求使用尾插法和尾删法时最便捷, 那么就是需要读取尾结点和尾结点的前驱结点的地址. B. 单循环链表, 读取尾结点需要遍历; C. 带尾指针的单循环链表, 删除尾结点时, 需要更新尾结点的前驱结点, 因此也需要遍历; D. 单链表, 当然是最麻烦的 要求对线性表支持4种操作: 删除第一元素, 删除最后一个元素, 在第一个元素前插入元素, 在最后一个元素之后插入元素. 那么最好使用:__ I, II\nA. 有尾指针, 无头指针, 循环单链表\nB. 有尾指针, 无头指针, 双链表\nC. 有头指针, 无尾指针, 循环双链表\nD. 有头指针, 有尾指针, 循环单链表\nA. 删尾结点需要其前驱结点更新指针域, 从前往后遍历耗时$O(n)$; B. 删头节点需要其后继结点更新指针域, 从后往前遍历耗时$O(n)$; D. 删尾结点需要其前驱结点更新指针域, 从前往后遍历耗时$O(n)$. 栈, 队列, 数组 栈 设链表不带头结点且操作总在表头进行, 则最不适合作为链栈的是( C )\nA. 有表头指针, 无表尾指针的双向循环链表\nB. 有表尾指针, 无表头指针的双向循环链表\nC. 有表头指针, 无表尾指针的单向循环链表\nD. 有表尾指针, 无表头指针的单向循环链表\nC. 已知使用头插法和头删法, 而且没有头结点, 因此这个单向循环链表在完成增删操作后就需要将尾结点的 next 更新为新头结点的地址. 而该链表又没有尾指针, 因此每次更新都需要重新遍历得到尾结点. 采用共享栈的好处是( B ).\nA. 减少存取时间, 降低发生上溢的可能\nB. 节省存储空间, 降低发生上溢的可能\nC. 减少存取时间, 降低发生下溢的可能\nD. 节省存储空间, 降低发生下溢的可能\n上溢: 相当于\"栈满\", 指栈已经满了还要往里添加新元素; 下溢: 相当于\"栈空\", 指站已经空了还要向外弹出一个元素. 共享栈节省空间是必然的, 为什么说是降低发生上溢的可能呢? 这是因为操作都是在栈顶进行的, 只有可能是产生上溢.(两个栈顶指针相逢) 给定有限符号集 S, in 和 out 均为 S 中所有元素的任意排列, 对于初始空的栈 ST, 下列叙述正确的是( D )\nA. 若 in 为 ST 的入栈序列, 则不能判断 out 是否为其可能的出栈序列\nB. 若 out 为 ST 的出栈序列, 则不能判断 in 是否为其可能的入栈序列\nC. 若 in 为 ST 的入栈序列, out 是对应 in 的出栈序列, 则 in 与 out 一定不同\nD. 若 in 为 ST 的入栈序列, out 是对应 in 的出栈序列, 则 in 与 out 可能互为倒序\n这里重点要积累的是 A,B. 实际上, 只有我们能够确定哪一个是出栈, 哪一个是入栈, 那么我们一定可以通过模拟出入栈来判断两者是否可以具有对应关系. 因此A, B里的\"不能判断\"是错误的 队列 最适合用作链队的是( B )\nA. 带队首指针和队尾指针的循环单链表\nB. 带队首指针和队尾指针的非循环单链表\nC. 只带队首指针的非循环单链表\nD. 只带队首指针的循环单链表\nA. 相较于 B. 的循环条件对于队列而言是完全多余的. 最不适合用作链队的链表是( A)\nA. 只带队首指针的非循环双链表\nB. 只带队首指针的循环双链表\nC. 只带队尾指针的循环双链表\nD. 只带队尾指针的循环单链表\n最不适合用作链队的链表是( A)\nA. 只带队首指针的非循环双链表\nB. 只带队首指针的循环双链表\nC. 只带队尾指针的循环双链表\nD. 只带队尾指针的循环单链表\n对于循环链表而言, 只要知道了队头和队尾指针中的一个, 就可以通过结构体内的 prior 或着 next 知道另一个. 而对于A. 选项, 又是双链表, 又是非循环, 极大地增加了更新结点所需要的工作量. 所以 A 最不合适. 假设循环单链表表示的队列长度为 n, 队头固定在链表尾, 若只设头指针, 则进队操作的时间复杂度为( A)\nA. $O(n)$\nB. $O(1)$\nC. $O(n^2)$\nD. $O(n\\log_2 n)$\n注意:设置头指针就隐藏着一层含义, 即这个链表并没有头结点. 所以进队时会使头结点产生更新, 这又是一个循环链表, 所以每次进队后都要遍历一次以得到尾结点并且更新其 next 指针, 所以综合下来的时间复杂度为 $O(n)$. 已知循环队列存储在一维数组 A[0..n-1]中, 且队列非空时, front 和 rear 分别指向队头元素和队尾元素. 若初始时队列为空, 且要求第一个进入队列的元素存储在 A[0] 处, 则初始时的 front 和 rear 的值分别为( 0, n - 1)\n记住队列结构中, 入队看的是 rear 指针, 也就是 rear = (rear + 1) % n, 所以如果我们要让第一个入队的元素位置在A[0], 那么就有 (rear0 + 1) % n = 0, 反解即有 rear0 = n - 1. 栈与队列的应用 栈的应用不包括( D)\nA. 递归 B. 进制转换 C. 迷宫求解 D. 缓冲区\nD. 缓冲区使用的是队列结构 栈在表达式求值中的应用 将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-*-g+时, 用栈存放暂时还不能确定运算次序的操作符. 栈初始为空, 转换过程中同时保存在栈中的操作符的最大个数为( 5)\n扫到运算符的时候, 要输出优先级大于等于该运算符的所有运算符, 也就是说, 扫到'+'的时候要将所有的算符都输出, 包括'-'. 数组和特殊矩阵 适用于压缩存储稀疏矩阵的两种存储结构是( A)\nA. 三元组表和十字链表 B. 三元组表和邻接矩阵 C. 十字链表和二叉链表 D. 邻接矩阵和十字链表\n三元组表是指这样一种数据结构: 一个三元组表的结点存储 row, col, value 三个值的信息, 可以用来存储稀疏矩阵. 树 \u0026amp; 二叉树 二叉树 度为2的有序树就是二叉树(T/F)( F)\n对于度为2的有序树, 如果存在度为1的分支节点, 那么这个结点无法区分左右孩子, 所以不能够被算作是二叉树 ","permalink":"https://Muatyz.github.io/posts/cs/datastructure/wangdao/","summary":"绪论 已知两个长度为 $m$ 和 $n$ 的升序链表, 若将它们合并为长度为 $m + n$ 的一个降序链表, 则最坏情况下的时间复杂度为__. O(max(m,n)) 两个升序链表进行合并, 一个链表比完了, 另一个链表剩下的直接接上即可. 所以实际上的比较次数是 $m + n - 1 $ 次, 使用 max() 时就化简为答案的格式. 线性表 顺序表 顺序表上实现比在链表上","title":"数据结构反思总结"},{"content":"序言 本文记录学习的经典数据结构的实现, 由于原严蔚敏的书中使用的代码为C with \u0026amp;, 因此在真正的实现上是需要依赖于 cpp 的, 因此本文在具体的实现上为了能够\u0026quot;真正使用\u0026quot;有一些细节上的改动.\n在本文中的 ElemType 使用以下语句定义:\n#ifndef ElemType #define ElemType int #endif List Static Sequence List #define MaxSize 50 //数据类型为ElemType, 长度为 MaxSize 的静态线性表 typedef struct{ ElemType data[MaxSize]; int length;//表长 }SqList int main(){ } Dynamic Sequence List Definition #define InitSize 100 typedef struct{ ElemType *data; //表的地址 int MaxSize; //动态表的最大长度 int length; //当前动态表的长度 }SeqList; int main(){ SeqList L; L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); //动态分配 // free(L); return 0; } Operations //初始化动态表L bool InitList(SeqList \u0026amp;L){ L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); if(L.data == NULL){//分配内存失败 return false; } L.length = 0; return true; } //在静态顺序表L中的第 i 位插入元素 e bool ListInsert(SqList \u0026amp;L, int i, ElemType e){ if(i \u0026lt; 1 || i \u0026gt; L.length + 1){ //判断传入的参数 i 是否合法 return false; } if(L.length \u0026gt;= MaxSize){ //判断静态表是否已满 return false; } for(int j = L.length; j \u0026gt;= i; j--){ L.data[j] = L.data[j - 1]; //依次后移 } L.data[i - 1] = e; L.length++; return true; } //删除静态顺序表 L 中的第 i 位元素, 并且通过传入参数 e 保存删除的元素 bool ListDelete(SqList \u0026amp;L, int i, ElemType \u0026amp;e){ if(i \u0026lt; 1 || i \u0026gt; L.length){ //判断传入的参数 i 是否合法 return false; } for(int j = i; j \u0026lt; L.lrngth; j++){ L.data[j - 1] = L.data[j];//依次前移 } L.length--; return true; } //在静态顺序表 L 中查找第一个值为 e 的元素的[位置] bool LocateElem(SqList \u0026amp;L, int i, ElemType e){ int i; for(i = 0; i \u0026lt; L.length; i++){ if(L.data[i] == e){ return i + 1;//查找的是位置, 因此数组下标需要+1转换为编号 } } return 0;//查找失败 } Linked List Definition //单链表 typedef struct ListNode{ ElemType data; //数据域 struct ListNode *next; //下一结点地址 }ListNode, *LinkList; Operations //头插法建立单链表 L LinkList List_HeadInsert(LinkList \u0026amp;L){ ListNode *s; int x; L = (LinkList)malloc(sizeof(ListNode)); L -\u0026gt; next = NULL; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); while(x != 9999){ //输入9999即代表结束插入 s = (ListNode *)malloc(sizeof(ListNode)); s -\u0026gt; data = x; s -\u0026gt; next = L -\u0026gt; next; L -\u0026gt; next = s; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); } return L; } //尾插法建立单链表 L LinkList List_TailInsert(LinkList \u0026amp;L){ int x;//接收键盘输入的数值 L = (LinkList)malloc(sizeof(ListNode)); ListNode *new_node, *tail = L; //tail 为表尾指针 scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); while(x != 9999){ //输入9999即代表结束插入 new_node = (ListNode *)malloc(sizeof(ListNode)); new_node -\u0026gt; data = x; tail -\u0026gt; next = new_node; tail = new_node; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); } tail -\u0026gt; next = NULL; //将尾指针置空 return L; } //在单链表 L 中按照序号查找结点 ListNode *GetElem(LinkList L, int i){ if(i \u0026lt; 1){//检查传入的参数 i 是否合法 return NULL; } int j = 1; ListNode *ptr = L -\u0026gt; next; while(ptr != NULL \u0026amp;\u0026amp; j \u0026lt; i){ ptr = ptr -\u0026gt; next; j++; } return ptr; } //在单链表 L 中按照值查找结点 ListNode *LocateElem(LinkList L, ElemType e){ ListNode *ptr = L -\u0026gt; next; while(ptr != NULL \u0026amp;\u0026amp; ptr -\u0026gt; data != e){ ptr = ptr -\u0026gt; next; } return ptr; } Stack(template) template\u0026lt;typename T, int Size\u0026gt;//模板类, 传入参数栈元素的数据类型 T, 和栈的最大深度 Size class Stack{ private: T data[size]; int top; //当前栈中的栈顶元素的数组下标 public: Stack():top(-1){ //初始化函数 } ~Stack(){ //析构函数 } //向栈进入元素 item bool push(T item){ if(top == Size - 1){ //检测栈是否已满 return false; } data[++top] = item; return true; } //出栈栈顶元素, 并且使用 topElem 记录这个元素 bool pop(T \u0026amp;topElem){ if(top == -1){ //检验栈是否为空 return false; } topElem = data[top]; return true; } //判断栈是否为空 bool isEmpty(){ return top == -1; } //判断栈是否已满 bool isFull(){ return top == Size - 1; } } Queue(Template) template\u0026lt;typename T, int Size\u0026gt;//模板类, 传入参数队列元素的数据类型 T, 和队列的最大长度 Size class Queue{ private: T data[Size]; int front; //队头元素数组下标 int rear; //队尾元素数组下标 int tag; //辅助变量, 判断队列为空/满 public: Queue(): front(0), rear(0), tag(0){ //构造函数 } ~Queue(){ //析构函数 } //元素 item 入队 bool EnQueue(T, item){ if(front == rear \u0026amp;\u0026amp; tag == 1){ //判断队列是否已满 return false; } rear = (rear + 1) % Size; data[rear] = item; tag = 1; //进行入队操作后, 将tag = 1, 这样 rear == front时只有可能为满 return true; } //队列出队, 并且记录出队元素 item bool DeQueue(T \u0026amp;item){ if(front == rear \u0026amp;\u0026amp; tag == 0){ //判断队列是否为空 return false; } rear = (rear + 1) % Size; tag[rear] = item; tag = 0; //进行出队操作后, 将tag = 0, 这样 rear == front时只有可能为空 return true; } //判断队列是否为空 bool isEmpty(){ return front == rear \u0026amp;\u0026amp; tag == 0; } //判断队列是否为满 bool isFull(){ return front == rear \u0026amp;\u0026amp; tag == 1; } } String Definition Static String static const int MAXLEN = 255;//字符串的最大长度 //静态分配字符串 typedef struct{ char ch[MAXLEN];//数据域 int length; //字符串长度 }SString Dynamic String //动态分配字符串 typedef struct{ char *ch; //字符数组的地址 int length; //字符串长度 }HString; Linked List String //使用字符串结点存储字符串 typedef struct StringNode{ char ch[4]; //4个字符一组存放在一个结点中 struct StringNode *next; //下一个字符结点的地址 }StringNode, *String; Operations Static String //求静态字符串 S 中, 以 pos 为起点, 长为 len 的子串 sub. //在这里, 我们设定字符串的S[0]不存储任何元素, 而是从S[1]开始存储字符串的元素 bool SubString(SString \u0026amp;sub, SString S, int pos, int len){ if(pos + len - 1 \u0026gt; S.length){ //检测子串末尾是否已经溢出原串长度 return false; } for(int i = pos; i \u0026lt; pos + len; i++){ sub.ch[i - pos + 1] = S.ch[i]; } } //比较两个静态串的大小 //串的大小定义:(1)首先比长度(2)长度相等时, 比char对应的int. bool StrCompare(SString S, SString, T){ for(int i = 1; i \u0026lt;= S.length \u0026amp;\u0026amp; i \u0026lt;= T.length; i++){ if(S.ch[i] != T.ch[i]){ return S.ch[i] - T.ch[i]; } } //未能在以上循环中完成输出, 说明两个串呈现包含关系(即S 是 T的子串, 或者相反) //那么就应该使用长度来比较 return S.length - T.length; } //查询静态串的长度 int StrLength(SStrng S){ return S.length; } //使用朴素便利方法查询子串 T 首次出现在 S 中时的位置 int Index(SString S, SString T){ int i = 1, j = 1; while(i \u0026lt;= S.length \u0026amp;\u0026amp; j \u0026lt;= T.length){ if(S.ch[i] == T.ch[i]){ //匹配成功, i,j同步后移以进行下一位的比较 } else{ //匹配失败, 则 i 回到原先起点的下一位开始重新匹配 i = i - j + 2; j = 1; } } if(j \u0026gt; T.length){ return i - T.length; } else{ return 0; } } //使用KMP算法, 借助next[]数组查询子串 T 首次出现在 S 中时的位置 int Index_KMP(SString S, SString T, int next[]){ int i = 1, j = 1; while(i \u0026lt;= S.length \u0026amp;\u0026amp; j \u0026lt;= T.length){ if(j == 0 || S.ch[i] = = T.ch[j]){ i++; j++; } else{ j = next[j]; } } if(j \u0026gt; T.length){ return i - T.length; } else{ return 0; } } //根据next[]数组生成nextval[]数组, 从而优化KMP算法 int *next2nextval(SString T, int next[]){ int *nextval = (int *)malloc(T.length * sizeof(char)); nextval[1] = 0; for(int j = 2; j \u0026lt;= T.length; j++){ if(T.ch[next[j]] == T.ch[j]){ nextval[j] = nextval[next[j]]; } else{ nextval[j] = next[j]; } } return nextval; } Dynamic String //初始化动态字符串 bool InitHString(HString \u0026amp;S){ S.ch = (char *)malloc(MAXLEN * sizeof(char)); if(S.ch == NULL){ //内存分配失败 return false; } S.length = 0; return true; } Tree \u0026amp; Binary Tree Binary Tree Definition #define MAXSIZE 10 //二叉树结点 typedef struct BiTNode{ ElemType data; //数据域 struct BiTNode *lchild; //左子树根结点地址 struct BiTNode *rchild; //右子树根结点地址 }BiTNode, *BiTree; Operations //初始化二叉树root void InitBiTree(BiTree \u0026amp;root){ root = NULL;//通过置空来清洗之间root所在空间中地址 root = (BiTree)malloc(sizeof(BiTNode)); root -\u0026gt; data = 1; root -\u0026gt; lchild = NULL; root -\u0026gt; rchild = NULL; } //向二叉树root中插入值为 val 的结点 bool InsertBiTNode(BiTree \u0026amp;root, ElemType val){ BiTNode *new_node = (BiTNode *)malloc(sizeof(BiTNode)); if(new_node == NULL){ return false; } if(root -\u0026gt; lchild == NULL){ root -\u0026gt; lchild = new_node; new_node -\u0026gt; data = val; new_node -\u0026gt; lchild = NULL; new_node -\u0026gt; rchild = NULL; } else if(root -\u0026gt; rchild == NULL){ root -\u0026gt; rchild = new_node; new_node -\u0026gt; data = val; new_node -\u0026gt; lchild = NULL; new_node -\u0026gt; rchild = NULL; } else{ std::cout \u0026lt;\u0026lt; \u0026#34;Invalid root!\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } } //定义方位二叉树结点的行为 void observe(BiTree T){ std::cout \u0026lt;\u0026lt; T -\u0026gt; data \u0026lt;\u0026lt; std::endl; } //前根遍历二叉树 T //使用递归定义 void PreOrder(BiTree T){ if(T != NULL){ observe(T); PreOrder(T -\u0026gt; lchild); PreOrder(T -\u0026gt; rchild); } } //中根遍历二叉树 T //使用递归定义 void InOrder(BiTree T){ if(T != NULL){ InOrder(T -\u0026gt; lchild); observe(T); InOrder(T -\u0026gt; rchild); } } //后根遍历二叉树 T //使用递归定义 void PostOrder(BiTree T){ if(T != NULL){ PostOrder(T -\u0026gt; lchild); PostOrder(T -\u0026gt; rchild); observer(T); } } //层次遍历二叉树 T //借助队列模板类实现 void LevelOrder(BiTree T){ Queue\u0026lt;BiTree,20\u0026gt;queue; BiTree p = NULL; queue.Enqueue(T); while(!queue.isEmpty()){ queue.DeQueue(p); observe(p); if(p -\u0026gt; lchild != NULL){ queue.EnQueue(p -\u0026gt; lchild); } if(p -\u0026gt; rchild != NULL){ queue.EnQueue(p -\u0026gt; rchild); } } } Thread Tree Definition typedef struct ThreadNode{ ElemType data; //数据域 struct ThreadNode *lchild; //左子树的根结点地址 struct ThreadNode *rchild; //右子树的根结点地址 int ltag; //标记左子树根结点是否为线索, 1 为 是, 0 为 非 int rtag; //标记右子树根结点是否为线索, 1 为 是, 0 为 非 } Operation //使用全局变量 pre 来指定前驱结点 ThreadNode *pre = NULL; //访问行为 visit() void visit(ThreadNode *nodeptr){ //没有左孩子, 则空链域可以用来存储前驱结点地址 if(nodeptr -\u0026gt; lchild == NULL){ nodeptr -\u0026gt; lchild = pre; nodeptr -\u0026gt; ltag = 1; } //没有右孩子, 则空链域可以用来存储后继结点地址 if(pre != NULL \u0026amp;\u0026amp; pre -\u0026gt; rchild == NULL){ pre -\u0026gt; rchild = nodeptr; pre -\u0026gt; rtag = 1; } pre = nodeptr; } ","permalink":"https://Muatyz.github.io/posts/cs/datastructure/template-code/","summary":"序言 本文记录学习的经典数据结构的实现, 由于原严蔚敏的书中使用的代码为C with \u0026amp;, 因此在真正的实现上是需要依赖于 cpp 的, 因此本文在具体的实现上为了能够\u0026quot;真正使用\u0026quot;有一些细节上的改动. 在本文中的 ElemType 使用以下语句定义: #ifndef ElemType #define ElemType int #endif List Static Sequence List #define MaxSize 50 //数据类型为ElemType,","title":"数据结构经典代码"},{"content":"该站点用于记录每日所学新知\nInterest: Condensed Matter Physics, Numerical Calculation Profile: Undergraduate 本站已对 Twikoo 添加了 KaTex 支持.\n和ChatGPT聊聊天.该链接已经由 Cloudflare 进行加速, 可以自由访问.\n","permalink":"https://Muatyz.github.io/about/","summary":"该站点用于记录每日所学新知 Interest: Condensed Matter Physics, Numerical Calculation Profile: Undergraduate 本站已对 Twikoo 添加了 KaTex 支持. 和ChatGPT聊聊天.该链接已经由 Cloudflare 进行加速, 可以自由访问.","title":"🙋🏻‍♂️关于"},{"content":"本文记录对 東方 Project 全原作 STG 游戏的游玩记录.\n本文不提供任何游戏资源, 请支持正版.\n参考资料 THB Wiki 引言 東方紅魔郷　~ the Embodiment of Scarlet Devil ","permalink":"https://Muatyz.github.io/posts/life/toho-project/","summary":"本文记录对 東方 Project 全原作 STG 游戏的游玩记录. 本文不提供任何游戏资源, 请支持正版. 参考资料 THB Wiki 引言 東方紅魔郷 ~ the Embodiment of Scarlet Devil","title":"東方补全计划"},{"content":"背景 使用 Vercel 为 Hugo 添加 ChatGPT 支持的时候, 你需要在自己的 Github 仓库中添加大量的 Next.JS 依赖库, 而这些依赖库中很有可能会有着大小超过 100Mb 的文件, 使用 Visual Studio 进行提交就会被返回拒绝结果.\nremote: Resolving deltas: 100% (2535/2535), done. remote: error: Trace: 6d0ed0592a6b86e73e465451399567df9dd5b6d3664a9c9a2d14b61efb135a5d remote: error: See https://gh.io/lfs for more information. remote: error: File node_modules/@next/swc-win32-x64-msvc/next-swc.win32-x64-msvc.node is 117.24 MB; this exceeds GitHub\u0026#39;s file size limit of 100.00 MB remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. To https://github.com/Muatyz/chatgpt-api.git ! [remote rejected] master -\u0026gt; master (pre-receive hook declined) error: failed to push some refs to \u0026#39;https://github.com/Muatyz/chatgpt-api.git\u0026#39; “ChatGPT的回答” 这个错误的意思是你尝试推送到GitHub仓库的一个分支上，但其中一个文件的大小超出了GitHub的文件大小限制，该文件是 node_modules/@next/swc-win32-x64-msvc/next-swc.win32-x64-msvc.node，它的大小为117.24MB，而GitHub的限制是100MB。\n由于这个限制，GitHub拒绝了推送，并给出了建议使用Git Large File Storage（LFS）的错误消息。 Git LFS是一个Git扩展程序，用于存储大文件，它会在本地仓库中存储文件的指针，并在需要时下载它们。\n如果您想继续推送这个分支，您需要使用Git LFS来存储该文件。\n所以我们需要为 Github 仓库添加 LFS 支持.\nLFS安装 介绍 LFS(Large File Storage)将超出大小限制的文件存储在了单独的地址, 并且返回一个指针存储在原仓库中, 这样就可以在不超出大小限制的情况下提交代码了.\n方法 我的博客代码主要使用的 Windows 系统编辑的, 所以下面也将主要介绍有关于在 Windows 系统下的安装方法.\n到 Git LFS 官网 下载安装包, 并安装.\n在你的本地仓库的根目录下启用终端, 并且执行\ngit lfs install 以完成 LFS 的初始化.\n根据终端所警告的路径, 使用\ngit lfs track \u0026#34;path/to/file\u0026#34; 来跟踪你的文件, 例如:\ngit lfs track \u0026#34;node_modules/@next/swc-win32-x64-msvc/next-swc.win32-x64-msvc.node\u0026#34; 以跟踪 node_modules/@next/swc-win32-x64-msvc/next-swc.win32-x64-msvc.node 这个文件.\n*在仓库界面设置 LFS 支持.\n在网页端进入你的仓库, \u0026ldquo;Settings\u0026rdquo; -\u0026gt; \u0026ldquo;General\u0026rdquo; -\u0026gt; \u0026ldquo;Archives\u0026rdquo;, 为 \u0026ldquo;Include Git LFS objects in archives\u0026rdquo; 勾选上.\n完成本地仓库的提交并且推送到远程仓库:\ngit add . git commit -m \u0026#34;add LFS tracking for large file\u0026#34; git push origin master 这样就能够在 LFS 支持下成功推送所有的代码文件.\ncreate mode 100644 node_modules/zod/package.json create mode 100644 package-lock.json create mode 100644 package.json Uploading LFS objects: 100% (1/1), 123 MB | 0 B/s, done. Enumerating objects: 7113, done. Counting objects: 100% (7113/7113), done. Delta compression using up to 20 threads Compressing objects: 100% (6878/6878), done. Writing objects: 100% (7112/7112), 12.01 MiB | 4.39 MiB/s, done.Total 7112 (delta 2532), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (2532/2532), done. To https://github.com/Muatyz/chatgpt-api.git 6254ba2..154978d master -\u0026gt; master “注意” 当你在使用 LFS 对大文件进行标记时, 请先确保该文件从未被推送过(比如在我们的情境中, 是先被警告了文件超限然后再进行标记的, 这种情况下就是文件已经被推送过了), 所以我们需要先对原代码进行备份(该指令会对所有更改涉及的文件进行删除!), 然后使用\ngit fetch origin git reset --hard origin/master 来回退到改动前的文件夹.然后将备份的文件重新写入到该文件夹内, 再根据上面的步骤进行标记, 提交和推送. 这算不上是一种聪明的办法, 但是确实能够解决问题. 你也可以选择将大文件删除后再重新进行标记和提交.\n","permalink":"https://Muatyz.github.io/posts/cs/github-lfs/","summary":"背景 使用 Vercel 为 Hugo 添加 ChatGPT 支持的时候, 你需要在自己的 Github 仓库中添加大量的 Next.JS 依赖库, 而这些依赖库中很有可能会有着大小超过 100Mb 的文件, 使用 Visual Studio 进行提交就会被返回拒绝结果. remote: Resolving deltas: 100% (2535/2535), done. remote: error: Trace: 6d0ed0592a6b86e73e465451399567df9dd5b6d3664a9c9a2d14b61efb135a5d remote: error: See https://gh.io/lfs for more information. remote: error: File node_modules/@next/swc-win32-x64-msvc/next-swc.win32-x64-msvc.node is 117.24 MB; this exceeds GitHub\u0026#39;s file size limit of 100.00 MB remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. To https://github.com/Muatyz/chatgpt-api.git ! [remote rejected] master -\u0026gt; master (pre-receive hook declined) error:","title":"为Github添加LFS支持"},{"content":"指导老师: 张杰, 远晓辉\n助教: 李璟隆\n涉密内容警告 经过和助教的交流, 得知聚变涉及的内容比较敏感, 相关的代码必然不可能直接展示在本文中, 所以下面所有的代码均为 ChatGPT 给出的示例性代码以供思路上的参考. 研究背景 传统的中心点火方案存在两个问题:\n同时压缩和加热带来的不可控性; 加热效率较低. 所以设计了图示的有四个步骤组成的 DCI 方案, 即\n准等熵压缩 $\\rightarrow$ 提高密度; 混合加速 $\\rightarrow$ 提高动能; 对撞预加热 $\\rightarrow$ 提高密度和温度; 强磁场引导点火 $\\rightarrow$ 提高温度到点火温度; 其中我们研究的就是第三步.\n快电子加热前后, 等离子体会向外发射出光谱和各种粒子. 对这些光谱和粒子的性质进行研究, 有助于获取等离子体在快电子加热前后的参数.\n为了验证对撞后的等离子体的密度、快电子点火的加热是否达到预期效果，所以我们需要对等离子体参数进行诊断。在实际诊断中，可以观察中子产额、等离子体发射光谱等现象，来分析实验中的等离子体参数。等离子体光谱中包含软 $X$ 射线，硬 $X$ 射线等波段。而我们研究的就是软 $X$ 射线波段.\n研究问题 我们选择等离子体光谱中的软 $X$ 射线波段($17-40$nm)进行研究的原因:\n验证实验中采用了 CD 和 CHCl 材料，通过平场谱仪可以采集软 $X$ 射线波段的光谱曲线; 作为参考的碳平面靶实验为我们提供了 C 的软 $X$ 射线波段的各处谱线波长; 实际情况下，由于 Cl 原子在 $17-40$nm波段的谱线复杂，而 D 原子光谱远离该区域，所以我们选择 CD 材料的光谱数据加以研究。 所以我们最后选定的研究问题为:\n如何研究 DCI 中快电子加热前后的等离子体所发射光谱中的软 $X$ 射线波段以判断其参数(温度，密度)?\n研究方法 数据处理 坏点矫正(DPC) 在 CCD 录制下的光谱数据中存在着坏点, 在进行分析前需要先将其修复.\n人工修复\n由人眼搜索坏点的具体位置, 并且使用 ImageJ 来查找其具体的坐标. 然后使用其邻域的数据来填充坏点.\n因为不同发次的 CCD 拍摄角度, 拍摄距离等参数大致相同, 因此这些坏点坐标可以重复使用.\n坏点修复算法 这里使用的算法是常见的利用插值来修复坏点的算法. 在我们所涉及的坏点类型中, 使用线性插值即可.\nimport numpy as np def interpolate(data, dp_slope=0.5, dp_thresh=3, stencil_radius=2): for i in range(len(data)): if np.isnan(data[i]): j = i - 1 while np.isnan(data[j]): j -= 1 k = i + 1 while np.isnan(data[k]): k += 1 if (k - j) \u0026gt; stencil_radius: data[i] = np.nan else: slope = (data[k] - data[j]) / (k - j) if abs(slope) \u0026gt; dp_slope or abs(data[k] - data[j]) \u0026gt; dp_thresh: data[i] = np.nan else: data[i] = data[j] + slope * (i - j) return data # 示例数据 data = np.array([1, 2, np.nan, 4, np.nan, 6, 7, np.nan, 9]) print(\u0026#34;原始数据: \u0026#34;, data) # 调整参数并修复坏点 data = interpolate(data, dp_slope=0.3, dp_thresh=2, stencil_radius=3) print(\u0026#34;修复后的数据: \u0026#34;, data) dp_slope: 斜率阈值。当两个相邻的数据点之间的斜率超过这个阈值时，该区域被认为是不连续的，坏点将被插值而不是被修复。\ndp_thresh: 阈值。当两个相邻的数据点之间的差异超过这个阈值时，该区域被认为是不连续的，坏点将被插值而不是被修复。\nstencil radius: 模板半径。用于计算插值值的相邻数据点的数量。模板半径越大，计算出的插值值越平滑，但计算开销也会增加。\n使用算法来进行坏点修复速度很快, 但是在矫正坏点的同时容易对曲线进行高斯模糊, 从而损失部分细节信息. 要在修复坏点的同时尽可能少引入高斯模糊效果, 需要对上述参数进行更细致的调整.\n高斯模糊/高斯平滑 Gaussian Blur/Smoothing 从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作“高斯分布”，所以这项技术就叫作高斯模糊。图像与圆形方框模糊做卷积将会生成更加精确的焦外成像效果。由于高斯函数的傅立叶变换是另外一个高斯函数，所以高斯模糊对于图像来说就是一个低通滤波器 波长标定 在处理数据时, 需要建立起 CCD 像素坐标和波长之间的关系.\nAl 片的吸收边: $\\lambda_{Al} = 17.1$ nm CCD 比例尺: k = $13.5\\text{mm}/1\\text{ Pixel}$ 超环面平常光栅. 根据以上内容可以列出等式:\n$$ \\lambda = d_{0}(\\sin{\\alpha}-\\sin{\\arctan{\\frac{LH}{x}}})\\\\ \\lambda_{Al} = d_{0}(\\sin{\\alpha}-\\sin{\\arctan{\\frac{LH}{x_{Al}}}})\\\\ x - x_{Al} = (Pixel_{x} - Pixel_{Al})\\cdot k $$\nAl 铝片具有通过吸收来对波长谱进行截断的作用, 这一点将在后面去除响应效率的部分有所展示. 所以我们可以利用图像上的吸收边作为标定像素, 从而找到参考点.\n对上式进行联立化简, 即有\n$$ \\color{blue}{\\lambda} = d_{0}\\left\\{\\sin{\\alpha}-\\sin{\\arctan{\\left[\\frac{1}{\\cot{\\arcsin{\\left(\\sin{\\alpha}-\\frac{\\lambda_{Al}}{d_{0}}\\right)}}+\\left(\\color{red}{Pixel_{x}}-Pixel_{Al}\\right)\\cdot\\frac{k}{LH}}\\right]}}\\right\\} $$\n变栅距光栅具有固定的工作参数, 即 $\\alpha, d_{0}, LH$\n对应的工作示意图为\n去除响应效率 CCD 拍摄得到的图像并不是真正的曲线, 因为光路上的各种元件不同程度地引入了响应曲线, 比如反射率\\ Al 铝片吸收率\\光栅反射率\\CCD 响应效率函数. 所以如果要分析原始图像, 我们就需要对其进行去除.\n我们测量这些曲线并且写作矩阵, 通过插值对其进行扩展. 随后使用矩阵点除依次去除曲线.\n注意: 不同发次所使用的 Al 铝片的厚度不同, 因此对应的吸收曲线效果大不相同. 所以在具体的实验分析中需要对两者进行鉴别.\n下图即为厚为 $1.5\\mu$ m的 Al 铝片对软 $X$ 射线波段的吸收率曲线(原始数据, 未插值):\n由此可以观察到明显的吸收边现象, 这也是前面所说的使用 Al 铝片帮助确定坐标的原因.\n确定冕区和对撞区的 $Y$ 轴坐标 参考前面我们给出的实验室下的装置可知, 因为冕区和对撞区的温度不同, 因此对应的具体物理机制也会不同, 在 CCD 记录下的二维图像中需要数据切取, 而这个操作就需要确定具体的 $Y$ 轴坐标.\n我们可以借助读取 Matlab 的工作区数据, 或者直接用 ImageJ 来选取代表性的坐标.\n冕区: 选取连续多个 $Y$ 轴坐标和对应的采样半径, 分别进行数据平均, 挑选其中效果最好的一组; 对撞区: 确保采样区域在对撞区域图像的中心即可. 下面是示例性的取平均之后的数据曲线:\n低通滤波函数处理(Low Pass Filter) 由于得到的曲线中存在高斯噪声等干扰信号, 所以在进行正式分析前需要对其进行低通滤波处理.\nimport numpy as np from scipy.signal import butter, filtfilt def butter_lowpass(cutoff, fs, order=5): nyq = 0.5 * fs normal_cutoff = cutoff / nyq b, a = butter(order, normal_cutoff, btype=\u0026#39;low\u0026#39;, analog=False) return b, a def lowpass_filter(data, cutoff, fs, order=5): b, a = butter_lowpass(cutoff, fs, order=order) y = filtfilt(b, a, data) return y # 生成示例数据 t = np.linspace(0, 1, 1000) data = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t) + np.random.randn(len(t))*0.1 # 设置滤波器参数 cutoff = 15 # 截止频率 fs = 1000 # 采样率 order = 6 # 滤波器阶数 # 应用低通滤波器 filtered_data = lowpass_filter(data, cutoff, fs, order=order) 上述代码仅为示例, 实际工作中的处理是使用 Matlab 处理完成的.\n和矫正坏点类似, 这样的算法处理会引入高斯模糊, 从而损失部分的细节信息, 所以在去除干扰和避免信息损失之间需要做好权衡.\n输出光谱横坐标 因为在上述的操作过程中, $Pixel_{Al}$ 实际上是手动选中的, 所以可能会引入 $\\lambda$ 标定的误差.\n然而我们除了正式的对撞模拟实验之外, 还有碳平面参考靶产生的实验数据, 我们可以对两者的峰进行对比确认.\n光谱机制 发光机制按照其曲线形状可以分为连续谱和线谱.\n连续谱 连续谱中的发光机制主要有轫致辐射和复合辐射.\n轫致辐射 电子在离子的库仑力作用下做非匀速运动, 电子在这个过程中丢失动能, 从而发出电磁辐射. $$ \\color{red}{W_{B}}\\propto\\frac{Z^{2}e^{6}}{mc^{2}}\\frac{n_{e}n_{i}}{h}\\left(\\frac{2k_{B}T_{e}}{\\pi m}\\right) $$\n$\\color{red}{W_{B}}$: 布洛赫辐射的辐射能量密度; $Z$: 等离子体中的离子电荷数; $e$: 元电荷; $m$: 电子质量; $c$: 光速; $n_{e}$: 等离子体中的电子密度; $n_{i}$: 等离子体中的离子密度; $h$: 普朗克常数; $k_{B}$: 玻尔兹曼常数; $T_{e}$: 等离子体中的电子温度;\n复合辐射 自由态电子和离子的价态空穴进行结合, 电子回到某个能级上从而发出辐射: $$ \\color{lightblue}{W_{r}}\\approx 2.4\\frac{Z^2E_{H}}{k_{B}T_{e}}\\color{red}{W_{B}} $$\n$\\color{lightblue}{W_{r}}$; 布洛赫辐射的总辐射能量密度; $Z$: 等离子体中的离子电荷数; $E_{H}$: 氢原子的电离能; $k_{B}$: 玻尔兹曼常数; $T_{e}$: 等离子体中的电子温度; $\\color{red}{W_{B}}$: 布洛赫辐射的辐射能量密度;\n从所列出的公式可以看出, 轫致辐射对应的功率与 $Z^{2}$ 成正比, 所以我们猜测 CD 材料能引起的轫致辐射功率是相对小的; 而在低 $Z$ 数下, 复合辐射相对于轫致辐射还要更小(观察系数), 所以我们作出这样的推测: 连续谱可能在实际的谱线中并不占主导地位.\n所以要对光谱进行分析, 还要再看线状谱.\n线状谱 我们已经在研究问题部分介绍到, 软 $X$ 射线波段的量级大约为 $0.1$~$10$nm, 所以当处理 CD 作为靶材料的数据时, 应当重点关注 C 的谱线, 也就是 $17$~$40$nm.\n但是在真实的实验条件下, 线谱必定会因为各种原因出现展宽(即线谱的半高全宽), 对其出现原因的研究也很有意义.\n自然展宽\n由不确定性原理造成的展宽: $$ \\Delta E\\cdot\\Delta t\\geq h $$\n多普勒展宽\n粒子热运动造成原子与仪器之间的相对运动, 从而影响到所接收的频率, 而热运动的速率分布遵从麦克斯韦统计: $$ G(x,\\sigma) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^{2}}{2\\sigma^{2}}} $$\nStark 展宽\n一种压力展宽, 辐射粒子受到周围带电粒子的含时微场的影响从而产生展宽, 这会使得激发态电子的寿命变短.\n同时, 由于能级分裂, 也会产生谱线的偏移: $$ L(x,\\gamma)=\\frac{\\gamma}{\\pi(x^{2}+\\gamma^{2})} $$\n在真实的实验条件下, 谱线的实际形状是由以上几种效应的卷积, 也就是高斯线型和洛伦兹线型的卷积(Voigt 线型)\n数据分析 以 CD 发次的对撞实验进行分析. 观察可知, 在 C 的几个经典的离化态对应的波长处均有小峰, 这和纯碳平面参考靶给出的实验数据是吻合的. 一共是 $18.2, 22.7, 24.9, 26.7, 28.9, 31.2$ 六条谱线最为直观.\n每条谱线的展宽主要受到多普勒效应\n$$ \\Delta\\nu_{1/2} = 2\\sqrt{\\frac{(2\\ln{2})k_{B}T}{mc^{2}}}\\nu_{0}\\\\ \\Rightarrow \\Delta\\lambda_{1/2}=2\\sqrt{\\frac{(2\\ln{2})k_{B}T}{mc^{2}}}\\lambda_{0} $$\n和 Stark 效应\n$$ \\Delta\\lambda_{1/2}=2.5\\times 10^{-13}\\alpha_{1/2}N_{e}^{2/3} $$ 的影响.\n代入一些典型参数后, 验算得知多普勒展宽约为 $10^{-3}$nm, 而 Stark 展宽大致为 $0.1$~$1$nm, 多普勒线型和 Stark 效应的洛伦兹线型做卷积后的半高全宽中 Stark 效应将会占主导地位, 这和实际曲线中的情况是相符的.\n而另一方面, CD 加热前后发次的谱线展宽实际上相差不大, 这是因为 Stark 下效应本身受电子数密度的影响更大, 而快电子加热过程中对于密度的影响较小, 这和实验结果相符合.\n根据 Stark 效应半高全宽的经验公式, 大致估算其电子数密度量级约为 $10^{24}/\\text{cm}^{3}$, 等离子体密度量级约为 $10\\text{g}/\\text{cm}^{3}$.\n除了上述分析外还存在一些问题.\nStark 效应带来的除了谱线的展宽, 应该还会有中心波长的偏移, 其中有些实验数据是符合的, 但是有些数据则会存在差别; 某些发次的实验中在并不存在碳的离化态所对应的谱线位置出现了尖峰. 以上产生的与理论预测之间的矛盾可能是\n数据处理过程中波长的标定; 滤波函数的选择; 坏点的去除程度; 单次实验本身的误差 等因素导致的.\n数值模拟 很遗憾的是在实践期间, 由于各种因素数值模拟的工作进行得并不成功, 但是由此学习到的科研工具的确有必要记录下来. 该部分因为内容问题未被展示在期末答辩的内容上.\nFLYCHK FLYCHK 是由 NIST 开发的半公开等离子体光谱数据库, 输入原子序数, 温度, 密度等初始信息可以获取该条件下的发射光谱.\n使用时需要向维护者 Dr.Yuri Ralchenko 发送申请邮件以获取访问 ID 和密码.\n申请信件格式 名字 附属的机构 地址和工作用的电话号 电子邮箱 研究目的简要介绍 严格按照格式并且用英文书写, 有助于尽快获取 ID 和密码以进行对应工作. FLYCHK 只会保存最近14天的运行结果, 所以确保将运行数据导出并妥善保存.\n有时候访问 FLYCHK 可能会出现 404 错误, 这是网站管理人员对其进行维护导致的, 维护时间可能长达数月, 所以要做好心理准备.\n因为我们的目的是要验证理论模型是否正确, 所以通过 FLYCHK 模拟计算等离子体的光谱发射\\离化态分布是可行的.\nPrismSPECT PrismSPECT 是由棱镜计算科学公司开发的用于计算等离子体辐射光谱的商业软件, 通常用于模拟实验室和天体物理的物质辐射性质.\n这套软件对于个人而言价格昂贵, 一般都是由实验组购买并且分发密钥进行使用. 所以在这里不进行过多介绍.\n总结与展望 总结 成功将数据处理得到了可供分析的实际的光谱曲线; 理解光谱发射机制，并且能以此为根据，对实验发次的部分参数进行数量级上的预测; 掌握 FLYCHK 等数据库与软件的使用方法，从而通过调整参数逼近实验曲线，给出实验曲线的等离子体参数. 展望 目前处理的数据主要集中在 CD 上，可以对同样作为实验燃料的 CHCl 展开光谱研究，从而得出更广度的结论； 目前的研究手段主要集中在对碳的线谱上，可以学习更多的机制从而对连续谱方面进行半定量研究； 数据分析目前局限在单次的调参和模拟，在未来可以设法批量生成光谱曲线从而建设供机器学习的数据库。 参考文献 [1]刘运全,张杰,陈正林,彭晓昱.软 $X$ 射线平场光谱仪系统的优化设计[J].物理学报,2004(05):1433-1439.\n[2]李璟隆.对激光聚变物理过程的软 $X$ 射线诊断研究[D].上海:华东师范大学物理与电子科学学院,2021(5).\n[3] Giulietti D, Gizzi L A. $X$-ray emission from laser-produced plasmas[J]. La Rivista del Nuovo Cimento (1978-1999), 1998, 21(10): 1-93.\n[4]Wu, F., Yang, X., Ma, Y., Zhang, Q., Zhang, Z., Yuan, X., . . . Zhang, J. (2022). Machine-learning guided optimization of laser pulses for direct-drive implosions. High Power Laser Science and Engineering, 10, E12. doi:10.1017/hpl.2022.4\n[5]倪元龙,毛楚生,吴江,余松玉,周正良,傅思祖,顾援,王世绩.平焦场光栅光谱仪[J].强激光与粒子束,1991(02):242-248.\n[6] Giulietti D, Gizzi L A. $X$-ray emission from laser-produced plasmas[J]. La Rivista del Nuovo Cimento (1978-1999), 1998, 21(10): 1-93.\n[7] De Giacomo A, Hermann J. Laser-induced plasma emission: from atomic to molecular spectra[J]. Journal of Physics D: Applied Physics, 2017, 50(18): 183002.\n[8] Spencer J B, Alman D A, Ruzic D N, et al. Dynamics of a laser produced plasma for soft x-ray production[C]//Emerging Lithographic Technologies IX. SPIE, 2005, 5751: 798-807.\n[9]H.R. Griem. Plasma spectroscopy [M]. New York: McGraw-Hill, 1964\n[10]鲁建. 稠密等离子体诊断用 $X$ 射线均匀色散弯晶谱仪研究[D]. 重庆: 重庆大学, 2015.\n课程感想 这真的是我该呆的地方吗?? ","permalink":"https://Muatyz.github.io/posts/exp/dci-soft-x-ray/","summary":"指导老师: 张杰, 远晓辉 助教: 李璟隆 涉密内容警告 经过和助教的交流, 得知聚变涉及的内容比较敏感, 相关的代码必然不可能直接展示在本文中, 所以下面所有的代码均为 ChatGPT 给出的示例性代码以供思路上的参考. 研究背景 传统的中心点火方案存在两个问题: 同时压缩和加热带来的不可控性; 加热效率较低. 所以设计","title":"[课设]DCI方案中快电子加热的软X射线诊断研究"},{"content":"实验目的 了解量子纠缠态的概念、性质及其在量子信息领域的应用, 进而深刻理解量子力学的本质与精髓; 学习光子纠缠源的制备原理, 学习相关的非线性光学的知识, 如自发参量放大与振荡、相位匹配、自发参量下转换等; 学习量子光学实验中涉及的基本实验仪器的原理和使用方法。如光纤传输和耦合的理论与技术, 单光子计数器, 符合门, 半波片, 极化片等实验装置的使用方法。让学生熟练掌握光学实验的光路调节和各种光学元件的调整技术。 学习对光子纠缠源产生的光子纠缠对比度的符合测量方法, 并通过测量验算Bell 不等式 实验原理 量子纠缠态 在任何量子力学表象中, 都无法表示为组成它的各子系统量子态矢的直积形式.\n这些子系统之间表现出相互纠缠的不可分特性, 即使它们空间分离, 对一个子系统的观察也必然影响另一个子系统的测量结果\n4个Bell态(纠缠都最高的态)\n$$ |\\Psi_{1,2}\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle |1\\rangle \\pm |1\\rangle |0\\rangle)\\\\ |\\Psi_{3,4}\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle |0\\rangle \\pm |1\\rangle |1\\rangle) $$\n量子不可克隆原理\n由于量子力学的态叠加原理, 量子系统的任意未知量子态, 不可能在不遭受破坏的前提下, 以 100％ 成功的概率被克隆到另一个量子体系上。正是由于量子纠缠态的这种非定域的关联性和不可克隆性, 使得量子通讯有更多的优越性. 量子信息处理允许信息、即量子态的相干叠加, 当我们用量子态来加载信息时, 量子通信系统可以在如下几个方面超越经典通信系统：绝对安全性、高效率和高通道容量。\n双光子偏振纠缠态的制备方法与发展历程 利用非线性晶体中的自发参量下转换 (SPDC——spontaneous parametric down-conversion) 过程实现双光子纠缠的产生和操纵，探测简便，纠缠纯度高，相干性保持距离长，所以应用也最为广泛。\n可用于作为纠缠源检验 Bell 不等式, 从而证明量子力学非局域性的存在。\nEPR 佯谬和 Bell 不等式 量子力学完备性的前提:\n任何两个互不接触且不能直接作用的系统, 对其中任意一个系统的测量, 量子力学的预言都必须是正确的; 若对一个系统没有干扰, 那么如果能确定地预测一个物理量地值, 那么对于这一物理量必然存在一个对应的物理实在元素; 不存在超距作用, 即对其中一个系统做的任何物理操作, 都不应该对另一个系统有任何影响. 基于定域实在论和隐变量存在提出的二粒子自旋纠缠态关联函数的不等式:\n$$ |P(\\vec{a},\\vec{b})-P(\\vec{a},\\vec{c})|\\leq 1+P(\\vec{b},\\vec{c}) $$\n$$ P(\\vec{a}, \\vec{b}) = \\int \\rho(\\lambda)A(\\vec{a}, \\lambda)B(\\vec{b}, \\lambda)d\\lambda $$\n而对于量子力学, 该关系将会不成立.\nCHSH 不等式是一种容易在实验上进行检验的 Bell 不等式:\n$$ S = |E(\\phi_{A}\\phi_{B})-E(\\phi_{A}\\phi_{B}\u0026rsquo;)+E(\\phi_{A}\u0026rsquo;\\phi_{B})+E(\\phi_{A}\u0026rsquo;\\phi_{B}\u0026rsquo;)| \u0026lt; 2 $$\n$$ E(\\phi_{A}, \\phi_{B}) = \\frac{N_{\\phi_{A}\\phi_{A}} + N_{\\phi_{B}\\phi_{B}} - N_{\\phi_{A}\\phi_{B}} -N_{\\phi_{B}\\phi_{A}}}{N_{\\phi_{A}\\phi_{A}} + N_{\\phi_{B}\\phi_{B}} + N_{\\phi_{A}\\phi_{B}} + N_{\\phi_{B}\\phi_{A}}} $$\n$N_{\\phi_{A}\\phi_{B}}$ 为 AB 两路极化片分别为 $\\phi_{A}$ 和 $\\phi_{B}$ 时的符合计数.\n非线性光学 线性光学: $$ P = \\epsilon_{0}\\chi_{0}E $$\n非线性光学: $$ P = \\epsilon_{0}\\left[\\chi^{(1)}E + \\chi^{(2)}E^{2} + \\chi^{(3)}E^{3} + \\cdots + \\chi^{(n)}E^{n} + \\cdots\\right] $$\n$\\chi^{(i)}$ 被称为 $i$ 阶极化率.\n光学参量放大和振荡 设 $\\omega_{p}$ 的强光波(泵浦光)入射到介质, 同时如何 $\\omega_{s}(\\omega_{s} \u0026lt; \\omega_{p})$ 的弱光波(信号光), 便可能产生 $\\omega_{i} = \\omega_{p} - \\omega_{s}$ 的\u0026quot;空闲光\u0026quot;.\n泵浦光又可以和空闲光茶品得到信号光频率 $\\omega_{s} = \\omega_{p} - \\omega_{i}$ 的光, 使得信号光放大, 这就是光学参量放大效应.\n当泵浦光足够强时, 参数放大会转换为参量振荡. 此时即使没有信号光入射, 也可以产生一对输出光, 其频率之和等于泵浦光频率.\nManley-Rowe 关系式:\n$$ \\frac{d}{dz}(I_{1} + I_{2} + I_{3})\\\\ \\Rightarrow I_{1} + I_{2} + I_{3} = 0 $$\n三个光波的总能量是不变的, 也就是说能量只在光波之间交换, 介质并不参与, 只起到媒介作用.\n自发参量转换(SPDC, 相位匹配) SPDC 的产生类似于上述参量混频过程, 但是区别在于只有一束泵浦光作用在非线性晶体上. 量子真空噪声和原子相互作用产生自发辐射, 自发辐射产生的光子与泵浦光在非线性晶体中进行混频.\n也就是说, SPDC 光场是自发辐射的参量放大过程. 而且, 这个过程产生的双光子具有量子相关性, 具有频率, 时间, 偏振和自旋纠缠特性和全同时间涨落.\nSPDC 光场的空间分布取决于非线性晶体折射率的色散特性和泵浦光场电场波矢与晶体光轴之间的夹角 $\\theta$.\n相位匹配 光波之间要满足的守恒定律:\n$$ \\begin{aligned} \\text{能量守恒}: \\omega_{p} = \\omega_{s} + \\omega_{i} \\\\ \\text{动量守恒}: \\vec{k_{p}} = \\vec{k_{s}} + \\vec{k_{i}} \\end{aligned} $$ 只有入射光束在介质中的配置满足动量守恒, 参量过程才会实现. 这个条件也被称为相位匹配条件.\n$I$ 型和 $II$ 型自发参量下转换 根据晶体相位匹配的类型可以将参量下转换分为两种类型:\n$I$ 型: $$ e \\rightarrow o + o $$\n即产生的双光子偏振相同且均垂直于泵浦光的偏振方向;\n$II$ 型: $$ o \\rightarrow e + o $$\n即产生的双光子对的偏振方向互相垂直.\n准相位匹配 传统量子纠缠光源的缺点\n传统光源一般基于 BBO 晶体, 由于在 BBO 晶体中存在走离效应, 补偿的不完美会影响到纠缠品质;而 BBO 晶体本身的非线性系数限制使得在增加泵浦功率从而获得更高亮度的光源时, 更高阶的光子项也将不能再忽视.\n下转换光强所满足的表达式:\n$$ I\\propto e^{-\\Delta kd}d^{2}\\sin{c^{2}\\frac{\\Delta kd}{2}} $$\n$\\Delta k$ 为相位失配量, $d$ 为晶体长度.\n相位匹配 $\\Delta k = 0$ 非常难以实现, 所以通常的失配状态下光强将会呈现出周期性振荡的现象.\n所以如果能够周期性地反转晶体的极化矢量方向, 那么每个周期内的光强增长都会累积起来, 从而使得晶体的非线性系数大大增强.\n相位匹配条件就变为了 $$ \\Delta k = k_{p} - k_{i} - k_{s} - \\frac{2\\pi}{\\Lambda} = 0 $$\n$\\Lambda$ 为极化周期, $2\\pi/\\Lambda$ 相当于增加了一个光栅波矢.\n实验室中所用的周期极化晶体为磷酸氧钛钾(PPKTP).\n实验装置 $405$ nm 激光先被耦合仅单模光纤中的好处:\n半导体激光器的光斑模式通常为椭圆, 用单模光纤做空间滤波可以使泵浦光的空间模式为 Gaussian 基模; 如果激光器指向性有问题, 也只需要将前部的耦合重新恢复, 不会影响到后面已经调好的光路, 提高了系统的便携性和稳定性. 光束使用耦合器自带的微透镜完成了会聚过程, 节约空间. $\\frac{1}{4}$ 波片(QWP), $\\frac{1}{2}$ 波片(HWP)和偏振分束器使得泵浦光是水平偏振的线偏光;\n第二轮 $\\frac{1}{4}$ 波片(QWP), $\\frac{1}{2}$ 波片(HWP) 用于调节泵浦光相位从而制备最大纠缠态.\n双色镜(DM)用于分离泵浦光和下转换光.\n泵浦光经过双色镜透射后进入双色偏振分束器(DPBS), 水平偏振光和垂直偏振光被其分开, 分别沿着顺时针和逆时针在 Sagnac 环内行进, 绕行一周后离开 Sagnac 环.\n逆时针绕环. 两个光量子为 $|H\\rangle_{i}, |V\\rangle_{s}$, 半波片放置在 45° 实现极化反转, 系统的量子态变为 $|H\\rangle_{s}, |V\\rangle_{i}$. DPBS 的出口处, 一段接受透射的 $|H\\rangle_{s}$ 光子, 另一端接受到反射的 $|V\\rangle_{i}$ 光子. 顺时针绕环. 泵浦光 $|V\\rangle_{p}$ 先被半波片(HWP)转化为 $|H\\rangle_{p}$, 能够发生相位匹配从而下转换产生 $|H\\rangle_{i}$ 和 $|V\\rangle_{s}$. DPBS的出口处, 一端接收到透射的 $|H\\rangle_{s}$ 光子, 另一端接收到反射的 $|V\\rangle_{s}$ 光子. 由于是双向泵浦, 所以环内的相位是自稳的, 即使有微小差异也是有被动器件引起的, 容易通过改变泵浦光来补偿. 最终系统的量子态处于这样的纠缠态:\n$$ |\\varphi\\rangle = \\frac{1}{\\sqrt{2}}(|H\\rangle_{A}|V\\rangle_{B} + |H\\rangle_{B}|V\\rangle_{A}) $$\n单模光纤使用 $f = 300$ mm 的透镜进行模式匹配, 每个单模光纤前面都插入了极化片用于进行符合测量.\n最后纠缠光子通过长通滤波片由光纤耦合器收集, 被送到 InGaAs 雪崩二极管单光子探测器上转变为电信号.\n波片, 分束器, 偏振分束器 波片 在波片表面平行的平面内存在两个特殊方向, 当光子的电矢量振动方向平行于这两个方向(快轴方向和满洲方向)时, 出射光的偏振不会发生改变. 而一般性的偏振光子入射到波片上时, 其偏振会按照这两个昂想进行分解.一束平行光正入射时, 由于波片对 o 光和 e 光的折射率 $n_{o}, n_{e}$ 不同, 所以经过厚为 $d$ 的波片后, 两个光会出现一个相位差\n$$ \\varphi = \\frac{2\\pi}{\\lambda}(n_{e}-n_{o})d $$\n所以对于半波片/$\\frac{1}{2}$波片, 就有 $$ (n_{e}-n_{o})d = \\pm\\frac{\\lambda}{2}\\Rightarrow\\varphi = (2m+1)\\pi, $$\n同理, 有$\\frac{1}{4}$ 波片\n$$ \\varphi = (2m+1)\\frac{\\pi}{2} $$\n当波片光轴与水平方向称 $\\theta$ 时, 我们用琼斯矩阵来描述两个波片:\n$$ U_{HWP} = \\begin{bmatrix} \\cos{2\\theta} \u0026amp; \\sin{2\\theta} \\\\ \\sin{2\\theta} \u0026amp; -\\cos{2\\theta} \\\\ \\end{bmatrix}\\\\ U_{QWP} = \\begin{bmatrix} \\cos^{2}{\\theta} + i\\sin^{2}{\\theta} \u0026amp; (1 - i)\\cos{\\theta}\\sin{\\theta} \\\\ (1 - i)\\cos{\\theta}\\sin{\\theta} \u0026amp; \\sin^{2}{\\theta} + i \\cos^{2}{\\theta} \\\\ \\end{bmatrix} $$\n分束器, 偏振分束器 分束器: 通过镀膜使得某个波段的光子按照一定的几率发生透射或者反射; 偏振分束器: 基于双折射原理, 按照光子的偏振决定透射还是反射. $$ |a\\rangle = \\frac{i}{\\sqrt{2}}|c\\rangle + \\frac{1}{\\sqrt{2}}|d\\rangle\\\\ |b\\rangle = \\frac{1}{\\sqrt{2}}|c\\rangle + \\frac{i}{\\sqrt{2}}|d\\rangle $$\n这表明, 无论从哪一路输入, 最后都可以在两个输出口以 $50%$ 的概率得到光子. 其中的 $i$ 表示的因为反射产生的相位.\n而偏振分束器则是对光子的偏振投影测量, 在理想状态下透射的是水平偏振的光子, 反射的是水平偏振的光子.\n单模光纤 只允许一种模式在光纤中存在, 被称之为单模光纤. 这是因为内芯尺寸较小(5$\\mu$m).\n如果在单模光纤中引入不对称因素使得偏振模式不简并, 就被称为保偏光纤.\n多模光纤因为允许多个模式存在, 不同模式有不同的传输速度, 容易使量子比特发生退相干.\n单模光纤的作用:\n对偏振的影响.\n光线本身的不对称, 弯曲引起的应力, 环境条件的不一致, 都会使得单模光纤中产生双折射, 这种双折射随机且含时, 所以会改变其中的光子偏振态. 这种改变在退相干效应发生前都是可以通过步长来消除的幺正变换.\n退相干效应. 当光纤的长度很长的时候, 偏振模色散效应和色度色散都会使得两个偏振态由相干叠加变为混态.\n偏振模色散:光纤中两个偏振方向的传输速度不同引起的. 这是因为光纤的折射率随机变化, 这也导致偏振模色散效应本质上是随机的. 当偏振模色散导致两个偏振方向的时间间隔大于播报的相干长度时, 退相干效应就会发生.\n色度色散是因为波包不可能严格单色, 所以带宽内不同频率的成分由于群速度不同而使得波包变宽.\n单光子计数技术 单光子计数要求能对极微弱光进行探测, 而硅雪崩光电二极管(APD)因为在近红外波段量子效率高, 增益大, 也你能覆盖可见区所以被采用为实验的探测器.\n使用单光子计数技术可以将被淹没在背景噪声中的弱光信号提取出来.\n在实验中的 APD 工作电压高于雪崩电压, 这异于一般情况, 被称为盖革模式.\n盖革模式\n工作电压大于半导体二极管的雪崩电压.\n该模式下噪声会很大, 需要降低工作温度.\n在 APD 上施加负偏置电压, 大部分时间处于就绪阶段. 当接收到一个光子, 两端电压就会在 fs 级别时间内降到比雪崩电压低一些, 通过输出电阻产生一个脉冲信号. 当流经 APD 的电流小于其熄灭阈值时, 雪崩就会停止, 恢复到就绪状态. 恢复时间越充分, 信号高度就会越大.\n发生雪崩后的有一段时间无法接受光子, 被称为\u0026quot;死时间\u0026quot;. 死时间越小, 光子探测效率越高. 所以需要尽快抑制光子产生信号后的雪崩.\n无源抑制. 在计数率要求不高的情况下使用; 有源抑制. 在量子通信计数率高的实验中采用. 单光子有两个评测指标. 这两个指标直接影响到密钥生成效率和量子信道安全性的评估.\n量子效率 根据材料和波长不同, 量子效率也会发生不同.\n噪声等效功率(NEP) 和量子效率 $\\eta$ 和暗计数水平有关.\n$$ \\text{NEP} = \\frac{h \\nu}{\\eta}\\sqrt{2R} $$\n符合测量 入射光子经过 PPKTP 晶体下转换产生的一对光子被分别被不同的单光子探测器探测, 然后生成一个具有一定波形, 幅度和宽度的定时脉冲被送到符合电路的两个输入端, 符合后产生一个输出脉冲被计数器记录表示一次符合.\n真符合: 来源于同一事件的两个脉冲产生的符合; 偶然符合: 拉源于不同事件, 且在时间上偶然重合的信号产生的符合. TAC 将两个探测器产生的信号间的时间差转换为电压幅值信号, 通过多道分析仪统计时间差, 并且通过软件将这些数据显示并记录在计算机上.\n实验步骤 确定半波片和极化片的光轴;\n光路及光学元件的初步调节;\n根据 PPKTP 的中心高度确定整个光路的高度;\n确定半波片的光轴方向和偏振片的偏振方向;\n耦合器(Coupler)的聚焦和准直;\n细调光路, 测量符合对比度曲线\n进一步细调光路使得两路光子计数和符合计数最大; 分别测量一路偏振片方向为$0°,90°,45°,-45°,-22.5°,67.5°$时, 另一路偏振片的偏振方向在$[0, 360)$ 范围内均匀变化的符合计数, 并且画出对应的对比度曲线. Bell 不等式的实验测量 验证纠缠量子态的非局域性.\n$$ S = |E(\\phi_{A}\\phi_{B})-E(\\phi_{A}\\phi_{B}\u0026rsquo;)+E(\\phi_{A}\u0026rsquo;\\phi_{B})+E(\\phi_{A}\u0026rsquo;\\phi_{B}\u0026rsquo;)| \u0026lt; 2 $$\n$$ E(\\phi_{A}, \\phi_{B}) = \\frac{N_{\\phi_{A}\\phi_{A}} + N_{\\phi_{B}\\phi_{B}} - N_{\\phi_{A}\\phi_{B}} -N_{\\phi_{B}\\phi_{A}}}{N_{\\phi_{A}\\phi_{A}} + N_{\\phi_{B}\\phi_{B}} + N_{\\phi_{A}\\phi_{B}} + N_{\\phi_{B}\\phi_{A}}} $$\n$N_{\\phi_{A}\\phi_{B}}$ 为 AB 两路极化片分别为 $\\phi_{A}$ 和 $\\phi_{B}$ 时的符合计数.\n思考题 反打光系统起什么作用? “答案” 用于将一个光子分裂成一对纠缠光子并且将其分发到两个测量站, 测量站中可以检测其相关性. 哪些参数指标被用于考察我们所制备的纠缠源是否优质, 什么因素影响纠缠源的质量? “答案” 参数指标:\n纠缠度(Entanglement fidelity): 指纠缠源所制备的纠缠态与理想纠缠态之间的相似程度 纠缠速率(Entanglement rate): 指纠缠源所制备的纠缠态的产生速率 纠缠时间(Entanglement time): 指纠缠源所制备的纠缠态的保持时间 影响因素:\n光源的稳定性和噪声水平: 光源的稳定性和噪声水平对纠缠源的纠缠度、速率和时间都有影响. 光源的亮度: 光源的亮度越高, 纠缠度和速率就越高. 光源的波长: 光源的波长也会影响纠缠度和速率. 光源的偏振: 光源的偏振对纠缠度有影响, 因为只有特定的偏振方向才能产生纠缠态. 光源的几何形状: 光源的几何形状对纠缠度和速率都有影响, 因为不同的几何形状会导致不同的光场模式和光子分布. 实验环境的干扰: 实验环境的干扰会影响纠缠度和速率, 因为干扰会导致光源的稳定性和噪声水平发生变化. 测得的符合计数曲线如何分析? “答案” 详情见于上述的数据处理部分. 查阅文献并论述测量 Bell 不等式应选取什么偏振片角度的计数读数, 为什么? “答案” 因为我们选取的是 $|H\\rangle, |V\\rangle, |+\\rangle, |-\\rangle$, 所以需要选择上述实验操作中所用的角度 $\\alpha, \\alpha\u0026rsquo;, \\beta, \\beta'$ 找一个简单的通讯方案, 设计一个利用纠缠源验证方案的实验; “答案” Alice 和 Bob 之间通过纠缠源传输信息. 他们可以使用两个纠缠光子, 其中一个光子被发送给 Alice, 另一个光子被发送给 Bob. Alice 和 Bob 可以通过对自己手中的光子进行测量, 来推断对方手中的光子的状态, 从而完成信息的传输.\n为了验证这个方案, 可以进行如下实验:\n制备纠缠源: 制备一个高质量的纠缠源, 可以使用光纤或者非线性晶体等材料制作. 产生纠缠光子对: 使用纠缠源产生一对纠缠光子. 分离纠缠光子对: 将纠缠光子对分别发送给 Alice 和 Bob. 量子态传输: Alice 和 Bob 分别对自己手中的光子进行测量, 并将测量结果发送给对方. 他们可以使用单光子探测器和偏振旋转器等设备进行测量. 验证纠缠: 通过比较测量结果, 可以验证纠缠光子对的纠缠性质. 如果纠缠光子对的纠缠度高, 那么 Alice 和 Bob 可以通过测量自己手中的光子, 来推断对方手中的光子的状态, 从而完成信息的传输. 分析实验结果: 分析实验结果, 评估纠缠源的质量和通讯方案的可行性. 如果实验结果表明纠缠光子对的纠缠度和传输距离都比较高, 那么这个通讯方案就是可行的. 查阅文献并结合本次实验测量结果探究量子纠缠, Bell 不等式的深层意义. “答案” Bell 不等式是量子力学中用来检测量子纠缠的一种方法. 它是由物理学家 John S. Bell 在 1964 年提出的. Bell 不等式的基本思想是, 如果物理系统是局部实在论的, 即物理量的测量结果在任何时候都是确定的, 那么测量结果之间的相关性不应该超过一个特定的上限. 但是, 当物理系统处于量子纠缠状态时, Bell 不等式的上限将被违反. 这表明量子力学中存在着非局部实在论的效应, 即物理量的测量结果在某些情况下是不确定的.\n在实验中, 我们可以使用 Bell 不等式来检测两个纠缠粒子之间的量子纠缠. 实验中, 我们可以使用反打光系统来生成纠缠光子. 反打光系统可以将一个光子分裂成两个纠缠光子, 并将它们分别发送到两个测量站. 在测量站中, 我们可以测量两个光子之间的相关性, 并使用 Bell 不等式来检测量子纠缠. 如果测量结果超过了 Bell 不等式的上限, 那么这两个光子就是纠缠的.\n量子纠缠是量子力学中一个非常重要的概念, 它可以被用来实现量子通信、量子计算等领域的应用. 量子纠缠的深层意义在于它揭示了量子力学中的非局部实在论效应, 这是经典物理学所不具备的. 通过研究量子纠缠, 我们可以更好地理解量子力学中的奇异性质, 并且可以开发出更加高效的量子技术.\n","permalink":"https://Muatyz.github.io/posts/exp/quantum-photon/","summary":"实验目的 了解量子纠缠态的概念、性质及其在量子信息领域的应用, 进而深刻理解量子力学的本质与精髓; 学习光子纠缠源的制备原理, 学习相关的非线性光学的知识, 如自发参量放大与振荡、相位匹配、自发参量下转换等; 学习量子光学实验中涉及的基本实验仪器的原理和使用方法。如光纤传输和耦合的理论与技术","title":"量子光学基础"},{"content":"Abstract In the experiment, you will learn how to use plastic scientillator to measure lifetime of muon in cosmic ray. The basic particle detection skills will be shown in this activity, including how to using a PMT detector, signal processing methods, and data analysis skills etc.\n译：\n在这个实验中, 你将学习如何使用塑料科学仪器来测量宇宙射线中 $\\mu$ 子的寿命. 在这个活动中, 将展示基本的粒子检测技能, 包括如何使用 PMT 检测器、信号处理方法和数据分析技能等.\nIntroduction Muon was discovered by Carl D. Anderson in 1936 in studying of cosmic radiation. Just like its cousin electron, muon does not take part in strong interaction, bus has mass roughly 200 times larger than that of electron. Because its short lifetime, the muon from out space normally decay out before they arrive earth. Therefore, muons which come into our laboratory are the results of the interactions between protons and the nuclei in our atmosphere, principally nitrogen, oxygen and argon. At top of the atmosphere, the incoming protons are traveling at relativistic speeds. When they penetrate the atmosphere, many particles like $\\pi^{0,\\pm}, n, K$, etc. can be created due to the interactions and theirs sequencial reactions.\n缪子是由卡尔-D-安德森在1936年研究宇宙辐射时发现的. 就像它的表亲电子一样, $\\mu$ 介子不参与强相互作用, 其质量大约是电子的200倍. 由于它的寿命很短, 来自太空的 $\\mu$ 介子通常在到达地球之前就已经衰变了. 因此, 进入我们实验室的 $\\mu$ 介子是质子和我们大气层中的核子(主要是氮、氧和氩)之间相互作用的结果. 在大气层的顶部, 进入的质子以相对论级别的速度飞行. 当它们穿透大气层时, 由于相互作用和它们的连续反应, 许多粒子如 $\\pi^{0,\\pm}, n, K$ 等可以被创造出来.\nThe muons which will be detected in this experiment are the results of these reactions.(Fig.1), i.e.: $$ \\pi^{+} \\rightarrow \\mu^{+}+\\nu_{\\mu} \\\\ \\pi^{-} \\rightarrow \\mu^{-}+\\bar{\\nu_{\\mu}} \\\\ $$\nand then the muon will decay to:\n$$ \\mu^{+} \\rightarrow e^{+}+\\bar{\\nu_{\\mu}}+\\nu_{e} \\\\ \\mu^{-} \\rightarrow e^{-}+\\nu_{\\mu}+\\bar{\\nu_{e}} \\\\ $$\nThe muon flux in the atmosphere is shown in Fig. 2\n本实验将检测到的 $\\mu$ 介子是这些反应的结果. (图1), 即： $$ \\pi^{+} \\rightarrow \\mu^{+}+\\nu_{\\mu} \\\\ \\pi^{-} \\rightarrow \\mu^{-}+\\bar{\\nu_{\\mu}} \\\\ $$\n然后缪子会衰变为：\n$$ \\mu^{+} \\rightarrow e^{+}+\\bar{\\nu_{\\mu}}+\\nu_{e} \\\\ \\mu^{-} \\rightarrow e^{-}+\\nu_{\\mu}+\\bar{\\nu_{e}} \\\\ $$\n大气层中的 $\\mu$ 介子通量如图2所示.\nExperimental Setup The system is shown in Fig.3. A muon may traverse through the plastic scintillator or stop inside due to its energy. The energy loss in the scintillator is transformed into scintillator light and then is collected by the photomultiplier tube (PMT). The output signal from PMT is sent to discriminator which, once be triggered, can generate a few-ns-wide pulse. The pulse is splited to two, and send to the start and stop of a time-to-amplitude converter (TAC).\n该系统如图3所示.\n一个 $\\mu$ 介子根据其能量大小, 可能会穿越塑料闪烁体, 也可能而停在闪烁器里面. $\\mu$ 介子在闪烁器中的能量损失被转化为闪烁器的光, 然后被光电倍增管(PMT)收集. PMT的输出信号被送到鉴别器, 一旦被触发, 可以产生一个几ns宽的脉冲. 该脉冲被分成两个, 并被送到时间-振幅转换器(TAC)的开始和停止位置.\nThe cable to the start input of the TAC is roughly 3 meters longer than the cable to the stop input of the TAC.\nAt normal state, the TAC is ready to accept a start pulse. It ignores the stop pulse. The signal delayed 3 meter long cable start the TAC, and let it waiting another event come in.\nBut normally, nothing come in to stop the TAC during the maximum time range of TAC. But if a muon is stopped in the scintillator, its decay products, an electron or position, can cause another pulse, which servers as stop signal.\nThis stop signal, together with the start signal induced by muon itself, gives the time spectrum of the muon’s decay.\n通向TAC的启动输入的电缆大约比通向TAC的停止输入的电缆长3米.\n在正常状态下, TAC 准备接受一个启动脉冲. 此时它忽略了停止脉冲. 被延迟了传播3米长电缆所需时间的信号启动 TAC, 并让它等待另一个事件的到来.\n但通常情况下, 在 TAC 的最大接收时间范围内, 没有任何东西会激发信号来停止 TAC.\n但是如果有一个 $\\mu$ 介子被停止于闪烁体中, 它的衰变产物, 即一个电子或位置(注:这里的位置可能是由于被误译为position,个人猜测应该是正电子), 可以引起另一个脉冲, 可以被当成停止信号.\n这个停止信号, 加上 $\\mu$ 介子本身引起的启动信号, 给出了 $\\mu$ 介子衰变的时间谱.\nThe time sequence is shown in Fig.4.\n时间顺序如图4所示.\n提示 注意看在图示里面的信号分布应该是左边为更早的信号, 也就是传统的$y-t$图像. 里面的箭头只承担方向导引而并不代表实际的时间分布. Experimental Procedure According to the Fig.3, set up the electronics;\n根据图3, 设置好电子装置；\nHigh Voltage is used here, you can not do it at the first time without supervised. Tune the HV for the PMT carefully, and monitor the out signals at the oscilloscope;\n本次实验涉及使用高压电, 实验者不可以在无监督下进行首次实验. 仔细调整 PMT 的高压, 并在示波器上监测输出的信号;\nTune the threshold of the $\\color{red}{discriminator}$ carefully, to cut the background noise;\n仔细调整$\\color{red}{鉴别器}$的阈值以排除背景噪音;\nMonitor the start and stop signals on $\\color{red}{oscilloscope}$ to make sure the stop signal is normally earlier than start signals;\n在$\\color{red}{示波器}$上监测启动和停止信号, 确保停止信号通常早于启动信号;\nStart data acquisition system to record the time spectrum. You may need to wait few days to have the time spectrum;\n启动数据采集系统以记录时间谱. 时间谱可能需要耗费数天才会得到.\nAnalyze the time spectrum you obtained. Fit the curve to get the lifetime.\n分析所得到的时间谱. 拟合曲线以得到 $\\mu$ 子寿命.\nQuestions It is well accepted that “free muon” lifetime is $\\tau_{\\mu} = 2.1969811(22) × 10^{−6}$, and $\\tau_{\\mu +} /\\tau_{\\mu -} = 1.00002 \\pm 0.00008$. Does your result agree with that? Are the muons “free” in our setup?\n\u0026ldquo;自由$\\mu$介子\u0026quot;的寿命是$\\tau_{\\mu} = 2.1969811(22) × 10^{−6}$, 而$\\tau_{\\mu +} /\\tau_{\\mu -} = 1.00002 \\pm 0.00008$. 你的结果与此一致吗? 缪子在我们的实验装置中是\u0026quot;自由\u0026quot;的吗?\n答案 自由$\\mu$介子指的是未曾与物质发生相互作用的$\\mu$介子, 其寿命是已知的, 且自由$\\mu$介子还有一个特征就是整体呈现电中性(也就是$\\tau_{\\mu +} /\\tau_{\\mu -}\\approx 1$)\n根据以上特征, 可以得知我们在实验室中测得的缪子是否为自由介子.\nTaking into account the fact that there are muons and anti-muons in the (mixed) muon flux, how to interpret the results we obtained? Note that muons can also be captured by normal matter (proton and nucleus) via $$ \\mu^{-}+p \\rightarrow n+\\nu_{\\mu} \\\\ $$ thus making the muons appear to have a shorter lifetime (due to this additional capture process). The muons’ capture rate depends on the $Z$ of the interacting matter (in our case, the plastic scintillator has $Z = 6$ for carbon) by $Z^4$. For $Z = 10$, it is known that the (negative) muons would have $1/2$ of the “free muon” lifetime.\nAssuming we have equal fractions of muons and anti-muons in the experiment, what is the expected value for the muon lifetime? Does your result agree with the expectation? In reality, we normally see more anti-muons than muons in the experiment (why?), say, $55%$ vs. $45%$, does this make your result agree more (or less) with the expected value?\n如果考虑混合 $\\mu$ 子流中存在的 $\\mu$ 子和反 $\\mu$ 子, 如何解释我们得到的结果?\n请注意, $\\mu$ 子也可以通过以下方式被普通物质(质子和核子)俘获, $$ \\mu^{-}+p \\rightarrow n+\\nu_{\\mu} \\\\ $$ 从而使 $\\mu$ 子的寿命看起来更短(由于这个额外的俘获过程). 因此, $\\mu$ 子的俘获速率取决于与之相互作用的物质的$Z$数的$4$次方(在我们的情况下, 塑料闪烁体的碳的$Z$为$6$). 对于$Z = 10$, 已知(负) $\\mu$ 子将具有“自由 $\\mu$ 子”寿命的$1/2$.\n假设实验中 $\\mu$ 子和反 $\\mu$ 子的比例相等, 那么 $\\mu$ 子寿命的期望值是多少? 你的结果是否符合期望? 答案 我们可以将$\\mu$子的寿命分为两种情况：自由$\\mu$子和被物质俘获的$\\mu$子。其中，被物质俘获的$\\mu$子的寿命会看起来更短，因为它们被俘获后会与物质发生相互作用，从而导致寿命的缩短。\n根据已知信息，对于$Z=10$的物质，$\\mu$子的寿命会缩短到自由$\\mu$子寿命的$1/2$。而在实验中，我们使用的是$Z=6$的物质，因此我们可以估算出被俘获的$\\mu$子的寿命相对于自由$\\mu$子寿命的比例为$(6/10)^4=0.1296$。\n因此，我们可以将$\\mu$子的寿命期望值表示为：\n$$ \\begin{aligned} \\tau \u0026amp;= P(\\mu \\text{为自由}\\mu\\text{子})\\times \\tau_{\\mu} + P(\\mu \\text{被俘获})\\times \\frac{1}{2}\\tau_{\\mu} \\\\ \u0026amp;= \\frac{1}{2}\\tau_{\\mu} + 0.1296\\times \\frac{1}{2}\\tau_{\\mu} \\\\ \u0026amp;= 0.614\\times \\tau_{\\mu} \\\\ \u0026amp;= 1.347 \\times 10^{-6}\\text{s} \\end{aligned} $$\n因此，$\\mu$子的寿命期望值为$1.347 \\times 10^{-6}\\text{s}$。\n在现实中, 我们通常在实验中看到更多的反 $\\mu$ 子而非 $\\mu$ 子(为什么?), 答案 这是因为反$\\mu$子与正电子（即反质子）的衰变产物具有更长的寿命，这使得它们在实验室中更容易被探测到。此外，在宇宙射线中，反$\\mu$子比$\\mu$子更容易产生，因此在实验中观测到更多的反$\\mu$子也是可能的。 比如说, 55％对45％, 这是否使你的结果更符合期望值? 答案 根据题目中的信息，我们可以得到以下计算步骤：\n计算负$\\mu$子的自由寿命 $$ \\tau_{\\mu^-} = \\tau_{\\mu} = 2.1969811(22) \\times 10^{-6} s $$\n计算负$\\mu$子在实验中被俘获的速率相对于自由寿命的比例 $$ \\frac{1}{\\tau_{\\mu^-}} = \\frac{1}{\\tau_{\\mu}} + \\lambda_{\\text{capt}} \\\\ \\lambda_{\\text{capt}} = \\frac{1}{\\tau_{\\mu^-}} - \\frac{1}{\\tau_{\\mu}} = 194.6 \\text{ s}^{-1} $$\n计算负$\\mu$子在实验中的寿命期望值 $$ \\tau_{\\text{exp}}^- = \\frac{1}{\\frac{45}{100}\\lambda_{\\mu^-} + \\frac{55}{100}\\lambda_{\\bar{\\mu}^-}} = 2.048 \\times 10^{-6} \\text{ s} $$\n根据题目中的信息，正$\\mu$子的寿命期望值与负$\\mu$子的寿命期望值相同，即 $$ \\tau_{\\text{exp}}^+ = \\tau_{\\text{exp}}^- = 2.048 \\times 10^{-6} \\text{ s} $$\n因此，$\\mu$子的寿命期望值为 $2.048 \\times 10^{-6}$ 秒。\n将 反$\\mu$子/$\\mu$子视为变量$k$: 答案 Can the background radiations show up in the time spectrum you measured? How to subtract them?\n背景辐射能在你测量的时间光谱中显示出来吗? 如何除去它们? 答案 实验中的第三步确保将背景辐射从数据中剔除:\nTune the threshold of the $\\color{red}{discriminator}$ carefully, to cut the background noise; 仔细调整$\\color{red}{鉴别器}$的阈值以排除背景噪音；\nLab Report Format Title Abstract Introduction Methods, Materials and Procedures Results and Discussions Answers to Questions and More Discussions Conclusions Appendices “实验报告格式” 1. 标题 2. 摘要 3. 简介 4. 方法、材料和程序 5. 结果和讨论 6. 对问题的回答和更多讨论 7. 结论 8. 附录 ","permalink":"https://Muatyz.github.io/posts/exp/muon-lifetime/","summary":"Abstract In the experiment, you will learn how to use plastic scientillator to measure lifetime of muon in cosmic ray. The basic particle detection skills will be shown in this activity, including how to using a PMT detector, signal processing methods, and data analysis skills etc. 译： 在这个实验中, 你将学习如何使用塑料科学仪器来测量宇宙射线中 $\\mu$ 子的寿命. 在这个活动中, 将展示基本的粒子检测技能, 包括如何使用 PMT 检测器、信号处理方法和数据分析技能等. Introduction Muon was discovered by Carl D. Anderson in 1936 in","title":"使用塑料闪烁体测量介子的寿命"},{"content":" 本文内容来自 GitHub 的 Zihao Wang 所开发的开源项目 twisted_bilayer_graphene, 如有条件可进入链接为其 Star 以提供支持.\n在转角双层石墨烯的数值计算综述 中我们已经提到过有关紧束缚模型和低能连续模型(也有称之为低能有效模型, 如关济寰的石墨烯紧束缚模型到低能有效模型的推导). 而 Zihao Wang 的项目中也是基于 Moiré bands in twisted double-layer graphene 论文所提出的连续模型给出的, 所以对于目前正在焦虑于如何使用 ITensor 的密度矩阵重整化群方法来计算能带的本人来说, 是一个很好的用来借鉴与学习的对象.\n为了学习如何将物理图像化为代码进行计算, 这里我将源代码一步步拆解分别解说, 读者可以结合原项目中的 Jupyter Notebook 阅读体会.\n注意: 对源代码有轻微改动\n非魔角下的双层石墨烯 常量与参数 # 引入基础库 from numpy import * import matplotlib.pyplot as plt import numpy as np # 定义常数 theta = 5.00 # 旋转角, 度 omega = 110.7 # 跃迁参数, meV d = 1.420 # 层间距, 埃 hv = 1.5 * d * 2970 # 单层石墨烯的费米速度, meV * 埃 N = 5 # 截断范围 valley = -1 # 狄拉克点取点, +1 for K, -1 for K\u0026#39; KDens = 100 # K点密度 # 跃迁参数 theta = theta * np.pi / 180.0 # 弧度 I = complex(0,1) # 单位虚数 ei120 = np.cos(2*np.pi/3) + valley * I * np.sin(2*np.pi/3) # 120度的旋转虚数 ei240 = np.cos(4*np.pi/3) - valley * I * np.sin(4*np.pi/3) # 240度的旋转虚数 b1m = 8 * np.pi * np.sin(theta/2) / 3 / d * np.array([0.5, -np.sqrt(3)/2]) # 摩尔晶格倒格矢 b2m = 8 * np.pi * np.sin(theta/2) / 3 / d * np.array([0.5, np.sqrt(3)/2]) # 摩尔晶格倒格矢 qb = 8 * np.pi * np.sin(theta/2) / 3 / np.sqrt(3) / d * array([0, -1]) K1 = 8 * np.pi * np.sin(theta/2) / 3 / np.sqrt(3) / d * array([-np.sqrt(3)/2, -0.5]) # K点 K2 = 8 * np.pi * np.sin(theta/2) / 3 / np.sqrt(3) / d * array([-np.sqrt(3)/2, 0.5]) # K\u0026#39;点 跃迁矩阵 ## 采用最近邻跃迁假设 Tqb = omega * np.array([[1 , 1], [1 , 1 ]], dtype = complex) # T_{qb} Tqtr = omega * np.array([[ei120, 1], [ei240, ei120]], dtype = complex) # T_{qtr} Tqtl = omega * np.array([[ei240, 1], [ei120, ei240]], dtype = complex) # T_{qtl} ## 求跃迁矩阵的共轭转置(D == dagger) TqbD = np.array(np.matrix(Tqb).H) TqtrD = np.array(np.matrix(Tqtr).H) TqtlD = np.array(np.matrix(Tqtl).H) 晶格定义 # 定义晶格 L = [] invL = np.zeros((2 * N + 1, 2 * N + 1), int) # 晶格坐标索引 # 生成晶格网络, 将格点的坐标保存在L列表中 def Lattice(n): count = 0 for i in np.arange(-n, n + 1): for j in np.arange(-n, n + 1): L.append([i, j]) invL[i+n, j+n] = count # 坐标为(i, j)的格点对应的索引count保存于invL[i + n, j + n]中 count = count + 1 for i in np.arange(-n, n + 1): for j in np.arange(-n, n + 1): L.append([i, j]) Lattice(N) # 生成晶格网络 siteN = (2 * N + 1)**2 # 晶格格点总数 L = np.array(L) # 转换为numpy数组 哈密顿量函数构造 def Hamiltonian(kx, ky): H = array(zeros((4 * siteN, 4 * siteN)), dtype=complex) for i in np.arange(siteN): #diagonal term ix = L[i, 0] iy = L[i, 1] ax = kx - valley * K1[0] + ix * b1m[0] + iy * b2m[0] ay = ky - valley * K1[1] + ix * b1m[1] + iy * b2m[1] qx = np.cos(theta/2) * ax + np.sin(theta/2) * ay qy =-np.sin(theta/2) * ax + np.cos(theta/2) * ay H[2 *i, 2 *i +1] = hv * (valley *qx - I *qy) H[2 *i +1, 2 *i] = hv * (valley *qx + I *qy) #off-diagonal term j = i + siteN H[2*j, 2*i] = TqbD[0, 0] H[2*j, 2*i+1] = TqbD[0, 1] H[2*j+1, 2*i] = TqbD[1, 0] H[2*j+1, 2*i+1] = TqbD[1, 1] if (iy != valley*N): j = invL[ix+N, iy+valley*1+N] + siteN H[2*j, 2*i] = TqtrD[0, 0] H[2*j, 2*i+1] = TqtrD[0, 1] H[2*j+1, 2*i] = TqtrD[1, 0] H[2*j+1, 2*i+1] = TqtrD[1, 1] if (ix != -valley*N): j = invL[ix-valley*1+N, iy+N] + siteN H[2*j, 2*i] = TqtlD[0, 0] H[2*j, 2*i+1] = TqtlD[0, 1] H[2*j+1, 2*i] = TqtlD[1, 0] H[2*j+1, 2*i+1] = TqtlD[1, 1] for i in np.arange(siteN, 2*siteN): #diagnoal term j = i - siteN ix = L[j, 0] iy = L[j, 1] ax = kx - valley*K2[0] + ix*b1m[0] + iy*b2m[0] ay = ky - valley*K2[1] + ix*b1m[1] + iy*b2m[1] qx = cos(theta/2) * ax - sin(theta/2) * ay qy = sin(theta/2) * ax + cos(theta/2) * ay H[2*i, 2*i+1] = hv * (valley*qx - I*qy) H[2*i+1, 2*i] = hv * (valley*qx + I*qy) #off-diagonal term H[2*j, 2*i] = Tqb[0, 0] H[2*j, 2*i+1] = Tqb[0, 1] H[2*j+1, 2*i] = Tqb[1, 0] H[2*j+1, 2*i+1] = Tqb[1, 1] if (iy != (-valley*N)): j = invL[ix+N, iy-valley*1+N] H[2*j, 2*i] = Tqtr[0, 0] H[2*j, 2*i+1] = Tqtr[0, 1] H[2*j+1, 2*i] = Tqtr[1, 0] H[2*j+1, 2*i+1] = Tqtr[1, 1] if (ix != valley*N): j = invL[ix+valley*1+N, iy+N] H[2*j, 2*i] = Tqtl[0, 0] H[2*j, 2*i+1] = Tqtl[0, 1] H[2*j+1, 2*i] = Tqtl[1, 0] H[2*j+1, 2*i+1] = Tqtl[1, 1] eigenvalue,featurevector=np.linalg.eig(H) eig_vals_sorted = np.sort(eigenvalue) # eig_vecs_sorted = featurevector[:,eigenvalue.argsort()] e=eig_vals_sorted return e ","permalink":"https://Muatyz.github.io/posts/phy/cmp/tbg-moireband-python/","summary":"本文内容来自 GitHub 的 Zihao Wang 所开发的开源项目 twisted_bilayer_graphene, 如有条件可进入链接为其 Star 以提供支持. 在转角双层石墨烯的数值计算综述 中我们已经提到过有关紧束缚模型和低能连续模型(也有称之为低能有效模型, 如关济寰的石墨烯紧束缚模型到低能有效模型的推导). 而 Zihao Wang 的项目中也是基于 Moiré bands in twisted double-layer graphene 论文所提出的连","title":"Python计算转角石墨烯能带"},{"content":"全同性和对称性 对于多粒子体系, 我们可以将单单变量波函数扩展为 $N$ 变量波函数, 该波函数可以通过乘上某系数进行归一化.\n某系统中具有两个电子, 可以被看作是两个独立波函数 $\\psi_{1}(x_{1})$ 和 $\\psi_{2}(x_{2})$, 则 $\\psi(x_{1},x_{2})=\\psi_{1}(x_{1})\\psi_{2}(x_{2})$. 用狄拉克标记即为 $|\\psi_{1}\\rangle|\\psi_{2}\\rangle$. 其坐标表象可以通过 $$ (\\langle x_{1}|\\langle x_{2}|)(|\\psi_{1}\\rangle|\\psi_{2}\\rangle) = \\langle x_{1}|\\psi_{1}\\rangle\\langle x_{2}|\\psi_{2}\\rangle = \\psi_{1}(x_{1})\\psi_{2}(x_{2}) $$ 导出.\n对于全同性粒子, 有一个重要的概念是全同性.\n我们使用系数 $\\zeta$ 来描述交换对称性和交换反对称性.\n$\\zeta = +1$, 即服从玻色统计, 交换对称. 自旋为整数, 因为可以多个全同粒子同时处于同一个量子态, 所以在低温可以出现凝聚现象.常见的玻色子: 光子.\n$\\zeta = -1$, 即服从费米统计, 交换反对称, 自旋为半整数. 满足泡利不相容原理, 即费米子不会出现在同一量子态中. 常见的费米子: 电子, 中子, 质子.\n物质粒子都是费米子, 传递力作用的粒子都是玻色子.\n我们对一个含两个费米子的系统进行描述, 分别处于 $\\psi_{1}(\\vec{r})$ 和 $\\psi_2(\\vec{r})$, 进行反对称化构造:\n$$ \\Psi(\\vec{r_{1}},\\vec{r_{2}}) = \\frac{1}{\\sqrt{2}}(\\psi_{1}(\\vec{r_1})\\psi_{2}(\\vec{r_2})-\\psi_{2}(\\vec{r_{1}})\\psi_{1}(\\vec{r_{2}}))=\\frac{1}{\\sqrt{2}} \\left| \\begin{array}{cccc} \\psi_{1}(\\vec{r_{1}}) \u0026amp; \\psi_{1}(\\vec{r_{2}}) \\\\ \\psi_{2}(\\vec{r_{1}}) \u0026amp; \\psi_{2}(\\vec{r_{2}}) \\\\ \\end{array} \\right| $$\n可以观察到, 如果交换 $\\vec{r_{1}}$ 和 $\\vec{r_{2}}$, 波函数就会反号, 这符合费米子的定义.\n如果数量继续增加, 比如三个:\n$$ \\Psi(\\vec{r_{1}},\\vec{r_{2}},\\vec{r_{3}})=\\frac{1}{\\sqrt{3!}} \\left| \\begin{array}{cccc} \\psi_{1}(\\vec{r_{1}})\u0026amp;\\psi_{1}(\\vec{r_{2}})\u0026amp;\\psi_{1}(\\vec{r_{3}})\\\\ \\psi_{2}(\\vec{r_{1}})\u0026amp;\\psi_{2}(\\vec{r_{2}})\u0026amp;\\psi_{2}(\\vec{r_{3}})\\\\ \\psi_{3}(\\vec{r_{1}})\u0026amp;\\psi_{3}(\\vec{r_{2}})\u0026amp;\\psi_{3}(\\vec{r_{3}})\\\\ \\end{array} \\right| $$\n从而归纳得到 $N$ 个全同费米子的波函数为:\n$$ \\Psi(\\vec{r_{1}},\\vec{r_{2}},\u0026hellip;,\\vec{r_{N}}) = \\frac{1}{\\sqrt{N!}} \\left| \\begin{array}{cccc} \\psi_{1}(\\vec{r_{1}}) \u0026amp; \\psi_{1}(\\vec{r_{2}}) \u0026amp; \\cdots \u0026amp; \\psi_{1}(\\vec{r_{N}}) \\\\ \\psi_{2}(\\vec{r_{1}}) \u0026amp; \\psi_{2}(\\vec{r_{2}}) \u0026amp; \\cdots \u0026amp; \\psi_{2}(\\vec{r_{N}}) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ \\psi_{N}(\\vec{r_{1}}) \u0026amp; \\psi_{N}(\\vec{r_{2}}) \u0026amp; \\cdots \u0026amp; \\psi_{N}(\\vec{r_{N}}) \\\\ \\end{array} \\right|. $$\n用统计观点来看待 $\\frac{1}{\\sqrt{N!}}$ 系数的产生\n任意两个费米子的坐标 $\\vec{r_{i}}$ 和 $\\vec{r_{j}}$ 都是不同的, 且交换后波函数反号. 那么这就是一个排列数问题, 即对于 $N$ 个费米子, 存在着 $A_{N}^{N} = N!$ 中排列方式.\n又因为我们要求波函数具有归一性, 即波函数做内积为$1$, 而每一个独立的 $\\Pi_{i}\\psi_{i}$ 其内积为 $1$, 而这样的 $\\Pi_{i}\\psi_{i}$ 一共有 $N!$ 个, 所以我们需要除以 $N!$ 使得波函数具有归一性. $N!$ 几何平均到波函数上, 就得到了 $\\frac{1}{\\sqrt{N!}}$ 系数.\n由此我们得到了全同费米子的波函数.\n而对于玻色子, 情况就要简单得多, 因为交换时不产生负号. 那么我们可以用最简单的方式写出系统的波函数:\n$$ \\Psi(\\vec{r_{1}},\\vec{r_{2}},\u0026hellip;,\\vec{r_{N}}) = \\frac{1}{\\sqrt{N!}}\\sum_{P}\\prod_{i}\\psi_{P_{i}}(\\vec{r_{i}}) $$\n$P$ 指 $N$ 个粒子所有可能的置换\n我们前面提到过可以用 $\\zeta$ 来描述交换对称性和交换反对称性, 那么我们可以将同一的式子来描述多粒子体系:\n$$ \\Psi(\\vec{r_{1}},\\vec{r_{2}},\u0026hellip;,\\vec{r_{N}}) = \\frac{1}{\\sqrt{N!}}\\sum_{P}\\zeta^{P}\\prod_{i}\\psi_{P_{i}}(\\vec{r_{i}}) $$\n由此我们得出了多体波函数的斯莱特行列式(Slater Determinant)形式.\n粒子数表象\u0026amp;Fock Space 即使只是抄写多体波函数的表达式, 也会让人丧失计算的欲望. 更简洁的方法是使用占据数, 或者被称为粒子数表象的方法.\n我们无需知道哪个粒子在哪一个具体的态上, 只需要知道每一个态上有多少个粒子就可以了. 比如我们写作\n$$ |n_{1},n_{2},\u0026hellip;,n_{i},\u0026hellip;n_{N}\\rangle, (\\sum_{i}n_{i}=N) $$\n就是表达第一个态上有 $n_{1}$ 个粒子, 第二个态上有 $n_{2}$ 个粒子, 以此类推. 这样的表述同样能够构造出多粒子波函数.\n粒子观点和场观点\n这一段内容来自于知乎答主 Kyle Zhang 在二次量子化算是量子场论吗?中的回答.其中的内容通俗有趣.\n\u0026ldquo;明天有冷空气过境\u0026quot;就不叫场观点, 这叫粒子观点, 因为它描述了一团粒子在时空背景上的运动.(Lagrangian Description)\n但对于同一件事情, 天气预报员若换一种说法:\u0026ldquo;明天本地的温度将会降低\u0026rdquo;.\n这就叫场观点, 因为它描述了温度在某一固定点上的值, 把各个点上的温度汇总起来就形成了一个\u0026quot;温度场\u0026rdquo;.(Eulerian Description)\nLagrangian 描述就像随波逐流的小船, 描述一个具有内禀性质的实体的运动:苹果从树上落到了牛顿的头上; Eulerian 描述就像抛了锚的小船, 描述在一个固定点某个性质的变化: 树上湮灭了一个苹果, 牛顿的头上产生了一个苹果.\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/sec-quantization/","summary":"全同性和对称性 对于多粒子体系, 我们可以将单单变量波函数扩展为 $N$ 变量波函数, 该波函数可以通过乘上某系数进行归一化. 某系统中具有两个电子, 可以被看作是两个独立波函数 $\\psi_{1}(x_{1})$ 和 $\\psi_{2}(x_{2})$, 则 $\\psi(x_{1},x_{2})=\\psi_{1}(x_{1})\\psi_{2}(x_{2})$. 用狄拉克标记即为 $|\\psi_{1}\\rangle|\\psi_{2}\\rangle$. 其坐标表象可以通过 $$ (\\langle x_{1}|\\langle x_{2}|)(|\\psi_{1}\\rangle|\\psi_{2}\\rangle) = \\langle x_{1}|\\psi_{1}\\rangle\\langle x_{2}|\\psi_{2}\\rangle = \\psi_{1}(x_{1})\\psi_{2}(x_{2}) $$ 导出. 对于全同性粒子, 有一个重要的概念是全同性. 我们","title":"二次量子化与升降算符"},{"content":"本页面内容学习自关济寰的个人博客画转角石墨烯示意图（附 Python 代码）.\n因为正在研究转角双层石墨烯, 并且个人常常使用 Matlab 来绘制图像, 对于 Python 的数值计算使用十分欠缺, 因此抄录于此以进行学习.\n简单正方晶格 #绘制简单正方晶格 #使用conda切换至cmp环境(conda activate cmp) import numpy as np def main(): x_array = np.arange(-5,5.1) y_array = np.arange(-5,5.1) coordinates=[] for x in x_array: for y in y_array: coordinates.append([x,y]) plot_dots(coordinates) def plot_dots(coordinates): import matplotlib.pyplot as plt fig,ax = plt.subplots(figsize=(9,9)) plt.subplots_adjust(left=0.05,bottom=0.05,right=0.95,top=0.95) plt.axis(\u0026#39;off\u0026#39;) for i1 in range(len(coordinates)): for i2 in range(len(coordinates)): if np.sqrt((coordinates[i1][0]-coordinates[i2][0])**2+(coordinates[i1][1]-coordinates[i2][1])**2)\u0026lt;1.1: ax.plot([coordinates[i1][0],coordinates[i2][0]],[coordinates[i1][1],coordinates[i2][1]],\u0026#39;-k\u0026#39;,linewidth=1) for i in range(len(coordinates)): ax.plot(coordinates[i][0],coordinates[i][1],\u0026#39;ro\u0026#39;,markersize=10) plt.savefig(\u0026#39;simple-square-lattice.eps\u0026#39;) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行结果: 单层石墨烯 import numpy as np def main(): x_array = np.arange(-5,5.1) y_array = np.arange(-5,5.1) coordinates=[] for x in x_array: for y in y_array: coordinates.append([0+x*3,0+y*np.sqrt(3)]) coordinates.append([1+x*3,0+y*np.sqrt(3)]) coordinates.append([-1/2+x*3,np.sqrt(3)/2+y*np.sqrt(3)]) coordinates.append([-3/2+x*3,np.sqrt(3)/2+y*np.sqrt(3)]) plot_dots(coordinates) def plot_dots(coordinates): import matplotlib.pyplot as plt x_range = max(np.array(coordinates)[:,0])-min(np.array(coordinates)[:,0]) y_range = max(np.array(coordinates)[:,1])-min(np.array(coordinates)[:,1]) fig,ax = plt.subplots(figsize=(9*x_range/y_range,9)) plt.subplots_adjust(left=0.05,bottom=0.05,right=0.95,top=0.95) plt.axis(\u0026#39;off\u0026#39;) for i1 in range(len(coordinates)): for i2 in range(len(coordinates)): if np.sqrt((coordinates[i1][0]-coordinates[i2][0])**2+(coordinates[i1][1]-coordinates[i2][1])**2)\u0026lt;1.1: ax.plot([coordinates[i1][0],coordinates[i2][0]],[coordinates[i1][1],coordinates[i2][1]],\u0026#39;-k\u0026#39;,linewidth=1) for i in range(len(coordinates)): ax.plot(coordinates[i][0],coordinates[i][1],\u0026#39;ro\u0026#39;,markersize=8) plt.savefig(\u0026#39;single-layer-graphene.eps\u0026#39;) plt.show() if __name__ == \u0026#39;__main__\u0026#39;: main() 运行结果:\n转角双层石墨烯 import numpy as np import copy import matplotlib.pyplot as plt from math import * def main(): x_array = np.arange(-50,50.1) y_array = np.arange(-50,50.1) coordinates=[] for x in x_array: for y in y_array: coordinates.append([0+x*3,0+y*np.sqrt(3)]) coordinates.append([1+x*3,0+y*np.sqrt(3)]) coordinates.append([-1/2+x*3,np.sqrt(3)/2+y*np.sqrt(3)]) coordinates.append([-3/2+x*3,np.sqrt(3)/2+y*np.sqrt(3)]) x_range1 = max(np.array(coordinates)[:,0])-min(np.array(coordinates)[:,0]) y_range1 = max(np.array(coordinates)[:,1])-min(np.array(coordinates)[:,1]) theta = -1.1/180*pi rotation_matrix=np.zeros((2,2)) rotation_matrix[0][0]= np.cos(theta) rotation_matrix[0][1]=-np.sin(theta) rotation_matrix[1][0]= np.sin(theta) rotation_matrix[1][1]= np.cos(theta) coordinates2 = copy.deepcopy(coordinates) for i in range(len(coordinates)): coordinates2[i] = np.dot(rotation_matrix,coordinates[i]) x_range2 = max(np.array(coordinates2)[:,0])-min(np.array(coordinates2)[:,0]) y_range2 = max(np.array(coordinates2)[:,1])-min(np.array(coordinates2)[:,1]) x_range = max(x_range1,x_range2) y_range = max(y_range1,y_range2) fig,ax=plt.subplots(figsize=(9*x_range/y_range,9)) plt.subplots_adjust(left=0.05,bottom=0.05,right=0.95,top=0.95) plt.axis(\u0026#39;off\u0026#39;) plot_dots_1(ax,coordinates) plot_dots_2(ax,coordinates2) plot_dots_0(ax,[[0,0]]) plt.savefig(\u0026#39;twisted-bilayer-graphene.eps\u0026#39;) plt.show() def plot_dots_0(ax,coordinates): for i in range(len(coordinates)): ax.plot(coordinates[i][0],coordinates[i][1],\u0026#39;ko\u0026#39;,markersize=0.5) def plot_dots_1(ax,coordinates): for i1 in range(len(coordinates)): for i2 in range(len(coordinates)): if np.sqrt((coordinates[i1][0]-coordinates[i2][0])**2+(coordinates[i1][1]-coordinates[i2][1])**2)\u0026lt;1.1: ax.plot([coordinates[i1][0],coordinates[i2][0]],[coordinates[i1][1],coordinates[i2][1]],\u0026#39;-k\u0026#39;,linewidth=0.2) for i in range(len(coordinates)): ax.plot(coordinates[i][0],coordinates[i][1],\u0026#39;ro\u0026#39;,markersize=0.5) #相比于plot_dots_1只是改变了颜色,其余部分完全相同 def plot_dots_2(ax,coordinates): for i1 in range(len(coordinates)): for i2 in range(len(coordinates)): if np.sqrt((coordinates[i1][0]-coordinates[i2][0])**2+(coordinates[i1][1]-coordinates[i2][1])**2)\u0026lt;1.1: ax.plot([coordinates[i1][0],coordinates[i2][0]],[coordinates[i1][1],coordinates[i2][1]],\u0026#39;--k\u0026#39;,linewidth=0.2) for i in range(len(coordinates)): ax.plot(coordinates[i][0],coordinates[i][1],\u0026#39;bo\u0026#39;,markersize=0.5) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行结果:\n可以看到, 在1.1°(也就是计算提出的第一魔转角)下的转角双层石墨烯体现出了摩尔超晶格现象.\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/tbg-fig-python/","summary":"本页面内容学习自关济寰的个人博客画转角石墨烯示意图（附 Python 代码）. 因为正在研究转角双层石墨烯, 并且个人常常使用 Matlab 来绘制图像, 对于 Python 的数值计算使用十分欠缺, 因此抄录于此以进行学习. 简单正方晶格 #绘制简单正方晶格 #使用conda切换至cmp环境(conda activate cmp) import numpy as np def main(): x_array = np.arange(-5,5.1) y_array = np.arange(-5,5.1) coordinates=[]","title":"使用Python绘制转角石墨烯"},{"content":"one site 单节点 Site\n意指\u0026quot;节点\u0026quot;.\n单节点的自旋为 $\\frac{1}{2}$ 的波函数,有两个基底.\n$|s=1\\rangle=|\\uparrow\\rangle;|s=2\\rangle=|\\downarrow\\rangle$\n对于一般的自旋为 $\\frac{1}{2}$ 的波函数,可以写成如下形式:\n$|\\psi\\rangle=\\sum_{s=1}^{2}\\psi_s|s\\rangle(\\psi_s\\in\\mathcal{C})$\n使用张量数学来处理这个单节点波函数, 即 $|\\psi_s\\rangle$ 对应一个有一个\u0026quot;触手\u0026quot;的结点.展开形式为 $(^{\\psi_1}_{\\psi_2})$ , $\\psi_1,\\psi_2$ 又各自是一个单\u0026quot;触手\u0026quot;的结点.\nIndex s(\u0026#34;s\u0026#34;,2); //\u0026#34;s\u0026#34;代表的是Index的命名 //2是Index的维度 ITensor psi(s); //由于只声明不定义,所以初始值为0 Index 指标\n指的是表示某种物理量的符号.这个符号 可以是矢量, 张量, 算符.\nIndex s(2,\u0026#34;s\u0026#34;); Index t(3,\u0026#34;t\u0026#34;); ITensor T(s,t); 这个表示的就是创建了一个二维的物理量,我们用$s$来标记它;物理量t则是三维的. 而Itensor的大小则是 $2\\times 3$.\n对 $|\\psi_s\\rangle$ 进行初始化操作.我们不妨将其初始化为基矢:\n$|\\psi_s\\rangle=|\\uparrow\\rangle$\nIndex s(2,\u0026#34;s\u0026#34;); //在最新的ITensor语法规范中,Index (string, int)的语法已经被弃用 //目前的语法应当是Index (int, string) ITensor psi(s); psi(s(1)) = 1; PrintData(psi); 本示例代码应该会输出:\npsi = ITensor ord=1: (dim=2|id=414|\u0026#34;s\u0026#34;) {norm=1.00 (Dense Real)} (1) 1.0000000 Operators 操作符/算子 $\\hat{A}$ 算子体现在张量网络上就是一个拥有两个\u0026quot;触手\u0026quot;的结点, 它可以和只有一个\u0026quot;触手\u0026quot;的结点结合, 从而生成一个新的只有一个触手的结点.\nITensor Sz(s,prime(s)); ITensor Sx(s,prime(s)); //prime(s)是指的对s进行共轭操作 如果要对一个向量或者矩阵进行转置,共轭等操作,我们可以用被称为上下标的操作来表示.比如, $A_{ij}^{\u0026rsquo;}=A_{ji}$, $A_{ij}^{\\dagger}=A_{ji}$ 等.\nprime(s)就代表了对指标进行上标操作所得到的量.\nPrime Level 上标级别\n指标有一个属性被称为prime level, 表示是否被某个操作升降级.默认情况下指标的上标级别为0.\n这个量的作用是用来对两个张量进行比较, 在进行某些操作时, 上标必须要满足某些需求运算才能够成立.\n比如\nIndex s(2,\u0026#34;s\u0026#34;); Index t(2,\u0026#34;2\u0026#34;); ITensor A(s,t); ITensor B(s,t);// s, t 都是上标级别为 0 的指标 C = A * prime(B);// prime(B) 表示将 B 中的所有指标上标级别加 1 在这里, A * prime(B)就是一个不允许指标重复的操作.所以为了完成这个计算,我们需要对B进行上标级别升级的操作,也就是使用prime()函数.\n现在我们来对 $\\hat{S}_z,\\hat{S}_x$ 算子进行定义.\nITensor Sz(s,prime(s)),Sx(s,prime(s)); // commaInit(Sz,s,prime(s)) = 0.5, 0.0, // 0.0,-0.5; // commaInit(Sx,s,prime(s)) = 0.0, 0.5, // 0.5, 0.0; //commaInit的语法已经被弃用, 应当使用.set() //Sz Sz.set(s(1),prime(s)(1),0.5); Sz.set(s(2),prime(s)(2),-0.5); //Sx Sx.set(s(1),prime(s)(2),0.5); Sx.set(s(2),prime(s)(1),0.5);//设置分量 现在我们尝试对波函数 $|\\psi\\rangle$ 进行求某方向自旋的操作.\n即方程上的\n$$ (\\hat{S_{x}})_{s\u0026rsquo;}^{s}\\psi_{s} $$\n对应的是\nITensor phi = Sx * psi; (注意算符的上标要和波函数的下标相同, 这样的操作才是被允许的. $s$和$s\u0026rsquo;$的上标等级不同, 所以是不匹配的)\n为了研究经过求自旋的量 $|\\phi\\rangle$ 的具体情况, 我们将其输出在终端:\nITensor phi = Sx * psi; PrintData(phi); 输出的结果应该是:\nphi = ITensor ord=1: (dim=2|id=816|\u0026#34;s\u0026#34;)\u0026#39; {norm=0.50 (Dense Real)} (2) 0.5000000 我们来看看更多的结果. 如果有 $|\\psi_s\\rangle=(|^{\\cos{\\frac{\\theta}{2}}}_{\\sin{\\frac{\\theta}{2}}}\\rangle)_{\\theta=\\frac{\\pi}{4}}$, 那么我们可以这样描述:\nReal theta = Pi/4; // psi(s(1)) = cos(theta/2); // psi(s(2)) = sin(theta/2); //该语法已被弃用,使用.set()替代 psi.set(s(1),cos(theta/2)); psi.set(s(2),sin(theta/2)); PrintData(psi); 终端会输出\npsi = ITensor ord=1: (dim=2|id=977|\u0026#34;s\u0026#34;) {norm=1.00 (Dense Real)} (1) 0.9238795 (2) 0.3826834 期望值 $\\langle\\hat{A}\\rangle$ 在物理上我们定义算符 $\\hat{A}$ 的期望值为 $\\langle\\psi|\\hat{A}|\\psi\\rangle$.\n我们不妨求自旋算符 $\\hat{S_z}$ 的期望值. 在张量网络上, 这个过程体现为, 作为算符的\u0026quot;具有上下两个触手的结点\u0026quot;的每个触手分别连接一个\u0026quot;只有单触手的结点\u0026quot;(也就是代表着单节点波函数).\n我们用程序语言来描述这个过程:\nITensor cpsi = dag(prime(psi)); // Real zz = (cpsi * Sz * psi).toReal(); // Real xx = (cpsi * Sx * psi).toReal(); // toReal()函数已弃用,使用.real()替代 Real zz = (cpsi * Sz * psi).real(); Real xx = (cpsi * Sx * psi).real(); // println(\u0026#34;\u0026lt;Sz\u0026gt;=\u0026#34;,zz); // println(\u0026#34;\u0026lt;Sx\u0026gt;=\u0026#34;,xx); // println()已弃用,使用printfln()替代 printfln(\u0026#34;\u0026lt;Sz\u0026gt;=\u0026#34;,zz); printfln(\u0026#34;\u0026lt;Sx\u0026gt;=\u0026#34;,xx); 其中ITensor cpsi = dag(prime(psi));就是一个将 $\\psi$ 先取转置后取共轭的过程, 所以cpsi的上标级数为$2$. 我们也可以推测得知, 算符 $\\hat{S}_x,\\hat{S}_z$的上标级数为$1$.\n终端输出为\n\u0026lt;Sz\u0026gt;=0.353553 \u0026lt;Sx\u0026gt;=0.353553 观察到 $\\sqrt{\\langle S_z\\rangle ^2 + \\langle S_x\\rangle ^2} = \\frac{1}{2}$\n我们可以将这个过程进行类似结合率的分析:\n$\\langle\\psi|\\hat{S}_z|\\psi\\rangle = \\langle\\psi|\\hat{S}_z\\psi\\rangle$.\n用代码来描述结合律的过程:\nITensor Zpsi = Sz * psi; //因为Sz以s为上标,psi以s为下标,所以允许运算 ITensor expect = cpsi * Zpsi; Real zz = expect.real() Quiz $1$ 解析 提示\n原文所提示的函数elt()已经弃用.所以采用的是传统的prime(A) * B方式. 如果你想使用函数而非 *来得到内积, 你应当采用函数inner()\n#include \u0026#34;itensor/all.h\u0026#34; #include \u0026#34;itensor/util/print_macro.h\u0026#34; using namespace itensor; int main(){ // Define our Index // (the space we are working with) auto s = Index(2,\u0026#34;s\u0026#34;); // Operators auto Sx = ITensor(s,prime(s)); Sx.set(s(1),prime(s)(2),0.5); Sx.set(s(2),prime(s)(1),0.5); PrintData(Sx); // Single-site wavefunction auto psi = ITensor(s); //initialized to zero // TODO // 1. make the above wavefunction // the (normalized) positive Sx eigenstate psi.set(s(1),1/sqrt(2)); psi.set(s(2),1/sqrt(2)); PrintData(psi); // TODO // 2. Compute |phi\u0026gt; = Sx |psi\u0026gt; using // the Sx and psi ITensors above // AND // compute: auto olap = \u0026lt;psi|phi\u0026gt; // using the * operator and elt(...) method. // Print the result with PrintData(...). auto phi = Sx * psi; auto olap = prime(psi) * phi; //auto olap = elt(prime(psi),phi); PrintData(olap); // TODO // 3. Try normalizing |phi\u0026gt; and recompute // the inner product \u0026lt;psi|phi\u0026gt; // Print the result with PrintData(...). // HINT: use phi /= norm(phi)) to normalize. phi /= norm(phi); //auto olap2 = eltC(prime(psi),phi); auto olap2 = prime(psi) * phi; PrintData(olap2); return 0; } 输出得到:\nSx = ITensor ord=2: (dim=2|id=15|\u0026#34;s\u0026#34;) (dim=2|id=15|\u0026#34;s\u0026#34;)\u0026#39; {norm=0.71 (Dense Real)} (2,1) 0.5000000 (1,2) 0.5000000 psi = ITensor ord=1: (dim=2|id=15|\u0026#34;s\u0026#34;) {norm=1.00 (Dense Real)} (1) 0.7071068 (2) 0.7071068 olap = ITensor ord=0: {norm=0.50 (Dense Real)} 0.5000000 olap2 = ITensor ord=0: {norm=1.00 (Dense Real)} 1.0000000 Two Sites 双节点 纠缠态 对于双自旋的波函数, 我们一般的描述方程是:\n$$ |\\Psi\\rangle = \\sum_{s_1,s_2 = 1}^{2}\\psi_{s_1s_2}|s_1\\rangle|s_2\\rangle $$\n体现在张量网络上, 就是一个结点在同一方向上同时有着两个\u0026quot;触手\u0026quot;. 对于我们写出来的态, 我们可以分离出两个单态(Singlet).\n程序上的描述方法:\n// Index s1(2,\u0026#34;s1\u0026#34;,Site), s2(2,\u0026#34;s2\u0026#34;,Site); // 该语法已经被弃用,使用两步语法来替代 Index s1(2,\u0026#34;s1\u0026#34;);s1.addTags(\u0026#34;Site\u0026#34;); Index s2(2,\u0026#34;s2\u0026#34;);s1.addTags(\u0026#34;Site\u0026#34;); ITensor psi(s1,s2); //只声明不定义,则默认为0 // psi(s1(1),s2(2)) = 1./sqrt(2); // psi(s1(2),s2(1)) =-1./sqrt(2); // 该语法已被弃用,使用.set()来替代. psi.set(s1(1),s2(2), 1./sqrt(2)); psi.set(s1(2),s2(1),-1./sqrt(2)); PrintData(psi); Index s1(2,\u0026quot;s1\u0026quot;);s1.addTags(\u0026quot;Site\u0026quot;);代表的含义是创建一个维数为int,标签(或者理解为\u0026quot;名字\u0026quot;,一般是指物理上的状态,比如自旋,粒子位置等等)为string,指标类型为Site的物理量.同时使用ITensor psi(s1,s2)将s1和s2设置为纠缠态(Entangled State).\n现在要说明的就是指标(Index)的类型:Site和Link.\nSite表示单个量子位的物理态. 适用于表示单个自旋,单个粒子的位置等等. 与之配对的维数int表示的是该量子位可以取的物理态的数量;\nLink表示的是不同量子位之间的相互作用. 这种相互作用通常表示不同量子位的链接, 适用于表示各种相互作用, 比如哈密顿量等.\n(还有表示不同于Site和Link类型的其它指标类型, 比如Bulk)\n上面的代码中我们用Site来标记两个量子位,并且使其结合为纠缠态.\n结果输出为\npsi = ITensor ord=2: (dim=2|id=324|\u0026#34;s1,Site\u0026#34;) (dim=2|id=127|\u0026#34;s2\u0026#34;) {norm=1.00 (Dense Real)} (2,1) -0.707107 (1,2) 0.7071068 哈密顿量$\\hat{H}$ 我们写出双自旋系统的哈密顿量方程:\n$\\hat{H}=\\hat{S}_1\\cdot\\hat{S}_2=S_1^zS_2^z+\\frac{1}{2}S_1^+S_2^-+\\frac{1}{2}S_1^-S_2^+$\n其中 $S_1^\\pm, S_2^\\pm$ 是升降算符. 我们在程序中这样创建:\nIndex s1(2,\u0026#34;s1\u0026#34;);s1.addTags(\u0026#34;Site\u0026#34;); Index s2(2,\u0026#34;s2\u0026#34;);s1.addTags(\u0026#34;Site\u0026#34;); ITensor Sz1(s1,prime(s1)),Sp1(s1,prime(s1)),Sm1(s1,prime(s1)); ITensor Sz2(s2,prime(s2)),Sp2(s2,prime(s2)),Sm2(s2,prime(s2)); // commaInit(Sp1,s1,prime(s1)) = 0, 1, // 0, 0; // commaInit语法已被弃用. //Sz1,Sz2 Sz1.set(s1(1),prime(s1)(1),0.5);Sz1.set(s1(2),prime(s1)(2),-0.5); Sz2.set(s2(1),prime(s2)(1),0.5);Sz2.set(s2(2),prime(s2)(2),-0.5); //Sp1,Sp2 Sp1.set(s1(1),prime(s1)(2),1);Sp2.set(s2(1),prime(s2)(2),1); //Sm1,Sm2 Sm1.set(s1(2),prime(s1)(1),1);Sm2.set(s2(2),prime(s2)(1),1); ITensor H = Sz1 * Sz2 + 0.5 * Sp1 * Sm2 + 0.5 * Sm1 * Sp2; PrintData(H);//你也可以尝试执行printfln(\u0026#34;H=\u0026#34;,H); 执行后可以得到结果\nH = ITensor ord=4: (dim=2|id=397|\u0026#34;s1,Site\u0026#34;) (dim=2|id=397|\u0026#34;s1,Site\u0026#34;)\u0026#39; (dim=2|id=53|\u0026#34;s2\u0026#34;) (dim=2|id=53|\u0026#34;s2\u0026#34;)\u0026#39; {norm=0.87 (Dense Real)} (1,1,1,1) 0.2500000 (2,2,1,1) -0.250000 (1,2,2,1) 0.5000000 (2,1,1,2) 0.5000000 (1,1,2,2) -0.250000 (2,2,2,2) 0.2500000 这表明这是一个四阶张量,并且由索引s1, s1', s2, s2'来描述. 它们各自的维度都是$2$, 即它们可以取值为$1$或$2$.这就是(i,j,k,l)中1或者2的含义, 后面的值是对应的张量元素.\n这样计算得来的 $\\hat{H}$ 在张量网络中表示一个上下各自有两个\u0026quot;触手\u0026quot;的结点, 恰好可以和表现为在某一方向上拥有两个\u0026quot;触手\u0026quot;的纠缠态结点进行结合.\n更具体地说, 我们上面创建的 $\\hat{H}$ 的上标是s1'和s2',下标是s1和s2; 而 $\\psi$ 的上标是s1和s2,两者进行结合就可以得到只有两个上标s1'和s2'的新节点 $\\hat{H}\\psi$ .\n程序上这样描述这个结合的过程:\nITensor Hpsi = H * psi; //Hpsi.mapprime(1,0);//该语句的作用是将Hpsi中所有上标级别为1的索引全部降为0,使得之后的运算能够被允许 //该语法已被弃用. 使用.noPrime()来代替 Hpsi.noPrime(); Real E = (dag(psi) * Hpsi).real(); //Print()语法已被弃用, 使用PrintData()来代替. PrintData(E); 能够在终端得到输出\nE = -0.75 当然这个过程也可以一行语句完成:\nReal E = (dag(prime(psi)) * H * psi).real(); PrintData(E); 输出的结果同样是\nE = -0.75 Quiz $2$ 解析 这个题目的背景是, 使用虚时间演化的方式来找到哈密顿量所对应的基态. 对应的方程是\n$e^{-\\beta H/2}|0\\rangle\\propto|\\Psi_0\\rangle$\n#include \u0026#34;itensor/all.h\u0026#34; #include \u0026#34;itensor/util/print_macro.h\u0026#34; using namespace itensor; //定义生成Sp Sm Sz的函数 ITensor makeSp(Index const\u0026amp; s){ auto Sp = ITensor(s,prime(s)); Sp.set(s=2,prime(s)=1, 1); return Sp; } ITensor makeSm(Index const\u0026amp; s){ auto Sm = ITensor(s,prime(s)); Sm.set(s=1,prime(s)=2,1); return Sm; } ITensor makeSz(Index const\u0026amp; s){ auto Sz = ITensor(s,prime(s)); Sz.set(s=1,prime(s)=1,+0.5); Sz.set(s=2,prime(s)=2,-0.5); return Sz; } int main(){ // Initial product state auto s1 = Index(2,\u0026#34;s1\u0026#34;);auto s2 = Index(2,\u0026#34;s2\u0026#34;); auto psi = ITensor(s1,s2); psi.set(s1=1,s2=2,1.0); PrintData(psi); // Single-site operators auto Sz1 = makeSz(s1);auto Sz2 = makeSz(s2); auto Sp1 = makeSp(s1);auto Sp2 = makeSp(s2); auto Sm1 = makeSm(s1);auto Sm2 = makeSm(s2); // Two-site Heisenberg Hamiltonian auto H = Sz1 * Sz2 + 0.5 * Sp1 * Sm2 + 0.5 * Sm1 * Sp2; // Initial energy expectation value auto initEn = elt(dag(prime(psi)) * H * psi); printfln(\u0026#34;\\nInitial energy = %.10f\u0026#34;,initEn); // Make exp(-beta*H) // TODO // 3. Adjust beta to get the ground state Real beta = 0.1; auto expH = expHermitian(H,-beta); // Here we apply exp(-beta*H), normalize // and unprime auto psibeta = expH * psi; psibeta.noPrime(); psibeta /= norm(psibeta); PrintData(psibeta); auto En = elt(dag(prime(psibeta)) * H * psibeta); printfln(\u0026#34;At beta=%.1f, energy = %.10f\u0026#34;,beta,En); // TODO // 1. Adjust the following code to // truncate to dimension 1. // HINT: use the ITensor named argument // system, e.g. {\u0026#34;MaxDim=\u0026#34;,...} auto [U,D,V] = svd(psibeta,{s1},{\u0026#34;MaxDim=\u0026#34;,1}); PrintData(D); // TODO // 2. Calculate the overlap of the new // wavefunction with the old wavefunction. // Print your results with PrintData(...). // HINT: use U*D*V to calculate the new, // truncated wavefunction auto newpsi = U * D * V; PrintData(newpsi); Real op = (dag(prime(newpsi)) * H * psibeta).real(); PrintData(op); // TODO // 3. Increase beta (defined above) to get the // ground state. How does the overlap // change? return 0; } 输出得到.\npsi = ITensor ord=2: (dim=2|id=311|\u0026#34;s1\u0026#34;) (dim=2|id=239|\u0026#34;s2\u0026#34;) {norm=1.00 (Dense Real)} (1,2) 1.0000000 Initial energy = -0.2500000000 psibeta = ITensor ord=2: (dim=2|id=311|\u0026#34;s1\u0026#34;) (dim=2|id=239|\u0026#34;s2\u0026#34;) {norm=1.00 (Dense Real)} (2,1) -0.049896 (1,2) 0.9987544 At beta=0.1, energy = -0.2998339973 D = ITensor ord=2: (dim=1|id=426|\u0026#34;U,Link\u0026#34;) (dim=1|id=228|\u0026#34;V,Link\u0026#34;) {norm=1.00 (Diag Real)} (1,1) 0.9987544 newpsi = ITensor ord=2: (dim=2|id=311|\u0026#34;s1\u0026#34;) (dim=2|id=239|\u0026#34;s2\u0026#34;) {norm=1.00 (Dense Real)} (1,2) 0.9987544 op = -0.274295 所以只要我们一直调整beta的取值反复编译执行, 最后就能够找到能量最低时所对应的beta值.\nSVD 奇异值分解 Singular Value Decomposition\n如果M是 $m\\times m$ 的矩阵, 那么一定存在这样一个式子:\n$M = U \\Sigma V^*$\n其中$U$是 $m\\times m$ 的酉矩阵, $\\Sigma$ 是 $m\\times n$ 非负实数对焦矩阵, $V^*$ 是 $n\\times n$ 的酉矩阵.\n其中 $\\Sigma$ 对角线上的元素 $\\Sigma_{i,i}$ 是 $M$ 的奇异值.\n密度矩阵重整化群 Density Matrix Renormalization Group\n该方法通过矩阵乘积态(Matrix Product State,MPS)来表示量子多体系统的波函数等. DMRG方法来源于密度矩阵的理论和重整化群的思想, 大幅减少系统自由度的同时保留了系统中的物理特征.\n对于\n$$ M= \\begin{bmatrix} 0.435839 \u0026amp; 0.223707 \u0026amp; 0.10\\\\ 0.435839 \u0026amp; 0.223707 \u0026amp; -0.10 \\\\ 0.223707 \u0026amp; 0.435839 \u0026amp; 0.10 \\\\ 0.223707 \u0026amp; 0.435839 \u0026amp; -0.10 \\\\ \\end{bmatrix} $$\n可以分解为 $A * D * B$:\n$$ \\begin{bmatrix} 0.5 \u0026amp;-0.5 \u0026amp; 0.5 \\\\ 0.5 \u0026amp;-0.5 \u0026amp;-0.5 \\\\ 0.5 \u0026amp; 0.5 \u0026amp; 0.5 \\\\ 0.5 \u0026amp; 0.5 \u0026amp;-0.5 \\\\ \\end{bmatrix}* \\begin{bmatrix} 0.933 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0.300 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.200 \\\\ \\end{bmatrix}* \\begin{bmatrix} 0.707107 \u0026amp; 0.707107 \u0026amp; 0 \\\\ -0.707107 \u0026amp; 0.707107 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} $$\n可以看出, 两边的矩阵 $A,B$ 满足酉矩阵的定义, 即有 $A^{\\dagger}A=I,BB^{\\dagger}=I$.而对角矩阵 $D$ ,元素是非负实数且降序排列.\n如果我们从后往前一步步去除 $D$ 对角线上的元素, 即\n$$ \\begin{bmatrix} 0.933 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0.300 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.200 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} 0.933 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0.300 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} 0.933 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix} $$\n这种操作被称为截断(Truncating).\n然后依次重新进行 $M_{i} = A * D_{i} * B$ 合成, 并且使用范数 $||M_i - M||^2$ 来对合成后的矩阵产生的偏差程度进行评估.我们将可以看到:\n$$ ||M - M||^2 = 0;\\ ||M - M_1||^2 = (0.2)^2;\\ ||M - M_2||^2 = (0.2)^2 + (0.3)^2; $$\n我们不难看出, 其实截断就是在降低矩阵 $D$ 的秩, 通过把握这个截断的幅度, 我们就可以控制最后产生 $M_i$ 矩阵的偏差程度. 这是一个用精度换速度的过程.\n双自旋波函数 我们不妨用更物理一点的背景来分析奇异值分解的过程.\n对于一个纠缠态的双自旋系统, 我们已经知道可以处理为一个具有两个\u0026quot;触手\u0026quot;(即上标)的结点. 但是我们也可以将其作为一个矩阵来处理, 即一个拥有左右两个\u0026quot;触手\u0026quot;的结点.\n$-^{s_1} -\\square\\square\\square^{\\psi}-^{s_2}-$\n这样, 我们就可以对中间的结点进行SVD操作, 这样就形成了一个项链式的结构:\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n这种波函数形式, 我们将其称之为\u0026quot;矩阵乘积态\u0026quot;(Matrix Product State,MPS).\n为了让这个结构看上去更像是一个波函数,可以想象两侧的\u0026quot;触手\u0026quot;是向上的(上标).\n不妨用程序来描述这个过程.\nITensor A(s1),D,B; //先声明后使用 svd(psi,A,D,B); 我们已经知道, 对于一个寻常的双自旋波函数, 我们需要 $(2s + 1)^2$ 个参数来进行描述. 而且一般情况下, 我们对于这些参数的重要程度是无知的.无法放弃任何一个参数, 这就会急剧增加计算量.\n而SVD给了我们一种可能: 我们不仅能知道哪些参数最重要, 我们还可以很大程度上掌握它们的数量, 而且这个数量很有可能很少(有利于计算!).\n我们用方程来表达矩阵乘积态的思想:\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha,\\alpha\u0026rsquo;,s_2}A_{s_1\\alpha}D_{\\alpha\\alpha\u0026rsquo;}B_{\\alpha\u0026rsquo;s_2}|s_1\\rangle|s_2\\rangle $$\n当然我们也可以将矩阵 $A,D$ 预先相乘形成新矩阵 $\\psi$, 张量网络的形式即为:\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n$\\downarrow$\n$-^{s_1} -\\square\\square^{\\psi}-\\square^{B}-^{s_2}-$\n这样我们就得到了\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha\u0026rsquo;,s_2}\\psi_{s_1\\alpha\u0026rsquo;}B_{\\alpha\u0026rsquo;s_2}|s_1\\rangle|s_2\\rangle $$\n同理, 我们也可以将矩阵 $D,B$ 预先相乘形成新矩阵 $\\psi$, 张量积算网络的形式为\n$-^{s_1} -\\square^{A}-\\square^{D}-\\square^{B}-^{s_2}-$\n$\\downarrow$\n$-^{s_1} -\\square^{A}-\\square\\square^{\\psi}-^{s_2}-$\n这样我们就得到了\n$$ |\\Psi\\rangle=\\sum_{s_1,\\alpha,s_2}A_{s_1\\alpha}\\psi_{\\alpha s_2}|s_1\\rangle|s_2\\rangle $$\nQuiz $3$ 解析 #include \u0026#34;itensor/all.h\u0026#34; #include \u0026#34;itensor/util/print_macro.h\u0026#34; using namespace itensor; int main(){ // SVD of matrix M int Nrow = 4;int Ncol = 3; auto maxdim = std::min(Nrow,Ncol);//确定截断维度 auto M = Matrix(Nrow,Ncol); M(0,0) = 0.435839; M(0,1) = 0.223707; M(0,2) = 0.10; M(1,0) = 0.435839; M(1,1) = 0.223707; M(1,2) = -0.10; M(2,0) = 0.223707; M(2,1) = 0.435839; M(2,2) = 0.10; M(3,0) = 0.223707; M(3,1) = 0.435839; M(3,2) = -0.10;//初始化矩阵 Print(M); //声明变量的数据类型 Matrix U,V; Vector d;//用来接收对角元素,即奇异值 SVD(M,U,d,V); Print(U);Print(d);Print(V); int nkeep = 2;//取矩阵的截断维度 auto Dtrunc = Matrix(maxdim,maxdim);//只声明不定义,则初始化为0 for(auto j : range(nkeep)){ Dtrunc(j,j) = d(j); }//在对角线上填上截断保留的奇异值 auto Mtrunc = U*Dtrunc*transpose(V);//重新结合形成采取截断后的矩阵 Print(Mtrunc); auto diff = norm(M-Mtrunc);auto diff2 = sqr(diff);//取矩阵差的范数来评估截断的效果(diff) printfln(\u0026#34;|M-Mtrunc|^2 = %.2f\u0026#34;,diff2); // SVD of two-site wavefunction auto s1 = Index(2,\u0026#34;s1\u0026#34;);auto s2 = Index(2,\u0026#34;s2\u0026#34;);//声明指标 auto sing = ITensor(s1,s2);auto prod = ITensor(s1,s2); //Make sing a singlet sing.set(s1=1,s2=2, 1./sqrt(2));sing.set(s1=2,s2=1,-1./sqrt(2)); //Make prod a product state prod.set(s1=1,s2=2,1.); for(Real mix = 0; mix \u0026lt;= 1.; mix += 0.1){ // TODO: ADD CODE here to create // a new wavefunction that is // (1-mix) times a product state plus (mix) // times a singlet (i.e. maximally entangled state). auto wf = (1. - mix) * prod + mix * sing; wf /= norm(wf); //PrintData(wf); // SVD this wavefunction and analyze the results. // Try computing and plotting the entanglement entropy. ITensor A(s1),D,B; Spectrum spec = svd(wf,A,D,B); //PrintData(U);PrintData(D);PrintData(V); auto ent = 0.; //.eig(n)返回的是第(n+1)个本征值,这是因为数组下标从0开始;.numEigsKept()则是表示的特征值的数目 for(int n = 0;n \u0026lt; spec.numEigsKept();n++){ auto P = sqr(spec.eig(n)); if(P \u0026gt; 0) ent -= P*log(P); } //分别以两位小数和六位小数的形式输出 printfln(\u0026#34;mix = %.2f, entropy = %.6f\\n\u0026#34;, mix, ent); } return 0; } 为了节省篇幅,原本需要多次执行的PrintData()函数被注释了. 如果你有查看其具体数值的需要可以在自己使用的时候启用.\n编译完成执行,在终端输出:\nM = |0.4358390 0.2237070 0.1000000| |0.4358390 0.2237070 -0.100000| |0.2237070 0.4358390 0.1000000| |0.2237070 0.4358390 -0.100000| U = |0.5000000 0.5000000 0.5000000| |0.5000000 0.5000000 -0.500000| |0.5000000 -0.500000 0.5000000| |0.5000000 -0.500000 -0.500000| d = 0.932739 0.3 0.2 V = |0.7071068 0.7071068 1.11671818E-16| |0.7071068 -0.707107 -8.81355030E-17| |-1.66426876E-17 -1.41285111E-16 1.0000000| Mtrunc = |0.4358390 0.2237070 -2.89544043E-17| |0.4358390 0.2237070 -2.89544043E-17| |0.2237070 0.4358390 1.34311222E-17| |0.2237070 0.4358390 1.34311222E-17| |M-Mtrunc|^2 = 0.04 mix = 0.00, entropy = 0.000000 mix = 0.10, entropy = 0.010473 mix = 0.20, entropy = 0.042683 mix = 0.30, entropy = 0.094817 mix = 0.40, entropy = 0.160729 mix = 0.50, entropy = 0.230729 mix = 0.60, entropy = 0.293765 mix = 0.70, entropy = 0.340279 mix = 0.80, entropy = 0.364548 mix = 0.90, entropy = 0.365602 mix = 1.00, entropy = 0.346574 Four 四结点 对于四节点的矩阵乘积态，我们可以用这样一个方程式来描述：\n$$ |\\Psi\\rangle=\\sum_{{s},{\\alpha}}M_{\\alpha_1}^{s_1}M_{\\alpha_1\\alpha_2}^{s_2}M_{\\alpha_2\\alpha_3}^{s_3}M_{\\alpha_4}^{s_4}|s_1s_2s_3s_4\\rangle $$\n前面我们已经学习过怎么处理将两个单节点结合为纠缠态的双节点. 所以我们这里可以将具有 $s_3$ 和 $s_4$ 上标的两个单节点组合形成具有 $s_3$ 和 $s_4$ 上标的纠缠态双节点.\n然后就是刚才所学的将双节点进行SVD分解, 而这里我们要分解的对象就是刚才合成的纠缠态双节点。\n为了继续保持四节点的性质，我们将分解出的A,D和B中的A与D结合,其上标是 $s_3$ ,而剩下来的B则单独作为结点, 其上标是 $s_4$.\n以这种方式得到的新的四节点张量, 我们称之为\u0026quot;右正交\u0026quot;(Right Orthogonal)或者说\u0026quot;右规范\u0026quot;, 这是因为单独作为结点的 $B$ 是 酉的 ($BB^{\\dagger}=I$).\n显然, 这种右正交的性质是可以向左传递的. 比如, 我们取已经完成了SVD和AD结合的四节点张量中的具有 $s_2$ 和 $s_3$ 上标的单节点重复上述操作, 便可以让具有上标 $s_3$ 的单节点也具有右正交的性质.依此类推, 使得除了 $s_1$ 之外的所有单节点都具有右正交的性质.\n期望值 $\\langle\\hat{A}_1\\rangle$ 我们考虑一个具有4量子位的纠缠态波函数求第一量子位算符的期望值的过程.\n在一般情况下,我们通常是这样求解的(假设 $|\\psi\\rangle$ 已经规一化):\n$$ \\langle\\hat{A_1}\\rangle=\\sum_{s}\\overline{\\psi}_{s\u0026rsquo;_{1}s_{2}s_{3}s_{4}}A_{s\u0026rsquo;_{1}s_{1}}\\psi_{s_{1}s_{2}s_{3}s_{4}} $$\n这个过程显然是及其繁杂的, 在这种情况下时间复杂度以 $O(2^n)$ 的速度增长, 如果不以某种算法进行简化必然极其耗时.\n如果是已经经过了 SVD 分解的纠缠态波函数, 除了第一量子位 $s_1$ , 其余的所有单节点全部都具有右正交性质, 而我们求的是第一量子位的算符的期望值, 这也意味着其余量子位结合不会对第一量子位的运算产生任何影响.\n通过这样的算法, 计算量得到了大量简化.\n用程序语言来描述这个过程:\nSpinHalf sites(N); //表示sites是N个1/2自旋量子位的体系 MPS psi(sites); //以矩阵乘积态表示sites体系的波函数, 并且用psi来称呼这个波函数 computeGroundState(H,psi);//寻找哈密顿量H下的基态, psi被用以进行初始化 psi.position(2);//将psi的正则位置设置为第二个位置. Real sz_expect = (dag(prime(psi.A(2),Site)) * sites.op(\u0026#34;Sz\u0026#34;,2) * psi.A(2)).real(); 正则位置Canonical Position\n在前面的SVD和regroup过程中我们只提到了\u0026quot;右规范\u0026quot;, 实际上我们也很容易将其推广到\u0026quot;左规范\u0026quot;, 这样的话我们就可以将正则位置定义为\u0026quot;左规范\u0026quot;和\u0026quot;右规范\u0026quot;同时成立的位置.\n在上面的例子中,因为我们要求的是第二量子位的自旋期望值, 为了简化我们就要将其左右的全部结点都规范化(具体结合的方向看正则位置的左右).\nQuiz $4$ 解析 矩阵乘积算子Matrix Product Operator(MPO)\n和矩阵乘积态(MPS)相似, MPO也是一种张量网络的表示方法. 它可以用来描述复杂量子系统的哈密顿量.\n#include \u0026#34;itensor/all.h\u0026#34; #include \u0026#34;itensor/util/print_macro.h\u0026#34; using namespace itensor; using std::vector; int main(){ int N = 50;//定义一个包含50个1/2自旋的系统\u0026#39;sites\u0026#39; auto sites = SpinHalf(N,{\u0026#34;ConserveQNs=\u0026#34;,false});//\u0026#34;ConserveQNs=\u0026#34;设为false,表示不考虑量子数守恒. // TODO // 3. Adjust the external field to see how the // magnetization changes Real h = 0.5; //调整h来找到相变点.h = 1 时,系统从磁性相变无序相. // Create the MPO for the transverse field // Ising model auto ampo = AutoMPO(sites); //创建一个自动构造MPO的对象\u0026#39;ampo\u0026#39; //依次赋值 for(int j = 1; j \u0026lt; N; ++j){ ampo += -4.0,\u0026#34;Sz\u0026#34;,j,\u0026#34;Sz\u0026#34;,j+1; } for(int j = 1; j \u0026lt;= N; ++j){ ampo += -2*h,\u0026#34;Sx\u0026#34;,j; } //哈密顿量的类型是MPO, 利用toMPO()函数将ampo里蕴含的信息转化为哈密顿量 auto H = toMPO(ampo); // Create a random starting state // For DMRG //随机生成一个初始态 auto psi0 = randomMPS(sites); // Run DMRG to get the ground state auto sweeps = Sweeps(5); //设置密度矩阵重整化群算法(DMRG)的最大迭代次数 sweeps.maxdim() = 5,10,20; //设置密度矩阵重整化群算法(DMRG)的最大纠缠矩阵维度的序列 sweeps.cutoff() = 1E-10; //设置奇异值的截断精度, 只有大于该值的奇异值才会被保留 auto [E,psi] = dmrg(H,psi0,sweeps,{\u0026#34;Quiet\u0026#34;,true}); //H为系统的哈密顿量, 以psi0作为迭代起点运行算法, //\u0026#39;sweeps\u0026#39;是迭代的参数, //\u0026#39;{\u0026#34;Quiet\u0026#34;,true}\u0026#39;表示静默运行(不输出详细的迭代信息) //返回值为基态能量和基态波函数, 以量 E 和 psi 对计算结果进行存储 //在终端查看基态能量值 printfln(\u0026#34;Ground state energy = \u0026#34;,E); // 对psi进行共轭转置. 此时psidag上标级别为2. auto psidag = dag(prime(psi)); // A vector holding the operators used // in the expectation value. // All set to identity operators to start. // Note: this is one-indexed // (O[n] is the operator on site n) //创建长为N+1的向量, 用于存储测量算符.O[j]代表在第j个量子位上的测量算符 auto O = vector\u0026lt;ITensor\u0026gt;(N+1); //对O进行初始化,方法是将所有的测量算符都设为单位算符 for(auto j : range1(N)){ O[j] = op(sites,\u0026#34;Id\u0026#34;,j); //\u0026#34;Id\u0026#34;意指\u0026#34;Identity\u0026#34;, 即单位算符 } // Position we will place our operator // 将本征位置选为正中, 即N/2.以这个位置来执行测量 int Npos = N/2; // TODO // 1. Add an operator to measure the magnetization // in the z direction at Npos. // HINT: use the op(...) function. // It provides spin operators \u0026#34;Sx\u0026#34;, \u0026#34;Sy\u0026#34;, \u0026#34;Sz\u0026#34;, // you may want to scale your operator // to make it a Pauli matrix auto op_z = 2.0 * op(sites,\u0026#34;Sz\u0026#34;,Npos); O[Npos] = op_z; // TODO // 2. Complete the following code // to measure the magnetization. // Print your results with PrintData(...) auto o = psidag(1) * O[1] * psi(1); for(auto j : range1(2,N)){ o *= psidag(j) * O[j] * psi(j); } PrintData(o); // TODO // 3. Adjust the transverse field h at the top of the // file to find the critical point. // HINT: think about the field limits h -\u0026gt; 0 // and h -\u0026gt; infinity return 0; } 编译执行后终端输出：\nvN Entropy at center bond b=25 = 0.002062540436 Eigs at center bond b=25: 0.9998 Largest link dim during sweep 1/5 was 4 Largest truncation error: 4.11222e-11 Energy after sweep 1/5 is -51.205898332822 Sweep 1/5 CPU time = 0.0146s (Wall time = 0.0177s) vN Entropy at center bond b=25 = 0.006828488484 Eigs at center bond b=25: 0.9992 Largest link dim during sweep 2/5 was 10 Largest truncation error: 1.88078e-08 Energy after sweep 2/5 is -51.298393038956 Sweep 2/5 CPU time = 0.0181s (Wall time = 0.0181s) vN Entropy at center bond b=25 = 0.002920154202 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 3/5 was 18 Largest truncation error: 9.69913e-11 Energy after sweep 3/5 is -52.306536772989 Sweep 3/5 CPU time = 0.0210s (Wall time = 0.0210s) vN Entropy at center bond b=25 = 0.002920148259 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 4/5 was 6 Largest truncation error: 9.45633e-11 Energy after sweep 4/5 is -52.306549436787 Sweep 4/5 CPU time = 0.0179s (Wall time = 0.0180s) vN Entropy at center bond b=25 = 0.002920145615 Eigs at center bond b=25: 0.9997 Largest link dim during sweep 5/5 was 5 Largest truncation error: 9.18628e-11 Energy after sweep 5/5 is -52.306549436806 Sweep 5/5 CPU time = 0.0168s (Wall time = 0.0168s) Ground state energy = -52.3065 o = ITensor ord=0: {norm=0.96 (Dense Real)} -0.964679 \u0026ldquo;小车\u0026rdquo; Trotter – Suzuki formula 上一章中我们测量的是单个量子位的期望值, 当我们增加有效算子(指在该量子位上并非单位算符\u0026quot;Id\u0026quot;)的数量, 张量网络看上去就如同小车一般.\n上述语句均为强行解释.事实上这个算法来源于模拟哈密顿量动力学中的Trotter – Suzuki formula, Trotter到底是形容\u0026quot;小车\u0026quot;还是人名实际上并不太清楚.\n现在我们设想一个已经对于相邻的两个量子位的左/右都已经完成左/右规范化,那么现在要做的就是计算这两个相邻量子位上对应算符的期望值.\n和前面章节中处理二量子位的纠缠态类似, 我们可以将这两个量子位进行合并, 进行SVD分解, 再重组(至于是AD组合还是DB组合,可以根据自己需求来调整).\n注意: 这种算法仅适用于相邻量子位并不属于同一方向规范的情况(比如并不是两个正则位置, 而是在正则位置的同一边), 否则以截断SVD方法计算得到的结果并非全局最优.\nTrotter算法的精髓在于,将哈密顿量(也就是我们所用的算子)分解为若干个可以独立演化的小块, 而且如果哈密顿量是短程相互作用, 那么这种分解的效果就更好. 对于长程作用的哈密顿量Trotter算法的效率就会明显降低.在上面我们所举的例子里, 有效的哈密顿量仅涉及两个相邻的量子位, 可以说是符合短程的定义.\n如果哈密顿量中的相互作用都是短程的, 我们可以将哈密顿量分解为小块, 用自旋系统为例, 我们可以用这样的方程来描述:\n$$ \\begin{equation} \\hat{H}=\\hat{H_1}+\\hat{H_2}+\\hat{H_3}+\\dots \\\\ =\\sum_{j}\\hat{S_{j}}\\cdot\\hat{S_{j+1}} \\\\ =(\\hat{S_{1}}\\cdot\\hat{S_{2}})+(\\hat{S_{2}}\\cdot\\hat{S_{3}})+(\\hat{S_{3}}\\cdot\\hat{S_{4}})\\dots \\end{equation} $$\n那么假设系统演化了一极短的虚时间 $\\tau$,我们可以将系统的演化写作:\n$$ \\begin{aligned} e^{-\\tau\\hat{H}}\\approxeq \u0026amp;e^{-\\tau\\hat{H_1}/2}e^{-\\tau\\hat{H_2}/2}e^{-\\tau\\hat{H}_3/2}\\dots\\ \u0026amp;\\dots e^{-\\tau\\hat{H}_3/2}e^{-\\tau\\hat{H_2}/2}e^{-\\tau\\hat{H_1}/2}+O(\\tau^3) \\end{aligned} $$\n虚时演化\n对于一个一般的表达式 $|\\psi\u0026rsquo;\\rangle=e^{-\\tau\\hat{H}}|\\psi\\rangle$ (省略了 $\\hbar$ ),有两种情况:\n$\\tau$ 是实数, 那么相当于 $\\tau = i\\tau\u0026rsquo;$, 其中 $\\tau\u0026rsquo;$是虚时间. 那么我们只要执行足够多步, 就可以搜索到基态. $\\tau$ 是虚数, 那么就是一般的动力学表述, 相当于 $\\tau = it$, 原方程变为 $|\\psi\u0026rsquo;\\rangle=e^{-it\\hat{H}}|\\psi\\rangle$ 对于第一种情况, 有一种应用的例子, 即通过取 $\\beta/2=1/(2T)$ 的虚时演化来模拟有限温度.\n更详细的说, 就是取 $\\tau = \\frac{1}{k_BT}$ ,就相当于进行了一次虚时间演化. 在每一步执行完成后我们要对系统的状态进行记录, 从而对系统的在温度T下的性质进行统计平均.\n我们用.gif 来演示这一过程:\n因为我们每一步都只取了每个量子位对应分块哈密顿量的 $\\frac{1}{2}$ ,所以通过往返执行一遍可以不改变纠缠态的规范性.\nQuiz 5 解析 #include \u0026#34;itensor/all.h\u0026#34; #include \u0026#34;itensor/util/print_macro.h\u0026#34; using std::vector; using std::move; using namespace itensor; struct TGate{ int i1 = 0;int i2 = 0; //i1, i2是用来指定虚时演化算子中产生作用的两个自旋量子位编号 ITensor G; //G被声明为ITensor类型，用来存储具体的虚时演化算子值 TGate() { } TGate(int i1_, int i2_, ITensor G_) : i1(i1_), i2(i2_), G(G_) { } }; int main(){ int N = 20; auto sites = SpinHalf(N);//声明系统是20个1/2自旋子的系统 auto init = InitState(sites); for(auto n : range1(N)){ init.set(n, n%2 == 1 ? \u0026#34;Up\u0026#34; : \u0026#34;Dn\u0026#34;); }//并且将该系统初始化为Neel态(相邻自旋总相反) //将该状态init通过MPS()转译为矩阵乘积态(MPS)的形式 auto psi = MPS(init); //定义虚时演化的总时间和时间间隔(步长) Real ttotal = 2;Real tstep = 0.1; //检查时间步长和总时间是否合法 auto nt = int(ttotal/tstep+(1e-9*(ttotal/tstep))); if(std::fabs(nt*tstep-ttotal) \u0026gt; 1E-9){ Error(\u0026#34;Timestep not commensurate with total time\u0026#34;); } //Create Trotter gates (imaginary time) //定义数据类型为TGate的vector容器，用来存储虚时演化算子 auto gates = vector\u0026lt;TGate\u0026gt;{}; for(int b = 1; b \u0026lt; N; ++b){ //从头开始构建哈密顿量 auto hh = op(sites,\u0026#34;Sz\u0026#34;,b)*op(sites,\u0026#34;Sz\u0026#34;,b+1); hh += 0.5*op(sites,\u0026#34;Sp\u0026#34;,b)*op(sites,\u0026#34;Sm\u0026#34;,b+1); hh += 0.5*op(sites,\u0026#34;Sm\u0026#34;,b)*op(sites,\u0026#34;Sp\u0026#34;,b+1); //计算半步长的虚时演化算子 auto G = expHermitian(hh,-tstep/2.); //将虚时演化算子存储到名为gates的容器中(序列尾部) //b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置. gates.emplace_back(b,b+1,move(G)); } for(int b = N-1; b \u0026gt;= 1; --b){ //从尾开始构建哈密顿量 ITensor hh = op(sites,\u0026#34;Sz\u0026#34;,b)*op(sites,\u0026#34;Sz\u0026#34;,b+1); hh += 0.5*op(sites,\u0026#34;Sp\u0026#34;,b)*op(sites,\u0026#34;Sm\u0026#34;,b+1); hh += 0.5*op(sites,\u0026#34;Sm\u0026#34;,b)*op(sites,\u0026#34;Sp\u0026#34;,b+1); //计算半步长的虚时演化算子 auto G = expHermitian(hh,-tstep/2.); //将虚时演化算子存储到名为gates的容器中(序列尾部) //b在每个循环中都有一个值. 下面的b和b+1是指应用算子的位置. gates.emplace_back(b,b+1,move(G)); } for(int step = 1; step \u0026lt;= nt; ++step){ //将之前计算存储好的分块算子一一取出 for(auto\u0026amp; gate : gates){ //读取分块算子对应的作用位置 auto b = gate.i1; //读取分块算子的具体值 auto\u0026amp; G = gate.G; //设置正则位置为当前循环中的b psi.position(b); //将相邻量子位b和b+1合成为新张量AA auto AA = psi(b) * psi(b+1); // TODO: ADD CODE here that applies // the gate G to the MPS bond // tensor \u0026#34;AA\u0026#34; by multiplying // G and AA using the * operator // G is an ITensor // with index structure: // s_{b}\u0026#39; s_{b+1}\u0026#39; // | | // ======== // | | // s_{b} s_{b+1} // After applying G to AA, don\u0026#39;t forget // to reset the prime level to 0 by using // the noPrime method. //将G和AA相乘 AA *= G; AA.noPrime();//将AA的上标级别降为0, 因为SVD操作要求上标级别是一致的 //Normalize AA after applying G AA /= norm(AA); //SVD AA to restore MPS form auto [U,D,V] = svd(AA,inds(psi(b)),{\u0026#34;Cutoff\u0026#34;,1E-10}); psi.set(b,U); psi.set(b+1,D*V); } printfln(\u0026#34;Step %d/%d\u0026#34;,step,nt); } //Make Heisenberg H to //conveniently measure energy auto ampo = AutoMPO(sites); for(auto j : range1(N-1)){ ampo += 0.5,\u0026#34;S+\u0026#34;,j,\u0026#34;S-\u0026#34;,j+1; ampo += 0.5,\u0026#34;S-\u0026#34;,j,\u0026#34;S+\u0026#34;,j+1; ampo += \u0026#34;Sz\u0026#34;,j,\u0026#34;Sz\u0026#34;,j+1; } auto H = toMPO(ampo); printfln(\u0026#34;Energy = %.20f\u0026#34;,inner(psi,H,psi)); // Exact ground state energy of N=20 // Heisenberg model:E0 = -8.6824733306 return 0; } 编译执行后, 在终端输出的结果:\nStep 1/20 Step 2/20 Step 3/20 Step 4/20 Step 5/20 Step 6/20 Step 7/20 Step 8/20 Step 9/20 Step 10/20 Step 11/20 Step 12/20 Step 13/20 Step 14/20 Step 15/20 Step 16/20 Step 17/20 Step 18/20 Step 19/20 Step 20/20 Energy = -8.51422469470028886462 最后的结果和理论上计算得到的 $-8.6824733306$ 相差约为 $1.94%$, 可以说差距不大.\n矩阵乘积算子 MPO 我们已经知道, 在张量网络中, 一个哈密顿量 $\\hat{H}$ 看上去大概是这个样子:\n$$ \\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|}\\sum_{|}^{|} $$\n而一个对应量子位数的纠缠态波函数 $|\\Psi\\rangle$ 则是这样:\n$$ \\sum^{|}-\\sum^{|}-\\sum^{|}-\\sum^{|}-\\sum^{|} $$\n在上面的学习中我们已经知道, 要让 $\\hat{H}$ 作用到 $|\\Psi\\rangle$ 上, 其实就是将上下标进行结合的过程.\n那么既然 $|\\Psi\\rangle$ 能够写作矩阵乘积的形式, 我们自然也可以对 $\\hat{H}$ 进行同样的要求,将其化为张量网络中的这种形式:\n$$ \\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|}-\\sum_{|}^{|} $$\n我们取其中一个张量进行分析:\n$$ ^{1}-\\sum_{|_{4}}^{|^{3}}-^{2} $$\n这里面的$1$和$2$代表的时张量左右的指标, 而$3$和$4$代表的是张量上下的指标(通常和作用与某量子位或其它物理量有关). 多个这样的张量乘在一起就能化成矩阵乘积算子的形式.\n我们不妨用一个更具体的例子:\n$$\\hat{H} = \\begin{bmatrix} 0 \u0026amp; 1\\\\ \\end{bmatrix}_{A} \\begin{bmatrix} \\hat{I} \u0026amp; \\\\ \\hat{\\sigma}^{z} \u0026amp; \\hat{I}\\\\ \\end{bmatrix}_{B} \\begin{bmatrix} \\hat{I} \u0026amp; \\\\ \\hat{\\sigma}^{z} \u0026amp; \\hat{I}\\\\ \\end{bmatrix}_{C} \\begin{bmatrix} 1 \\\\ 0\\\\ \\end{bmatrix}_{D} $$\n在矩阵的右下角使用A B C D来进行标记.它们以张量网络画出的形式大概像这样:\n$$ \\sum{A}-\\sum_{|}^{|}{B}-\\sum_{|}^{|}{C}-\\sum{D} $$\n不难看出实际上A和B,以及C和D是能够各自结合形成新矩阵的, 我们写出相乘得到的结果:\n$$ \\hat{H} = \\begin{bmatrix} \\hat{\\sigma}^{z} \u0026amp; \\hat{I}\\\\ \\end{bmatrix}_{A\u0026rsquo;} \\begin{bmatrix} \\hat{I}\\\\ \\hat{\\sigma}^{z} \\\\ \\end{bmatrix}_{B\u0026rsquo;} $$\n在方程上我们这样表述:\n$$ \\hat{H} = \\hat{\\sigma_{1}}^{z}\\bigotimes\\hat{I_{2}} + \\hat{I_{1}}\\bigotimes\\hat{\\sigma_{2}}^{z} $$\n当然这一个式子我们还可以进行继续的简化, 完成最后一步的乘法:\n$$ \\hat{H} = \\hat{\\sigma_{1}}^{z}+\\hat{\\sigma_{2}}^{z} =\\sum_{i}\\hat{\\sigma_{i}}^{z} $$\n现在再动手算更复杂的例子.\n$$\\hat{H}= \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1\\\\ \\end{bmatrix} \\begin{bmatrix} \\hat{I} \u0026amp; \u0026amp; \\\\ \\hat{\\sigma}^{z} \u0026amp; \u0026amp; \\\\ -h\\hat{\\sigma}^{x} \u0026amp; \\hat{\\sigma}^{z} \u0026amp; \\hat{I}\\\\ \\end{bmatrix} \\begin{bmatrix} \\hat{I} \u0026amp; \u0026amp; \\\\ \\hat{\\sigma}^{z} \u0026amp; \u0026amp; \\\\ -h\\hat{\\sigma}^{x} \u0026amp; \\hat{\\sigma}^{z} \u0026amp; \\hat{I}\\\\ \\end{bmatrix} \\begin{bmatrix} 1\\\\ 0\\\\ 0\\\\ \\end{bmatrix} $$\n先算两边, 再算中间, 即有\n$$ \\hat{H}=[-h\\hat{\\sigma}^{x},\\hat{\\sigma}^{z},\\hat{I}][\\hat{I},\\hat{\\sigma}^{z},-h\\hat{\\sigma}^{x}]^{T}=\\sum_{j}\\hat{\\sigma_{j}}^{z}\\hat{\\sigma_{j+1}}^{z}-h\\hat{\\sigma_{j}}^{x} $$\n本章没有对应的Quiz\nDMRG 密度矩阵重整化群 警告\n以下部分内容, 可能仅适用于1D的情况, 虽然ITensor开发了一些基于基于DMRG算法的扩展用以应对二维情况下系统, 但是这些方法的实现复杂度通常较高, 需要较长的计算时间和更高的计算资源.\n如果你想要对二维系统进行计算, 请考虑使用PEPS(投影纠缠对态算法)或者MERA(Multi-scale Entanglement Renormalization Ansatz,多尺度嵌套正交模型)算法, 除了ITensor外你也可以考虑使用Qiskit, PyQuante等计算库, 从而实现基于哈密顿量对角化的能带计算.\n所以为什么要学ITensor呢? 直接用matlab模拟不就好了\n如果我们想要求解一维哈密顿量的基态, DMRG 将是最好的方法.\n方程式的形式如下:\n$\\hat{H}|\\Psi\\rangle = E|\\Psi\\rangle$\n其中 $\\hat{H}$ 和 $|\\Psi\\rangle$ 都化为对应量子位数的 矩阵乘积形式(MPO 和 MPS).\nMPS的构造中不只是用到了我们之前所学的SVD和ReGroup, 它还包括了一些我们没有提到的处理操作, 这些操作被统称为\u0026quot;规范化变换\u0026quot;, 比如对张量进行单位化(unitarization).\n这些处理是为了MPS在计算时具有良好性质, 比如计算物理量时具有最小误差.\nImporttant: MPS should be in definite gauge. I.e.most tensors unitary.\n就是在要求矩阵乘积态应当已经被规范化, 也就是大多数量子位的张量都是幺正的.\n幺正 Unitary\n幺正本身是一个线性代数里的概念, 在这里我们用更物理一些的语言来描述这个性质.\n如果一个算子 $\\hat{U}$ , 还有一个态矢量 $|\\psi\\rangle$ ,能够满足以下条件:\n$\\hat{U}|\\psi\\rangle\\neq 0$; $||\\hat{U}|\\psi\\rangle|| = ||\\psi\\rangle||$; $\\langle\\Phi|\\hat{U}|\\psi\\rangle = \\langle\\Phi|\\psi\\rangle$ 其中 $||\\psi\\rangle||$ 代表态势 $|\\psi\\rangle$ 的长度, 这个量可以通过求内积来得到. 那么我们就可以称这个算子是幺正的. 所以我们可以选定一个特定的位置(正则位置), 将其左右两边的张量全部都规范化处理, 从而定义出正交归一的基.\n这样, 我们就可以计算出期望值 $\\langle\\Psi|\\hat{H}|\\Psi\\rangle$ .其中 $|\\Psi\\rangle$ 和 $\\hat{H}$ 都是矩阵乘积形式. 按照我们前面所说的,\nMERA算法 Multi-scale Entanglement Renormalization Ansatz\n多尺度嵌套正交矩形模型. 这是对重整化群方法的扩展. MERA将系统分解为一系列的张量, 每个张量代表了系统不同尺度下的状态. 每个张量的大小表示该尺度的自由度数目.\n这些张量通过特定的变化相互连接, 从而形成具有分形结构的网络. 这样, 我们就可以将系统的纠缠结构表示为不同尺度上的简单张量网络.\n具体来说, 每个张量被分为两个部分, 即上部分和下部分. 上部分表示的是低尺度的信息, 下部分表示的是高尺度的信息. 通过重复应用加密和解密操作, 就可以得到不同尺度下的系统状态.\n","permalink":"https://Muatyz.github.io/posts/phy/calphy/itensor-mannual/","summary":"one site 单节点 Site 意指\u0026quot;节点\u0026quot;. 单节点的自旋为 $\\frac{1}{2}$ 的波函数,有两个基底. $|s=1\\rangle=|\\uparrow\\rangle;|s=2\\rangle=|\\downarrow\\rangle$ 对于一般的自旋为 $\\frac{1}{2}$ 的波函数,可以写成如下形式: $|\\psi\\rangle=\\sum_{s=1}^{2}\\psi_s|s\\rangle(\\psi_s\\in\\mathcal{C})$ 使用张量数学来处理这个单节点波函数, 即 $|\\psi_s\\rangle$ 对应一个有一个\u0026quot;触手\u0026quot;的结点.展开形式为 $(^{\\psi_1}_{\\psi_2})$ , $\\psi_1,\\psi_2$ 又各自是一个单\u0026quot;触手\u0026quot","title":"ITensor基础语法说明"},{"content":"在某文件夹下创建ITensor文件夹。在该文件夹内执行\ngit clone https://github.com/ITensor/ITensor itensor 得到以itensor命名的编译源文件。这个文件夹名字可以自己改。\n前置：安装lapack和blas依赖库. sudo apt-get update sudo apt-get install libblas-dev liblapack-dev 检验是否正确安装:\ndpkg -L libblas-dev dpkg -L liblapack-dev 若能弹出对应路径说明安装成功。在这里留心安装的具体路径, 之后设置BLAS_LAPACK_LIBFLAGS可能会用到\n在终端执行\ncd itensor 进入下载的库文件所在的文件夹.\ncp options.mk.sample options.mk 将示例mk文件另存为mk文件.并且执行\nsudo nano options.mk 以nano编辑器打开配置文件。配置文件里默认的平台是MacOS，我们用的是WSL2,所以将\nPLATFORM=macos BLAS_LAPACK_LIBFLAGS=-framework Accelerate 这两行注释掉，而将下面的\n#PLATFORM=lapack #BLAS_LAPACK_LIBFLAGS=-lpthread -L/usr/lib -lblas -llapack 取消注释。注意看自己的BLAS_LAPACK_LIBFLAGS是否需要修改.比如我的就应该是-L/usr/lib/x86_64-linux-gnu.ctrl+O，ENTER保存。ctrl+X退出。\n依然是在itensor目录下，在bash终端执行\nmake 等待终端执行完成。\n为了能够在ITensor源文件所在文件夹以外的路径使用Itensor, 应该遵循以下步骤。\n将itensor/tutorial/project_template下的所有文件(Makefile,myappname.cc,myclass.h,当然说明书README.md无关紧要)复制粘贴到含有main函数代码的cpp文件所在的文件夹中;\n修改LIBRARY_DIR.这个路径和options.mk所在的文件夹的路径是相同的.(如果有/mnt/e/wsl/ubuntu2204/cpp/itensorCalculation/ITensor/itensor/options.mk,那么就将\nLIBRARY_DIR=$(HOME)/itensor 改写为\nLIBRARY_DIR=/mnt/e/wsl/ubuntu2204/cpp/itensorCalculation/ITensor/itensor 即可;\n修改APPNAME.这个是你的程序的名字.我给自己的程序源文件主程序起名为ctnmodel.cc, 所以 APP=myappname 改为\nAPP=ctnmodel 增加依赖库.模板里的myclass.h是用来测试的,在实际过程中可以替换为自己的头文件;\n编译的源文件名字,只要完成了APP的修改就无需改动.\n然后在bash终端执行\nmake 编译出执行文件.\n注意\n示例的Makefile并没有添加可执行权限，如果你想在bash终端中进行执行，那么你可以\nchmod +x ctnmodel (ctnmodel换成你自己程序的名字)\n或者直接在你的Makefile里面找到build和debug的行， 然后分别添加\nchmod +x $(APP) 和\nchmod +x $(APP)-g 最后形成这样的表达：\nbuild: $(APP) #这一行是为了添加可执行权限，如果你不需要，可以将其注释掉 chmod +x $(APP) debug: $(APP)-g #同上 chmod +x $(APP)-g 你可以通过在终端执行\n./ctnmodel (ctnmodel换成你的程序的名字)来完成程序的执行.这些模板都是由Makefile来进行管理的,所以对于vscode的编译执行功能没有得到充分发挥.\n待续:vscode的配置.\n","permalink":"https://Muatyz.github.io/posts/phy/calphy/itensor-donwload/","summary":"在某文件夹下创建ITensor文件夹。在该文件夹内执行 git clone https://github.com/ITensor/ITensor itensor 得到以itensor命名的编译源文件。这个文件夹名字可以自己改。 前置：安装lapack和blas依赖库. sudo apt-get update sudo apt-get install libblas-dev liblapack-dev 检验是否正确安装: dpkg -L libblas-dev dpkg -L liblapack-dev 若能弹出对应路径说明安装成功。在这里留心安装的具体路径, 之后设置BL","title":"ITensor库安装说明"},{"content":"对于原子实和价电子体系, 我们可以这样描述哈密顿量 $\\hat{H}_{\\text{Total}}$(或者写作$\\hat{H}_{T}$):\n$$ \\hat{H}_{T} = \\underbrace{\\sum_{i}\\frac{|\\vec{p_{i}}|^2}{2m}}_{\\text{价电子动能}} + \\underbrace{\\sum_{n}\\frac{|\\vec{p_{n}}|^2}{2M_{n}}}_{原子实动能} + \\underbrace{\\frac{1}{2}\\sum_{ij}\u0026rsquo;\\frac{e^2}{|\\vec{r_{i}}-\\vec{r_{j}}|}}_{电子间库伦势} + \\underbrace{\\frac{1}{2}\\sum_{nn\u0026rsquo;}\u0026rsquo;\\frac{Z_{n}Z_{n\u0026rsquo;}e^{2}}{|\\vec{R_{n}}-\\vec{R_{n\u0026rsquo;}}|}}_{原子实间库伦势} + \\underbrace{\\sum_{n,i}V_{n}(\\vec{r_{i}}-\\vec{R_{n}})}_{电子和原子实之间的相互作用} + \\underbrace{\\hat{H}_{R}}_{相对论修正} $$\n$\\hat{H}_{R}$ 被称为 \u0026lsquo;Relativistic Corrections\u0026rsquo;, 包括了自旋-轨道的耦合项.\n我们已经知道 $N_{A}$~$10^{23}$, 对于这种量级的系统进行简单求解是不现实的.\nBorn-Oppenheimer Adiabatic Approximation(波恩-奥本海默绝热近似法)\n原子实质量远大于电子质量; 在典型固体中, 原子实表现为经典粒子; 电子形成了电子气; 原子实和电子的动能有数量级上的差异; 电子对原子实的运动有即时反应. 电子哈密顿量:\n$$ \\hat{H}_{e} = \\sum_{i}\\left[\\frac{|\\vec{p_{i}}|^2}{2m}+\\sum_{n}V_{n}(\\vec{r_{i}}-\\vec{R_{n}})\\right] + \\frac{1}{2}\\sum_{ij}\u0026rsquo;\\frac{e^{2}}{|\\vec{r_{i}}-\\vec{r_{j}}|} + \\hat{H}_{R} $$\n根据该哈密顿量可以解得能谱 $E_{e}^{l}(\\{\\vec{R_{n}}\\})$. 取 $l = 0$ 即为电子基态能量($E_{e}^{0}(\\{\\vec{R_{n}}\\})$).\n原子实的哈密顿量:\n$$ \\hat{H}_{c} = \\sum_{n}\\frac{|\\vec{p_{n}}|^2}{2M_{n}} + \\frac{1}{2} \\sum_{nn\u0026rsquo;}\u0026rsquo;\\frac{Z_{n}Z_{n\u0026rsquo;}e^2}{|\\vec{R_{n}}-\\vec{R_{n\u0026rsquo;}}|} + V_{\\text{ec}}(\\{\\vec{R_{n}}\\}) $$\n$V_{\\text{ec}}(\\{\\vec{R_{n}}\\})$ 是由 $E_{e}^{0}(\\{\\vec{R_{n}}\\})$ 确定的.\nB-O 绝热近似将电子和原子实的自由度分开了.\n非相对论效应下的多电子波函数方程:\n$$ \\left\\{-\\frac{\\hbar^{2}}{2m}\\sum_{j}\\nabla_{j}^{2}-\\sum_{j,l}\\frac{Z_{l}e^{2}}{|r_{j}-R_{l}|}+\\frac{1}{2}\\sum_{j\\neq j\u0026rsquo;}\\frac{e^{2}}{|r_{j}-r_{j\u0026rsquo;}|} - E\\right\\}\\Psi(r_{1},r_{2},\\cdots,r_{N}) = 0 $$\n根据泡利不相容原理, 有\n$$ \\hat{P}_{jj\u0026rsquo;}\\Psi = -\\Psi $$\n$\\hat{P}_{jj\u0026rsquo;}$ 表示交换电子 $j$ 和 $j\u0026rsquo;$ 的自旋和坐标.\n电子的所有性质都依赖于参数 $R_{l}$ (即原子实的位置). 所以我们将电子密度分布函数和能量函数写作:\n$$ n(r) = n(r;R_{1},\\dots,R_{\\mathcal{N}})\\\\ E = E(R_{1},\\dots,R_{\\mathcal{N}}) $$\n$\\mathcal{N}$ 表示原子实的数量, 应当和 $N$ 区分开.\n氢分子模型 实验数据 $$ D = 4.75\\mathrm{eV}, R = 0.740Å $$\nHeitler-London Estimation 定义波函数为\n$$ \\Psi_{HL} = A\\left[\\varphi_{H}(r_{1}-R_{1})\\varphi_{H}(r_{2}-R_{2})+\\varphi_{H}(r_{1}-R_{2})\\varphi_{H}(r_{2}-R_{1})\\right]\\chi_{0}\\\\ (\\text{HL = Heitler-London}) $$\n$\\varphi_{H}(r)$ 是电子轨道在基态的波函数; $\\chi_{0}$ 代表自旋单子波函数.\n该式满足分子的反射对称性以及泡利原理.\n计算得出的结果为\n$$ D\u0026rsquo; = 3.14\\mathrm{eV}, R\u0026rsquo; = 0.87Å $$\nMullikan Ansatz 该定理是一种 Hatree-Fock 近似, 我们可以将其\n$$ \\Psi_{\\text{HF}} = \\frac{1}{\\sqrt{2}}\\mathrm{Det}[\\varphi_{m}(r_{1})\\alpha(1)\\varphi_{m}(r_{2})\\beta(2)]\\\\ (\\text{HF = Hatree-Fock}) $$\n该方法给出的数值为\n$$ D\u0026rsquo;\u0026rsquo; = 3.63\\mathrm{eV}, R\u0026rsquo;\u0026rsquo; = 0.74Å $$\nJames-Coolidge Approximation $$ \\Psi_{JC} = \\Psi(r_{1},r_{2})\\chi_{0} $$\n$\\Psi(r_{1},r_{2})$ 是对 $r_{1},r_{2}$ 归一化的函数, 服从分子的空间对称性.\n试探波函数 $\\Psi$ 依赖于参数 $p_{1},p_{2},\\dots, p_{m}$. 所以能量的期望值也依赖于这些参数而有 $E = E(p_{1},\\dots,p_{m})$.\n如果我们取 $M=13$, 那么就会得出:\n$$ D\u0026rsquo;\u0026rsquo;\u0026rsquo; = 4.70\\mathrm{eV}, R\u0026rsquo;\u0026rsquo;\u0026rsquo;= 0.74Å $$\n相比于前面所作的努力, 这个结果已经非常接近实验值了.\n如果我们要得到真正满意的数值结果, 我们就需要进一步增大 M.\n对于 $\\Psi(r_{1},r_{2})$, 所需要的连续变量为 $6 - 1 = 5$; 每个变量要达到指定精度所需要的参数数量是 $p$.\n我们要求能量精度为 $O(10^{-2})$, 波函数精度为 $O(10^{-1})$. 所以我们猜测对应的 $p$ 需要满足 $3\\leq p\\leq 10$, 所以\n$$ M = p^{5}\\in [3^{5},10^{5}] \\approx [10^{2}, 10^{5}] $$\n这仍然是一个非常大的数值, 通过估算我们可以知道这种方法仅适用于化学活性电子较少的分子(即 $N\\leq O(10)$).\nKohn Provocative Statement(科恩判别陈述)\n对于一 $N$ 电子体系的多电子波函数 $\\Psi(r_{1},\\dots,r_{N})$, 当 $N\\geq 10^{3}$ 时, 该波函数不是一个有效的描述.\n**\u0026ldquo;有效\u0026rdquo;**的含义\n$\\Psi$ 可以在足够精度要求下计算; $\\Psi(r_{1},\\dots,r_{N})$ 可以在足够精度下记录. 对于更大的情形, 我们需要使用一些数学技巧和近似方法来削减这种指数增长的参数要求.\nExponential Wall\n构造波函数\n考虑一个 $\\mathcal{N}$ 原子实- $n$ 电子体系, 精确波函数为 $\\psi_{l}(r_{1},\\dots,r_{n})$, 近似波函数为 $\\widetilde{\\psi}_{l}(r_{1},\\dots,r_{2})$. 已知取 $n = 10$ 时, 有误差 $$ |(\\widetilde{\\psi}_{l},\\psi_{l})| = 1 - \\epsilon, \\epsilon = 10^{-2} $$\n$\\mathcal{N} = 10^{2}, N_{e} = 10^3$, 即有 $$ (\\widetilde{\\Psi},\\Psi) = (1 - \\epsilon)^{\\mathcal{N}} \\approx e^{-\\mathcal{N}\\epsilon}\\approx e^{-1} \\approx 0.37 $$ 电子数为 $N_{e} = 10^4$, $$ (\\widetilde{\\Psi},\\Psi) \\approx e^{-10}\\approx 5\\times 10^{-5} $$ 记录波函数\n如果每个变量需要 $q$ 个 bit 来记录, 那么总共所需要的 bit 数量为 $B = q^{3N}$ 这是一个极大的数字, 比如当 $q = 3, N = 10^3$, 那么 $B\\approx 10^{1431}$\n我们真正关心的量, 比如 $E, n(r), g(r,r\u0026rsquo;)$, 实际上并不需要那么多的变量才能计算.\nHartree-Fock Approximation 密度泛函理论(Density Functional Theory, DFT)是从 $N$ 粒子薛定谔方程导出的, 而具体的形式又根据其采用的方法而不同.\nHoner-Kohn 公式. 使用 $n(r)$ 项表述; Kohn-Sham 公式. 使用 $n(r)$ 和 单粒子波函数 $\\psi_{j}(r)$ 表述. 对于电子部分的自由度, 我们可以写出\n$$ \\hat{H} = -\\sum_{i}\\frac{\\hbar^2}{2m_{e}}\\nabla_{vec{r_{i}}}^{2} + \\sum_{i}V_{\\text{ion}}(\\vec{r_{i}}) + \\frac{e^2}{2}\\sum_{ij(i\\neq j)}\\frac{1}{|\\vec{r_{i}}-\\vec{r_{j}}|} $$\n又有对于多体波函数, 我们假设各单体波函数可以进行简单乘积:\n$$ \\Psi^{H}(\\{\\vec{r}_{i}\\}) = \\phi_{1}(\\vec{r}_{1})\\phi_{2}(\\vec{r}_{2})\\dots\\phi_{N}(\\vec{r}_{N}) $$\n所以我们可以表示系统的总能量为:\n$$ E^{H} = \\left\\langle\\Psi^{H}\\left|\\hat{H}\\right|\\Psi^{H}\\right\\rangle = \\sum_{i}\\left\\langle\\phi_{i}\\left|\\frac{-\\hbar^{2}\\nabla_{\\vec{r}}^2}{2m_{e}} + V_{\\text{ion}}(\\vec{r})\\right|\\phi_{i}\\right\\rangle + \\frac{e^{2}}{2}\\sum_{ij(i\\neq j)}\\left\\langle\\phi_{i}\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{i}\\phi_{j}\\right\\rangle $$\n假定 Hatree 波函数是系统稳态, 而且正交归一的, 那么我们对能量进行变分:\n$$ \\delta\\left[E^{H}- \\sum_{i}\\epsilon_{i}(\\langle\\phi_{i}|\\phi_{i}\\rangle-1)\\right] = 0 $$\n将上面这个式子展开:\n$$ \\left\\langle\\delta\\phi_{i}\\left|-\\frac{\\hbar^2\\nabla_{\\vec{r}}^2}{2m_{e}}+V_{\\text{ion}}(\\vec{r})\\right|\\phi_{i}\\right\\rangle + e^{2}\\sum_{i\\neq j}\\left\\langle\\delta\\phi_{i}\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{i}\\phi_{j}\\right\\rangle - \\epsilon_{i}\\langle\\delta\\phi_{i}|\\phi_{i}\\rangle\\\\ = \\left\\langle\\delta\\phi_{i}\\left|\\left[-\\frac{\\hbar^2\\nabla_{\\vec{r}}^2}{2m_{e}}+V_{\\text{ion}}+e^2\\sum_{i\\neq j}\\left\\langle\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{j}\\right\\rangle-\\epsilon\\right]\\right|\\phi_{i}\\right\\rangle = 0 $$\n所以我们就有了单粒子的 Hatree 方程:\n$$ \\left[-\\frac{\\hbar^2\\nabla{\\vec{r}}^{2}}{2m_{e}}+V_{\\text{ion}}(\\vec{r})+e^2\\sum_{j\\neq i}\\left\\langle\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{i}\\right\\rangle\\right]\\phi_{i}(\\vec{r}) = \\epsilon_{i}\\phi_{i}(\\vec{r}) $$\n这些常数 $\\epsilon_{i}$ 就是拉格朗日乘子.\n拉格朗日乘子法 要求$f(x,y)$ 在 $g(x,y) = 0$ 约束下取得局部极值, 可以通过引入拉格朗日乘数 $\\lambda$ 来辅助实现.\n问题就转化为了求\n$$ \\mathcal{L}(x,y,\\lambda) = f(x,y) - \\lambda\\cdot g(x,y) $$\n的极值.\n更一般的, 有\n$$ \\mathcal{L}(x_{1},\\dots,x_{n},\\lambda_{1},\\dots,\\lambda_{k}) = f(x_{1},\\dots,x_{n})-\\sum_{i = 1}^{k}\\lambda_{i}g_{i}(x_{1},\\dots,x_{n}) $$\nHatree 势的出现是因为其余全体电子的存在:\n$$ V_{i}^{H}(\\vec{r}) = e^2\\sum_{i\\neq j}\\left\\langle\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{j}\\right\\rangle $$\n如果已知单个轨道波函数 $\\phi_{i}(\\vec{r}_{i})$, 那么我们就可以解对应的单粒子薛定谔方程来确定任意一个 $\\phi_{j}(\\vec{r}_{j})$\n自洽性问题可以通过迭代的思路来解决, 下面是伪代码:\n自洽性问题证明 选取初始轨道 $\\phi_{i}^{(in)}(\\vec{r})$;\n计算 $\\rho^{(in)}(\\vec{r}) = \\sum_{i}|\\phi_{i}^{(in)}(\\vec{r})|^2, V^{sp}(\\vec{r},\\rho^{(in)}(\\vec{r}))$;\n求解薛定谔方程 $$ \\left[-\\frac{\\hbar^2\\nabla_{\\vec{r}}^{2}}{2m_{e}}+V^{sp}(\\vec{r},\\rho^{(in)}(\\vec{r}))\\right]\\phi_{i}^{(out)}(\\vec{r}) = \\epsilon_{i}^{(out)}\\phi_{i}^{(out)}(\\vec{r}) $$\n计算新的电荷密度 $\\rho^{(out)}(\\vec{r}) = \\sum_{i}|\\phi_{i}^{(out)}(\\vec{r})|^2$;\n若 $|\\rho^{(in)}(\\vec{r})-\\rho^{(out)}(\\vec{r})|\u0026lt;\\delta_{tol}$, 停止迭代;\n否则, 令 $\\phi_{i}^{(in)} = \\phi_{i}^{(out)}$, 回到步骤2.\n对于每个粒子而言, 对应的势都是不同的. 所以我们实际上是做了一种 平均场近似, 只考虑了电子电荷. 这无疑是一种很强的简化.\n接下来我们要引入电子的费米子特性, 在多体全同性和对称性中我们已经介绍了有关于 Slater Determinant(斯莱特行列式) 的内容.\n所以我们把 Hatree-Fock 多体波函数写作:\n$$ \\Psi^{\\text{HF}}(\\{\\vec{r}_{i}\\}) = \\frac{1}{\\sqrt{N!}} \\left| \\begin{array}{cccc} \\phi_{1}(\\vec{r}_{1}) \u0026amp; \\phi_{1}(\\vec{r}_{2}) \u0026amp; \\cdots \u0026amp; \\phi_{1}(\\vec{r}_{N}) \\\\ \\phi_{2}(\\vec{r}_{1}) \u0026amp; \\phi_{2}(\\vec{r}_{2}) \u0026amp; \\cdots \u0026amp; \\phi_{2}(\\vec{r}_{N}) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ \\phi_{N}(\\vec{r}_{1}) \u0026amp; \\phi_{N}(\\vec{r}_{2}) \u0026amp; \\cdots \u0026amp; \\phi_{N}(\\vec{r}_{N}) \\\\ \\end{array} \\right|. $$\n$\\phi_{i}$ 是单粒子的轨道波函数, 是需要计算得到的. 可以将其理解为\n$$ \\phi_{i}(\\vec{r}) \\approx \\psi_{i}(\\vec{r})\\chi_{i}(\\sigma) $$\n有了多体波函数, 我们就可以求得总能量:\n$$ E^{\\text{HF}} = \\langle\\Psi^{\\text{HF}}|\\hat{H}|\\Psi^{\\text{HF}}\\rangle\\\\ = \\sum_{i}\\left\\langle\\phi_{i}\\left|\\frac{-\\hbar^2\\nabla_{\\vec{r}}^{2}}{2m_{e}}+V_{\\text{ion}}(\\vec{r})\\right|\\phi_{i}\\right\\rangle + \\frac{e^{2}}{2}\\sum_{ij(i\\neq j)}\\left\\langle\\phi_{i}\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{i}\\phi_{j}\\right\\rangle - \\frac{e^2}{2}\\sum_{ij(i\\neq j)}\\left\\langle\\phi_{i}\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{j}\\phi_{i}\\right\\rangle $$\n整理之后使用变分法, 即可得到单粒子的 Hatree-Fock 方程:\n$$ \\left[\\frac{-\\hbar^2\\nabla_{\\vec{r}}^{2}}{2m_{e}}+V_{\\text{ion}}+V_{i}^{H}(\\vec{r})\\right]\\phi_{i}(\\vec{r}) - e^2\\sum_{j\\neq i}\\left\\langle\\phi_{j}\\left|\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\right|\\phi_{i}\\right\\rangle\\phi_{j}(\\vec{r})=\\epsilon_{i}\\phi_{i}(\\vec{r}) $$\n交换项产生于多费米子波函数的反对称性质.\n我们定义单粒子的密度分布和总密度为:\n$$ \\rho_{i}(\\vec{r}) = |\\phi_{i}(\\vec{r})|^2\\\\ \\rho(\\vec{r}) = \\sum_{i}\\rho_{i}(\\vec{r}) $$\n将密度引入到我们前面得出的式子:\n$$ V_{i}^{H}(\\vec{r}) = e^{2}\\sum_{j\\neq i}\\int\\frac{\\rho_{j}(\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo; = e^{2}\\int\\frac{\\rho(\\vec{r}\u0026rsquo;)-\\rho_{i}(\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo; $$\n单粒子交换密度:\n$$ \\rho_{i}^{X}(\\vec{r},\\vec{r}\u0026rsquo;) = \\sum_{j\\neq i}\\frac{\\phi_{i}(\\vec{r}\u0026rsquo;)\\phi_{i}^{*}(\\vec{r})\\phi_{j}(\\vec{r})\\phi_{j}^{*}(\\vec{r}\u0026rsquo;)}{\\phi_{i}(\\vec{r})\\phi_{i}^{*}(\\vec{r})} $$\n所以就得到 Hatree-Fock 势:\n$$ V_{i}^{HF}(\\vec{r}) = \\underbrace{e^{2}\\int\\frac{\\rho(\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;}_{\\text{经典库仑排斥势(所有态下共有)}} - \\underbrace{e^2\\int\\frac{\\rho_{i}(\\vec{r}\u0026rsquo;)+\\rho_{i}^{X}(\\vec{r},\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;}_{\\text{费米子交换效应(每个态都不同)}} $$\n根据 Hatree-Fock 密度得到的式子:\n$$ \\rho_{i}^{HF}(\\vec{r},\\vec{r}\u0026rsquo;) = \\sum_{j}\\frac{\\phi_{i}(\\vec{r}\u0026rsquo;)\\phi_{i}^{*}(\\vec{r})\\phi_{j}(\\vec{r})\\phi_{j}^{*}(\\vec{r}\u0026rsquo;)}{\\phi_{i}(\\vec{r})\\phi_{i}^{*}(\\vec{r})}\\\\ V_{i}^{HF}(\\vec{r}) = e^2\\int\\frac{\\rho(\\vec{r}\u0026rsquo;)-\\rho_{i}^{HF}(\\vec{r},\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}' $$\n所以最后的单粒子 Hatree-Fock 方程为:\n$$ \\left[\\frac{-\\hbar^2\\nabla_{\\vec{r}}^{2}}{2m_{e}}+V_{ion}(\\vec{r})+V_{i}^{HF}(\\vec{r})\\right]\\phi_{i}(\\vec{r}) = \\epsilon_{i}\\phi_{i}(\\vec{r}) $$\n均匀电子气(Uniform Electron Gas) Jellium Model\n均匀正离子背景; 均匀电子气体. 在以上假设下, 可以将电子态写作平面波形式:\n$$ \\phi_{i}(\\vec{r}) = \\frac{1}{\\sqrt{\\Omega}}e^{i\\vec{k}_{i}\\cdot\\vec{r}} $$\n$\\Omega$ 为晶胞体积. 均匀电子气的波矢的数值范围为 $k\\in[0,k_{F}]$, $k_{F}$ 即为费米动量.\n费米能级 $\\epsilon_{F} = \\frac{\\hbar^{2}k_{F}^{2}}{2m_{e}}$.\n快速复习费米动量 三维的 $K$ 空间下的每个体积元 $(\\frac{2\\pi}{L})^{2}$ 中存在一个波矢 $(k_{x},k_{y},k_{z})$, 根据费米球和泡利不相容原理, 可以有 $$ 2\\cdot\\frac{4\\pi k_{F}^{3}/3}{(2\\pi/L)^{3}} = N\\\\ \\Rightarrow k_{F} = \\left(\\frac{3\\pi^{2}N}{V}\\right)^{1/3}=(3\\pi^{2}n)^{1/3} $$ 我们引入一个参数 $r_{s}$, 它来自于以下方程:\n$$ \\frac{4\\pi}{3}r_{s} = \\frac{\\Omega}{N} = n^{-1} = \\frac{3\\pi^2}{k_{F}^{3}} $$\n以及新的能量单位 $\\text{Ry}$:\n$$ \\frac{\\hbar^{2}}{2m_{e}a_{0}^{2}} = \\frac{e^{2}}{2a_{0}} = 1\\mathrm{Ry} $$\n$a_{0}$ 是玻尔半径.\n我们假设电子气的电荷和正离子的电荷总量相同, 又因为是均匀的, 所以整体呈现电中性. 那么波函数方程就特化为\n$$ \\left[-\\frac{\\hbar^{2}\\nabla_{\\vec{r}}^{2}}{2m_{e}}-e^{2}\\int\\frac{\\rho_{\\vec{k}}^{HF}(\\vec{r},\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;\\right]\\phi_{\\vec{k}}(\\vec{r}) = \\epsilon_{\\vec{k}}\\phi_{\\vec{k}}(\\vec{r}) $$\n证明行波为特征根 $$ -\\frac{\\hbar^{2}\\nabla^{2}}{2m_{e}}\\frac{1}{\\sqrt{\\Omega}}e^{i\\vec{k}\\cdot\\vec{r}} = \\frac{\\hbar^{2}\\hat{k}^{2}}{2m_{e}}\\frac{1}{\\sqrt{\\Omega}}e^{i\\vec{k}\\cdot\\vec{r}}\\\\ e^{2}\\left[\\int\\frac{\\rho_{\\vec{k}}^{HF}(\\vec{r},\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;\\right]\\phi_{\\vec{k}}(\\vec{r}) = \\frac{-e^{2}}{\\sqrt{\\Omega}}\\int\\frac{\\rho_{\\vec{k}}^{HF}(\\vec{r},\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;e^{i\\vec{k}\\cdot\\vec{r}}\\\\ =\\frac{-e^{2}}{\\sqrt{\\Omega}}\\sum_{\\vec{k}\u0026rsquo;}\\int\\frac{\\phi_{\\vec{k}}(\\vec{r}\u0026rsquo;)\\phi_{\\vec{k}}^{*}(\\vec{r})\\phi_{\\vec{k}\u0026rsquo;}(\\vec{r})\\phi_{\\vec{k}\u0026rsquo;}^{*}(\\vec{r}\u0026rsquo;)}{\\phi_{\\vec{k}}(\\vec{r})\\phi_{\\vec{k}}^{*}(\\vec{r})}\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;e^{i\\vec{k}\\cdot\\vec{r}}\\\\ = \\frac{-e^{2}}{\\sqrt{\\Omega}}\\sum_{\\vec{k}\u0026rsquo;}\\int\\frac{e^{-i(\\vec{k}-\\vec{k}\u0026rsquo;)\\cdot(\\vec{r}-\\vec{r}\u0026rsquo;)}}{\\Omega}\\frac{1}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo;e^{i\\vec{k}\\cdot\\vec{r}} $$ 根据常用积分公式和傅里叶变换公式 $$ \\int\\frac{1}{r}e^{i\\vec{k}\\cdot\\vec{r}}\\mathrm{d}\\vec{r} = \\frac{4\\pi^2}{k^{2}}\\\\ \\sum_{\\vec{k}}f(\\vec{k}) = \\frac{\\Omega}{(2\\pi)^{3}}\\int f(\\vec{k})\\mathrm{d}\\vec{k} $$ 即有 $$ \\frac{-4\\pi^{2}}{\\sqrt{\\Omega}}\\left[\\int_{k\u0026rsquo;\u0026lt;k_{F}}\\frac{\\mathrm{d}\\vec{k}\u0026rsquo;}{(2\\pi)^3}\\frac{1}{|\\vec{k}-\\vec{k}\u0026rsquo;|^{2}}\\right]e^{i\\vec{k}\\cdot\\vec{r}} = -\\frac{e^{2}}{\\pi}k_{F}F\\left(\\frac{k}{k_{F}}\\right)\\frac{1}{\\sqrt{\\Omega}}e^{i\\vec{k}\\cdot\\vec{r}} $$\n$$ F(x) = 1 + \\frac{1 - x^2}{2x}\\ln{\\left|\\frac{1+x}{1-x}\\right|} $$\n即有平面波为单粒子 Hatree-Fock 哈密顿量的本征态.\n单粒子态 $\\phi_{\\vec{k}}(\\vec{r})$ 的能量为\n$$ \\epsilon_{\\vec{k}} = \\frac{\\hbar^{2}k^{2}}{2m_{e}} - \\frac{e^{2}}{\\pi} F\\left(\\frac{k}{k_{F}}\\right) $$\n可以看出, 该式相比于无相互作用的电子能量更低一些. 电子-电子相互作用实际上是大大降低了系统的能量.\n$$ E^{HF} = 2\\sum_{k\u0026lt;k_{F}}\\frac{\\hbar^{2}|\\vec{k}|^{2}}{2m_{e}} - \\frac{e^{2}k_{F}^{2}}{\\pi}\\sum_{k\u0026lt;k_{F}}\\left[1+ \\frac{k_{F}^{2}-k^{2}}{2kk_{F}}\\ln{\\left|\\frac{k_{F}+k}{k_{F}-k}\\right|}\\right] $$\n系数 $2$ 来自于电子的自旋, 第二项是因为每个粒子被计数了两边所以需要乘上 $1/2$.\n两边同时除以 $N$:\n$$ \\frac{E^{HF}}{N} = \\frac{3}{5}\\epsilon_{F} = \\frac{3}{4}\\frac{e^{2}k_{F}}{\\pi} $$\n如果要用 $r_{s}$ 和 $\\mathrm{Ry}$ 来表述, 那么以上形式就演化为\n$$ \\frac{E^{HF}}{N} = \\left[\\frac{2.21}{(r_{s}/a_{0})^{2}}\\underbrace{-\\frac{0.916}{(r_{s}/a_{0})}}_{\\text{均匀电子气的交换能}}\\right]\\mathrm{Ry} $$\n均匀电子气交换能的另一种写法: $$ \\frac{E^{X}}{N} = -\\frac{3e^{2}}{4}\\left(\\frac{3}{\\pi}\\right)^{\\frac{1}{3}}n^{\\frac{1}{3}} = -1.447(a_{0}^{3}n)^{\\frac{1}{3}}\\mathrm{Ry} $$\n在高密度极限下(即 $r_{s}$ 很小), 动能将会占据主导地位. 所以我们希望基态的能量能够以 $r_{s}$ 进行级数展开.\nGell-Mann \u0026amp; Brueckner Approximation($r_{s}\u0026lt;1$)\n$$ \\frac{E}{N} = \\left[\\frac{2.21}{(r_{s}/a_{0})^{2}}-\\frac{0.916}{(r_{s}/a_{0})}+0.0622\\ln{\\frac{r_{s}}{a_{0}}}-0.096+\\mathcal{O}\\left(\\frac{r_{s}}{a_{0}}\\right)\\right] $$\nDensity Functional Theory 除了处理求解多体波函数 $\\Psi(\\{\\vec{r}_{i}\\})$ 对应的多体薛定谔方程, 还可以从电子总密度分布 $n(\\vec{r})$ 入手. 该思想基于这样一种假设:\n基态的电子总密度分布 $n(\\vec{r})$ 由外部电势 $V(\\vec{r})$ (和离子电势有关)唯一确定.\n电势唯一性定理证明 假设 $V(\\vec{r})$ 和 $V\u0026rsquo;(\\vec{r})$ 不同, 且能够得到相同的电子密度分布 $n(\\vec{r})$.\n$$ E = \\langle\\Psi|\\mathcal{H}|\\Psi\\rangle\\\\ E\u0026rsquo; = \\langle\\Psi\u0026rsquo;|\\mathcal{H}\u0026rsquo;|\\Psi\u0026rsquo;\\rangle $$\n根据变分法, 有 $$ E \u0026lt; \\langle\\Psi\u0026rsquo;|\\mathcal{H}|\\Psi\u0026rsquo;\\rangle = \\langle\\Psi\u0026rsquo;|\\mathcal{H} + V\u0026rsquo; - V\u0026rsquo;|\\Psi\u0026rsquo;\\rangle = \\langle\\Psi\u0026rsquo;|\\mathcal{H}\u0026rsquo;+ V - V\u0026rsquo;|\\Psi\u0026rsquo;\\rangle \\\\ = \\langle\\Psi\u0026rsquo;|\\mathcal{H}\u0026rsquo;|\\Psi\u0026rsquo;\\rangle + \\langle\\Psi\u0026rsquo;|(V-V\u0026rsquo;)|\\Psi\u0026rsquo;\\rangle \\\\ = E\u0026rsquo; + \\langle\\Psi\u0026rsquo;|(V-V\u0026rsquo;)|\\Psi\u0026rsquo;\\rangle $$\n同理可以得到\n$$ E\u0026rsquo; \u0026lt; E - \\langle\\Psi|(V-V\u0026rsquo;)|\\Psi\\rangle $$\n将两个不等式同向相加, 即有\n$$ (E + E\u0026rsquo;) \u0026lt; (E + E\u0026rsquo;) + \\underbrace{\\langle\\Psi\u0026rsquo;|(V-V\u0026rsquo;)|\\Psi\u0026rsquo;\\rangle - \\langle\\Psi|(V-V\u0026rsquo;)|\\Psi\\rangle}_{(*)} $$\n其中的 $(*)$ 得到\n$$ \\int n\u0026rsquo;(\\vec{r})[V(\\vec{r})V\u0026rsquo;(\\vec{r})]\\mathrm{d}\\vec{r}- \\int n(\\vec{r})[V(\\vec{r})-V\u0026rsquo;(\\vec{r})]\\mathrm{d}\\vec{r} $$\n因为我们假设了 $n(\\vec{r}) = n\u0026rsquo;(\\vec{r})$, 所以 $(*)=0$, 对于不等式而言是荒谬的.\n所以我们就得出结论: 电子总密度分布 $n(\\vec{r})$ 由外部电势 $V(\\vec{r})$ (和离子电势有关)唯一确定.\n对于一般的哈密顿量 $\\mathcal{H}$, 可以写出通用形式\n$$ \\mathcal{H} = \\underbrace{-\\sum_{i}\\frac{\\hbar^{2}}{2m_{e}}\\nabla_{\\vec{r}_{i}}^{2}}_{T} + \\underbrace{\\sum_{i}V_{\\text{ion}}(\\vec{r}_{i})}_{W} + \\underbrace{\\frac{e^{2}}{2}\\sum_{ij(j\\neq i)}\\frac{1}{|\\vec{r}_{i}-\\vec{r}_{j}|}}_{V} $$\n我们可以写出对密度的泛函(Functional):\n$$ F[n(r)] = \\langle\\Psi|T + W|\\Psi\\rangle $$\n系统的总能量也是对密度的泛函:\n$$ E[n(\\vec{r})] = \\langle\\Psi|\\mathcal{H}|\\Psi\\rangle = F[n(\\vec{r})] + \\int V(\\vec{r})n(\\vec{r})\\mathrm{d}\\vec{r} $$\n根据变分法, 这个函数在正确的电子密度分布 $n(\\vec{r})$ 下取得最小值.\n$$ E[n\u0026rsquo;(\\vec{r})] = \\langle\\Psi\u0026rsquo;|\\mathcal{H}|\\Psi\u0026rsquo;\\rangle=F[n\u0026rsquo;(\\vec{r})]+\\int V(\\vec{r})n\u0026rsquo;(\\vec{r})\\mathrm{d}\\vec{r}\u0026gt; \\langle\\Psi|\\mathcal{H}|\\Psi\\rangle = E[n(\\vec{r})] $$\n我们假定, 存在一群这样的电子:\n虚构的费米子, 但是密度分布与真是电子的密度分布相同; 彼此之间没有相互作用, 因此可以做直积(从而使用我们熟知的 Slater Determinant). 我们就可以将 $F[n(\\vec{r})]$ 写作以下形式:\n$$ F[n(\\vec{r})] = \\underbrace{T^{S}[n(\\vec{r})]}_{\\text{行列式态动能}} + \\underbrace{\\frac{e^{2}}{2}\\int\\int\\frac{n(\\vec{r})n(\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\\mathrm{d}\\vec{r}\u0026rsquo;}_{\\text{经典库伦相互作用}} + \\underbrace{E^{XC}[n(\\vec{r})]}_{\\text{交换相关能}} $$\n该式完整表现了多体电子系统的效应.\n现在取密度的虚微分\n$$ \\delta n(\\vec{r}) = \\delta\\phi_{i}^{*}(\\vec{r})\\phi_{i}(\\vec{r}) $$\n并且该虚微分满足约束条件\n$$ \\int\\delta n(\\vec{r})\\mathrm{d}\\vec{r} = \\int\\delta\\phi_{i}^{*}(\\vec{r})\\phi_{i}(\\vec{r})\\mathrm{d\\vec{r}} = 0 $$\n就得到了 Kohn-Sham 方程:\n$$ \\left[-\\frac{\\hbar^{2}}{2m_{e}}\\nabla_{\\vec{r}}^{2}+V^{\\text{eff}}(\\vec{r},n(\\vec{r}))\\right]\\phi_{i}(\\vec{r}) = \\epsilon_{i}\\phi_{i}(\\vec{r}) $$\n有效势 $$ V^{\\text{eff}}(\\vec{r},n(\\vec{r})) = V(\\vec{r}) + e^{2}\\int\\frac{n(\\vec{r}\u0026rsquo;)}{|\\vec{r}-\\vec{r}\u0026rsquo;|}\\mathrm{d}\\vec{r}\u0026rsquo; + \\frac{\\delta E^{XC}[n(\\vec{r})]}{\\delta n(\\vec{r})} $$\n单粒子轨道波函数 $\\phi_{i}(\\vec{r})$ 是 Kohn-Sham 方程的解, 因此也被称为 Kohn-Sham 轨道.\n如果 $E^{XC}[n(\\vec{r})]$ 已知, 那么 Kohn-Sham 方程的自洽解将会给出电子密度和基态能量的精确解, 并且这个解是以系统中原子坐标为自变量的函数.\n一般的近似 $E^{XC}[n(\\vec{r})]$ 的方法是\n$$ E^{XC}[n(\\vec{r})] = \\int n(\\vec{r})\\epsilon^{XC}([n],\\vec{r})\\mathrm{d}\\vec{r} $$\n$\\epsilon^{XC}([n],\\vec{r})$ 是交换相关能密度.\n从以上式子分支出两种处理方法:\n局域密度近似(LDA, Local Density Approximation); $$ E^{XC}_{\\text{LDA}} = \\int\\epsilon^{XC}[n(\\vec{r})]n(\\vec{r})\\mathrm{d}\\vec{r} $$\n广义梯度近似(GGA, Generalized Gradient Approximation). $$ E^{XC}_{\\text{GGA}} = \\int\\epsilon^{XC}\\left[n(\\vec{r}),|\\nabla n(\\vec{r})|\\right]n(\\vec{r})\\mathrm{d}\\vec{r} $$\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/density-generalized-function-theory/","summary":"对于原子实和价电子体系, 我们可以这样描述哈密顿量 $\\hat{H}_{\\text{Total}}$(或者写作$\\hat{H}_{T}$): $$ \\hat{H}_{T} = \\underbrace{\\sum_{i}\\frac{|\\vec{p_{i}}|^2}{2m}}_{\\text{价电子动能}} + \\under","title":"多体: 密度泛函理论"},{"content":"","permalink":"https://Muatyz.github.io/posts/phy/cmp/mera-method/","summary":"","title":"发源于重整化(Renormalization)的MERA算法"},{"content":"Dirac Notation 狄拉克符号利用 \u0026lsquo;$\\langle$\u0026rsquo;(Bra, 左矢) 和 \u0026lsquo;$\\rangle$\u0026rsquo;(Ket, 右矢)语言来对常规的量子力学中的概念进行替换.\n方程语言 Dirac Notation Wave Function $\\psi$ $\\psi = |\\psi\\rangle$ Conjugate Wave Function $\\psi^{*}$ $\\psi^{*} = \\langle\\psi|$ Inner Product $\\int\\phi^{*}(q)\\psi(q)dq=\\langle\\phi|\\psi\\rangle$ Outer Product(Operater) $|\\psi\\rangle\\langle\\phi|$ 特别地, 当 $\\psi = \\phi$ 时, 外积 $|\\psi\\rangle\\langle\\phi| = \\hat{P}$ 为投影算符.\n若有一组正交归一完备基 $\\{|a_{i}\\rangle\\}$, 其满足:\n完备性. $\\sum_{i}|a_{i}\\rangle\\langle a_{i}| = 1$; 正交归一性. $\\langle a_{i}|a_{j}\\rangle = \\delta_{ij}$ 我们就能对波函数和算子进行改写.\n$|\\psi\\rangle = \\sum_{i}|a_{i}\\rangle\\langle a_{i}|\\psi\\rangle = \\sum_{i}c_{i}|a_{i}\\rangle$ $\\hat{H} = \\sum_{i}|a_{i}\\rangle\\langle a_{i}|\\hat{H}\\sum_{j}|a_{j}\\rangle\\langle a_{j}|= \\sum_{ij}|a_{i}\\rangle\\langle a_{i}|\\hat{H}|a_{j}\\rangle\\langle a_{j}|=\\sum_{ij}H_{ij}|a_{i}\\rangle\\langle a_{j}|$ Generation and Annihilation Operators(Ascending and Descending Operators) 通过使用二次量子化, 可以将单体的算符 $\\hat{H}=\\sum_{i}\\hat{h}(q_{i})$ 转化为形式:\n$$ \\hat{H}=\\sum_{ij}h_{ij}\\hat{c_{i}^{\\dagger}}\\hat{c_{j}} $$\n$\\hat{c}$ 是湮灭算符, $\\hat{c^{\\dagger}}$ 是产生算符;对于费米子系统有 $\\{\\hat{c_i},\\hat{c_j}\\} = \\delta_{ij}$. 系数 $h_{ij} = \\langle i|\\hat{h}|j\\rangle$, $\\hat{h}$ 表示的是单粒子态算符.\n具体证明过程见于二次量子化.\nField Operators 场算符被定义为\n$$ \\hat{\\psi}(q) = \\sum_{i}\\hat{c_{i}}\\phi_{i}(q), $$\n对应的厄米共轭的场算符为\n$$ \\hat{\\psi^{\\dagger}}(q) = \\sum_{i}\\hat{c_{i}^{\\dagger}}\\phi_{i}^{*}(q), $$\n对于单体算子 $\\hat{H}=\\sum_{i}\\hat{h}(q_{i})$, 可以写成场算子的形式:\n$$ \\hat{H}=\\int\\hat{\\psi^{\\dagger}}(q)\\hat{h}(q)\\hat{\\psi}(q)dq $$\n$\\hat{h}(q)$ 表示的是单粒子态算符.\n$$ \\begin{equation} \\begin{aligned} \\hat{H} \u0026amp;= \\int\\hat{\\psi^{\\dagger}}(q)\\hat{h}(q)\\hat{\\psi}(q)dq\\\\ \u0026amp;= \\int\\sum_{i}\\hat{c_{i}^{\\dagger}}\\psi_{i}^{*}(q)\\hat{h}(q)\\sum_{j}\\hat{c_{j}}\\psi_{j}(q)dq\\\\ \u0026amp;= \\sum_{ij}\\hat{c_{i}^{\\dagger}}\\hat{c_{j}}\\int\\psi_{i}^{*}(q)\\hat{h}(q)\\psi_{j}(q)dq\\\\ \u0026amp;= \\sum_{ij}\\langle i|\\hat{h}|j\\rangle \\hat{c_{i}^{\\dagger}}\\hat{c_{j}}\\\\ \u0026amp;=\\sum_{ij}h_{ij}\\hat{c_{i}^{\\dagger}}\\hat{c_{j}} \\end{aligned} \\end{equation} $$\n泡利矩阵构造方法 在紧束缚模型-石墨烯中我们已经谈到过单层石墨烯的紧束缚模型近似下的哈密顿量:\n$$ h_{\\vec{K}}(\\vec{q})\\approx\\hbar v_{F} \\begin{bmatrix} 0 \u0026amp; q_{x} - iq_{y} \\\\ q_{x} + iq_{y} \u0026amp; 0 \\\\ \\end{bmatrix} =\\hbar v_{F}\\sigma\\cdot\\vec{q} $$\n$v_{F} = \\frac{3ta}{2}$, 石墨烯中的等效费米速度.\n我们可以发现, 拥有自旋意义的泡利矩阵同样可以构造出哈密顿量.\n泡利矩阵的定义和运算 单位矩阵 $$ \\sigma_{0} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\\\ \\end{bmatrix} $$\n泡利矩阵 $$ \\sigma_{x}= \\begin{bmatrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\\\ \\end{bmatrix}, \\sigma_{y}= \\begin{bmatrix} 0 \u0026amp; -i \\\\ i \u0026amp; 0 \\\\ \\end{bmatrix}, \\sigma_{z}= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\\\ \\end{bmatrix} $$\n计算性质 $$ \\sigma_{x}^2=\\sigma_{y}^2=\\sigma_{z}^2=\\sigma_{0}\\\\ \\sigma_{x}\\cdot\\sigma_{y}=i\\sigma_{z}\\\\ \\sigma_{y}\\cdot\\sigma_{z}=i\\sigma_{x}\\\\ \\sigma_{z}\\cdot\\sigma_{x}=i\\sigma_{y} $$\n对易关系: $$ [\\sigma_{x},\\sigma_{y}]=2i\\sigma_{z}\\\\ [\\sigma_{y},\\sigma_{z}]=2i\\sigma_{x}\\\\ [\\sigma_{z},\\sigma_{x}]=2i\\sigma_{y} $$\n反对易关系: $$ \\{\\sigma_{x},\\sigma_{y}\\}=2i\\sigma_{z}\\\\ \\{\\sigma_{y},\\sigma_{z}\\}=2i\\sigma_{x}\\\\ \\{\\sigma_{z},\\sigma_{x}\\}=2i\\sigma_{y} $$\n泡利矩阵的Kronecker积 矩阵的Kronecker积\n若有 $A = (a_{ij})_{m\\times n}, B = (b_{ij})_{p\\times q}$ , 则分块矩阵 $$ \\begin{bmatrix} a_{11}B \u0026amp; a_{12}B \u0026amp; \\cdots \u0026amp; a_{1n}B \\\\ a_{21}B \u0026amp; a_{22}B \u0026amp; \\cdots \u0026amp; a_{2n}B \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ a_{m1}B \u0026amp; a_{m2}B \u0026amp; \\cdots \u0026amp; a_{mn}B \\\\ \\end{bmatrix}_{mp\\times nq} $$\n为 $A$ 和 $B$ 的Kronecker积, 记作 $A\\otimes B$.\n例如: $$ \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\\\ \\end{bmatrix}\\otimes \\begin{bmatrix} 2\\\\ 3\\\\ \\end{bmatrix}= \\begin{bmatrix} 2a \u0026amp; 2b \\\\ 3a \u0026amp; 3b \\\\ 2c \u0026amp; 2d \\\\ 3c \u0026amp; 3d \\\\ \\end{bmatrix}, $$ $$ \\begin{bmatrix} 2\\\\ 3\\\\ \\end{bmatrix}\\otimes \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\\\ \\end{bmatrix}= \\begin{bmatrix} 2a \u0026amp; 2b \\\\ 2c \u0026amp; 2d \\\\ 3a \u0026amp; 3b \\\\ 3c \u0026amp; 3d \\\\ \\end{bmatrix}. $$\n由此我们可以计算出含有泡利矩阵的Kronecker积.\n从二次量子化到泡利矩阵 该内容参考自博客文章从Pauli矩阵出发构造哈密顿量, 作者YuXuan\n凝聚态更关心低能状态下的哈密顿量, 而晶体中电子的能量通常与其动量和位置有关, 所以会将哈密顿量写作动量$k$的函数.\n我们给出一个以动量$k$为参数的哈密顿量:\n$$ H(\\vec{k})=2\\lambda_{x}\\sin{k_{x}}\\sigma_{x}s_{z}\\tau_{z}+2\\lambda_{y}\\sin{k_{y}}\\sigma_{y}\\tau_{z}+(\\zeta_{k}\\sigma_{z}-\\mu)\\tau_{z} + \\Delta(\\vec{k})\\tau_{x} $$\n该式的引入只是为了介绍泡利矩阵是如何参与到构造哈密顿量的, 其中具体的参数意义可以暂且不理会. 如果你对其参数含义实在感兴趣, 猜测得出的含义如下:它是用来描述二维拓扑绝缘体或者拓扑超导体的。其中的$\\lambda_x$和$\\lambda_y$是自旋轨道耦合项，$\\sigma_x$和$\\sigma_y$是泡利矩阵，$s_z$是自旋算符，$\\tau_z$是粒子-空穴空间的泡利矩阵。$\\zeta_k$和$\\mu$是质量项，$\\Delta(\\vec{k})$是超导配对项。\n原本的哈密顿量写法应该是\n$$ \\hat{H} = \\sum_{\\vec{k}}\\Psi_{k}^{\\dagger}H(\\vec{k})\\Psi_{\\vec{k}} $$\n我们选定基矢:\n$$ \\Psi_{\\dagger} = \\begin{bmatrix} c_{a\\uparrow\\vec{k}}^{\\dagger} \u0026amp; c_{b\\uparrow\\vec{k}}^{\\dagger} \u0026amp; c_{a\\downarrow\\vec{k}}^{\\dagger} \u0026amp; c_{b\\downarrow\\vec{k}}^{\\dagger} \u0026amp; c_{a\\downarrow-\\vec{k}} \u0026amp; c_{b\\downarrow-\\vec{k}} \u0026amp; -c_{a\\uparrow-\\vec{k}} \u0026amp; -c_{b\\uparrow-\\vec{k}} \\\\ \\end{bmatrix} $$\n注意基矢的选定其实是具有高自由度, 你可以对算符的顺序和符号进行任意重排组合, 最后只是影响了哈密顿量的形式, 但是物理意义是不变的.\n$c_{a\\uparrow\\vec{k}}^{\\dagger}$ 中各指标的含义\n$^{\\dagger}$ 代表产生算符, $a$ 表示能带/轨道, $\\uparrow$ 表示自旋, $\\vec{k}$ 表示动量.\n所以 $\\Psi_{\\vec{k}}$ 相当于一个包含了所有升降算符的极长列向量.由此我们得到了哈密顿量的泡利矩阵形式和二次量子化形式之间的关系.\n不如更具体的例子:\n选择基矢为\n$$ \\Psi_{\\vec{k}}= \\begin{bmatrix} C_{a,\\uparrow, \\vec{k}}\\\\ C_{a,\\uparrow, -\\vec{k}}\\\\ C_{a,\\downarrow, \\vec{k}}\\\\ C_{a,\\downarrow, -\\vec{k}}\\\\ C_{b,\\uparrow, \\vec{k}}\\\\ C_{b,\\uparrow, -\\vec{k}}\\\\ C_{b,\\downarrow, \\vec{k}}\\\\ C_{b,\\downarrow, -\\vec{k}}\\\\ \\end{bmatrix} $$\n$$ \\Psi_{\\dagger}= \\begin{bmatrix} C_{a,\\uparrow, \\vec{k}}^{\\dagger} \u0026amp; C_{a,\\uparrow, -\\vec{k}}^{\\dagger} \u0026amp; C_{a,\\downarrow, \\vec{k}}^{\\dagger} \u0026amp; C_{a,\\downarrow, -\\vec{k}}^{\\dagger} \u0026amp; C_{b,\\uparrow, \\vec{k}}^{\\dagger} \u0026amp; C_{b,\\uparrow, -\\vec{k}}^{\\dagger} \u0026amp; C_{b,\\downarrow, \\vec{k}}^{\\dagger} \u0026amp; C_{b,\\downarrow, -\\vec{k}}^{\\dagger} \\\\ \\end{bmatrix} $$\n哈密顿量为\n$$ H^{BdG}(\\vec{k}) = (m_{0}-t_{x}\\cos{k_{x}}-t_{y}\\cos{k_{y}})\\sigma_{z}\\tau_{z} + A_{x}\\sin{k_{x}}\\sigma_{x}\\tau_{z} + A_{y}\\sin{k_{y}}\\sigma_{y}\\tau_{z} + \\Delta{k}\\tau_{x} $$\n这也提示我们, 因为个人习惯不同, 同一个哈密顿量可能有很多种不同形式的写法. 所以在阅读他人的文章时, 如何识别出其基矢的选择则成为重要的问题.具体的解决方法由原文作者在哈密顿量构建时的基矢选择中给出.\n将哈密顿量写为二次量子化的形式:\n$$ \\hat{H} = \\frac{1}{2}\\sum_{\\vec{k}}\\Psi_{\\vec{k}}^{\\dagger}H(\\vec{k})\\Psi_{\\vec{k}} $$\n其中计算 $(m_{0}-t_{x}\\cos{k_{x}}-t_{y}\\cos{k_{y}})\\sigma_{z}\\tau_{z}$ 的算子表示即为 $\\Psi_{\\vec{k}}^{\\dagger}\\cdot(\\tau_{z}\\otimes s_{0}\\otimes\\sigma_{z})\\Psi_{\\vec{k}}$\n最后得到的结果为\n$$ \\hat{H}=-C_{a,\\downarrow,-\\vec{k}}C_{a,\\downarrow,-\\vec{k}}^{\\dagger}-C_{a,\\uparrow,-\\vec{k}}C_{a,\\uparrow,-\\vec{k}}^{\\dagger}+C_{a,\\downarrow,\\vec{k}}C_{a,\\downarrow,\\vec{k}}^{\\dagger}+C_{a,\\uparrow,\\vec{k}}C_{a,\\uparrow,\\vec{k}}^{\\dagger}+C_{b,\\downarrow,-\\vec{k}}C_{b,\\downarrow,-\\vec{k}}^{\\dagger}+C_{b,\\uparrow,-\\vec{k}}C_{b,\\uparrow,-\\vec{k}}^{\\dagger}-C_{b,\\downarrow,\\vec{k}}C_{b,\\downarrow,\\vec{k}}^{\\dagger}-C_{b,\\uparrow,\\vec{k}}C_{b,\\uparrow,\\vec{k}}^{\\dagger} $$ 利用 Mathematica 可以方便地计算出所有的算符组合形式.\nClear[\u0026#34;Global`*\u0026#34;] i = PauliMatrix[0];x = PauliMatrix[1];y = PauliMatrix[2];z = PauliMatrix[3]; m1 = KroneckerProduct[z, i, z]; b1 = Flatten[Table[{C_{i1,i2,i3}},{i1,{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;}},{i2,{\u0026#34;\\uparrow\u0026#34;, \u0026#34;\\downarrow\u0026#34;}}, {i3, {\u0026#34;k\u0026#34;,\u0026#34;-k\u0026#34;}}], 2]; b1t = Flatten[Table[{C_{i1,i2,i3}^{\\dagger}},{i1,{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;}},{i2,{\u0026#34;\\uparrow\u0026#34;, \u0026#34;\\downarrow\u0026#34;}}, {i3, {\u0026#34;k\u0026#34;,\u0026#34;-k\u0026#34;}}]]; re = Style[b1t.m1.b1, Lighter@Blue,20, FontFamily -\u0026gt; \u0026#34;Times New Roman\u0026#34;] 其中的 LaTex 格式代码仅供参考, 使用时需要将其转换为 Mathmatica 格式.\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/hamiltonian/","summary":"Dirac Notation 狄拉克符号利用 \u0026lsquo;$\\langle$\u0026rsquo;(Bra, 左矢) 和 \u0026lsquo;$\\rangle$\u0026rsquo;(Ket, 右矢)语言来对常规的量子力学中的概念进行替换. 方程语言 Dirac Notation Wave Function $\\psi$ $\\psi = |\\psi\\rangle$ Conjugate Wave Function $\\psi^{*}$ $\\psi^{*} = \\langle\\psi|$ Inner Product $\\int\\phi^{*}(q)\\psi(q)dq=\\langle\\phi|\\psi\\rangle$ Outer Product(Operater) $|\\psi\\rangle\\langle\\phi|$ 特别地, 当 $\\psi = \\phi$ 时, 外积 $|\\psi\\rangle\\langle\\phi| = \\hat{P}$ 为投影算符. 若有一组正交归一完备基 $\\{|a_{i}\\rangle\\}$, 其满足: 完备性. $\\sum_{i}|a_{i}\\rangle\\langle a_{i}| = 1$; 正交归一性. $\\langle a_{i}|a_{j}\\rangle = \\delta_{ij}$ 我们就能对波函数和算子进行改写. $|\\psi\\rangle = \\sum_{i}|a_{i}\\rangle\\langle a_{i}|\\psi\\rangle = \\sum_{i}c_{i}|a_{i}\\rangle$","title":"哈密顿量的描述方式"},{"content":"本文将个人本科期间所学习的所有计算物理技巧总结于此:\n数值分析与程序设计(2020-2021-2-MA1802-2)\n计算软件应用(2020-2021-3-PHY1750-1)\n计算物理导论(2021-2022-2-PHY2506-1)\nComputer Physics@ucsc\n本文内容预计需要大量时间才能编写完成, 其中不乏需要复习回顾的内容.\n","permalink":"https://Muatyz.github.io/posts/phy/calphy/calphy/","summary":"本文将个人本科期间所学习的所有计算物理技巧总结于此: 数值分析与程序设计(2020-2021-2-MA1802-2) 计算软件应用(2020-2021-3-PHY1750-1) 计算物理导论(2021-2022-2-PHY2506-1) Computer Physics@ucsc 本文内容预计需要大量时间才能编写完成, 其中不乏","title":"计算物理方法"},{"content":"布洛赫和 紧束缚近似假定电子受到了很强的束缚作用. 当电子靠近原子实, 将其所在势场近似为库伦势. 因此电子在原子实附近的行为于类氢原子的轨道波函数将会有相似性.\n至于其它原子实对电子的作用将被处理为微扰. 原本的轨道波函数是分立的, 引入其它原子实的势场微扰就会使能级产生劈裂.\n我们假定电子的束缚态波函数为 $\\phi_{i}(\\vec{r})$, 写出含势场的薛定谔方程:\n$$ \\left[-\\frac{\\hbar^2}{2m}\\nabla^2+V(\\vec{r}-\\vec{R_m})\\right]\\phi_{i}(\\vec{r}-\\vec{R_m})=\\epsilon_{i}\\phi_{i}(\\vec{r}-\\vec{R_m}) $$\n根据已经学到的量子力学的知识, 对于一个核外电子的波函数, 我们知道其可以为 $s$ , $p$ 轨道波函数, 在不考虑自旋的情况下则是由 $n, l, m$ 三个量子数来描述.\n而真正的周期性势场 $U(\\vec{r})$ 与 $V(\\vec{r})$ 是有区别的. 所以我们将其差异部分, 也就是 $U(\\vec{r}) - V(\\vec{r} - \\vec{R_m})$ 视为微扰哈密顿量. 那么就有对波函数 $\\psi(\\vec{r})$ :\n$$ \\left[-\\frac{\\hbar^2}{2m}\\nabla^2+U(\\vec{r})\\right]\\psi(\\vec{r})=E\\psi(\\vec{r}) $$\n对于不同的格点, 有着不同的势场 $V(\\vec{r}-\\vec{R_m})$ ($m = 1,\\dots, N$). 所以这会产生 $N$ 个解 $\\phi_{i}(\\vec{r}-\\vec{R_m})$. 我们假定在周期性势场下, 电子的波函数即为这 $N$ 个束缚态波函数的线性叠加:\n$$ \\psi(\\vec{r}) = \\sum_{m}a_{m}\\phi_{i}(\\vec{r}-\\vec{R_m}) $$\n将其带入到 $\\psi$ 的薛定谔方程中, 即有:\n$$ \\sum_{m}\\left[\\epsilon_{i}+(U(\\vec{r})-V(\\vec{r}-\\vec{R_m}))a_{m}\\phi_{i}(\\vec{r}-\\vec{R_m})\\right] = E\\sum_m a_{m}\\phi_{i}(\\vec{r}-\\vec{R_m}). $$\n并且我们将这些不同格点处的束缚态波函数视为线性无关的, 即近似正交归一的. 所以对上式等号的左右两边都对 $\\phi_{i}(\\vec{r}-\\vec{R_m})$ 做内积(相当于都左乘 $\\int d^3\\vec{r}\\phi_{i}^{*}(\\vec{r}-\\vec{R_m})$), 就有:\n$$ \\sum_{m}a_m\\int d^3\\vec{r}\\phi_{i}^{*}(\\vec{r}-\\vec{R_n})(U(\\vec{r})-V(\\vec{r}-\\vec{R_m}))\\phi_{i}(\\vec{r}-\\vec{R_m}) = a_{n}(E-\\epsilon_{i}) $$\n因为我们假定了这些波函数是正交归一的, 所以 $$\\int d^3\\vec{r}\\phi_{i}^{*}(\\vec{r}-\\vec{R_n})\\phi_{i}(\\vec{r}-\\vec{R_m}) = \\delta_{nm}, $$ 所以求和项中只有 $n$ 会被保留下来.\n换元 $\\vec{\\zeta} = \\vec{r} - \\vec{R_m}$, 将上式简写为以下形式:\n$$ \\sum_{m}a_m\\int d^3\\zeta\\phi_{i}^{*}\\left(\\zeta-(\\vec{R_n}-\\vec{R_m})\\right) \\left(U(\\zeta)-V(\\zeta) \\right) \\phi_{i}(\\zeta)\\\\ =-\\sum_{m}a_{m}J(\\vec{R_n}-\\vec{R_m}) = a_{n}(E-\\epsilon_{i}) $$\n$$\\int d^3\\zeta\\phi_{i}^{*}(\\zeta-\\vec{R})\\left(U(\\zeta)-V(\\zeta)\\right)\\phi_{i}(\\zeta)=-J(\\vec{R})$$\n$J$ 被称为 交叠积分(或者重叠积分), 这是因为只有当 $\\phi_{i}(\\vec{R_n})$ 和 $\\phi_{i}(\\vec{R_m})$ 存在共同分量(即并非完全正交)时, 该量才不会等于 $0$ .\n对于具有周期性边界条件的晶体, 我们不仅能推测 $J(\\vec{R_n}-\\vec{R_m})$ 只和格点 $n$ 和 $m$ 的相对位置有关, 还可以猜测系数 $a_{m}$ 具有平面波的形式.即\n$$ a_{m} = Ce^{i\\vec{k}\\cdot\\vec{R_m}}, $$\n代入到前面我们做内积的式子中, 即有\n$$ -C\\sum_{m}J(\\vec{R_n}-\\vec{R_m})e^{-i\\vec{k}\\cdot(\\vec{R_n}-\\vec{R_m})} = C(E-\\epsilon_{i})e^{i\\vec{k}\\cdot(\\vec{R_n}-\\vec{R_m})} = C(E - \\epsilon_{i}) $$\n同样是利用周期性边界条件, 我们将 $\\vec{R_n} - \\vec{R_m}$ 进行换元, 即有\n$$ E(\\vec{k}) = \\epsilon_{i} - \\sum_{s}J(\\vec{R_s})e^{-i\\vec{k}\\cdot\\vec{R_s}} $$\n$\\vec{R_s} = \\vec{R_n} - \\vec{R_m}$\n对于波函数则可以写作为布洛赫和的形式:\n$$ \\psi_{\\vec{k}}(\\vec{r}) = \\frac{1}{\\sqrt{N}}\\sum_{m}e^{i\\vec{k}\\cdot\\vec{R_m}}\\phi_{i}^{\\vec{r}-\\vec{R_m}}=e^{i\\vec{k}\\cdot\\vec{r}}\\left(\\frac{1}{\\sqrt{N}}\\sum_{s}r^{-i\\vec{k}\\cdot\\vec{R_s}}\\phi_{i}(\\vec{R_s})\\right) $$\n$\\frac{1}{\\sqrt{N}}$ 是归一化因子\n能带计算 一维晶格 如果我们要计算$s$轨道波函数的布洛赫和, 只考虑最近邻(nearest neighbours)格点的交叠函数, 我们会有\n$$ E(\\vec{k}) = \\epsilon_{s} - J_{0} - J_{1}e^{-ika} - J_{1}e^{ika} $$\n一般 $U - V \u0026lt; 0$, 所以 $J \u0026gt; 0$. 以此将上式简化\n$$ E = \\epsilon_{s} - J_{0} - 2J\\cos(ka) $$\n$a$ 为晶格常数.\n二次量子化下的紧束缚模型\n考虑一维的原子链, 每个原胞一个原子, 每个原子附近一个电子. $$ \\hat{H} = -\\sum_{ij}(t_{ij}\\hat{c_{i}^{\\dagger}}\\hat{c_{j}}+t_{ji}\\hat{c_{j}^{\\dagger}}\\hat{c_{i}}) + \\sum_{i}V_{i}\\hat{c_{i}^{\\dagger}}\\hat{c_{i}} $$\n第一个 $\\sum$ 代表的是跃迁(hopping)能, 第二个 $\\sum$ 代表的是在位势能, $\\hat{c_{i}}^{\\dagger}, \\hat{c_{i}}$ 分别为产生算符和湮灭算符.\n升降算符存在关系: $$ \\sum_{i}\\hat{c_{i}}^{\\dagger}\\hat{c_{i}} = \\sum_{i}\\hat{n_{i}} = N $$\n$N$ 为总粒子数\n则有 $$ \\hat{H} = -\\sum_{ij}(t_{ij}\\hat{c_{i}}^{\\dagger}\\hat{c_{j}}+h.c.)+ VN $$\nh.c. = Hermitian Conjugate, 意为\u0026rsquo;厄米共轭'\n若原子等距排列且只考虑最近邻跃迁能, 则将哈密顿量简化为:\n$$ \\hat{H} = -t\\sum_{i}(\\hat{c_{i}}^{\\dagger}\\hat{c_{i+1}}+h.c.) $$ 这就是二次量子化表述的紧束缚模型近似下的哈密顿量.\n更具体一点的计算, 就是使用傅里叶变换写出 $k$ 表象下的哈密顿量:\n$$ \\hat{c_{j}} = \\frac{1}{\\sqrt{N}}\\sum_{k}e^{ikx_{j}} $$ 代入到原哈密顿量的式子中即有 $$ \\hat{H}(k)=-t\\sum_{k}(\\hat{c_{k}}^{\\dagger}\\hat{c_{k}}+h.c.)=\\sum_{k}(-2t\\cos{(ka)}\\hat{c_{k}}^{\\dagger}\\hat{c_{k}}) $$ 所以就有了 $$ E(k) = -2t\\cos{(ka)} $$\n二维晶格 简单正方晶格 $$ E = \\epsilon - 2t\\left(\\cos(k_{x}a) + \\cos(k_{y}a)\\right) $$\n二维六角晶格(最密堆积) 二维六角晶格的经典代表就是石墨烯和六方氮化硼. 简单起见我们先考虑相同原子的石墨烯二维结构.\n紧束缚模型要求仅考虑最近邻原子, 那么我们写出满足要求的哈密顿量为:\n$$ \\hat{H} = t\\sum_{i, j = \\langle i\\rangle}a_{i}^{\\dagger}b_{j} + h.c.. $$\n$a_{i}, a_{i}^{\\dagger}$是 $A$ 处的湮灭, 产生算符, 而 $b_{i}, b_{i}^\\dagger$ 同理. \u0026lsquo;$i,j = \\langle i\\rangle$\u0026rsquo; 是表达最近邻的意思.\n哈密顿量可以用三种方法表示(Dirac Bra-Ket, Ascending and Descending Operators, Field Operators). 其中第二种和第三种在某些情况下其实是等同的.详情见于哈密顿量的三种形式.\n在石墨烯原胞中, 包含着两个不等价的碳原子, 我们将晶格基矢选为\n$$ \\vec{a_{1}}=\\left(\\frac{3}{2}, \\frac{\\sqrt{3}}{2}\\right)a,\\\\ \\vec{a_{2}}=\\left(\\frac{3}{2},-\\frac{\\sqrt{3}}{2}\\right)a. $$\n$a$ 为晶格常数\n二维空间中计算倒格子基矢的方法和三维空间中的一样, 只是需要我们构造出一个辅助矢量 $\\vec{a_{3}} = \\vec{a_{1}}\\times \\vec{a_{2}}$, 代入到传统的求倒格子公式中即可. 由此我们得到二维下的倒格子基矢:\n$$ \\vec{b_{1}}=\\frac{1}{a}\\left(\\frac{2\\pi}{3}, \\frac{2\\sqrt{3}}{3}\\right),\\\\ \\vec{b_{2}}=\\frac{1}{a}\\left(\\frac{2\\pi}{3},-\\frac{2\\sqrt{3}}{3}\\right). $$\n原子到最近邻原子之间的距离分别为\n$$ \\vec{\\delta_{1}} = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)a,\\\\ \\vec{\\delta_{2}} = \\left(\\frac{1}{2},-\\frac{\\sqrt{3}}{2}\\right)a,\\\\ \\vec{\\delta_{3}} = \\left(0 , -1\\right)a. $$\nBloch 态和 Wannier 态之间呈现为 Fourier 变换关系:\n$$ \\psi_{nl}(r) = \\frac{1}{\\sqrt{N}}\\sum_{l}e^{ik\\cdot l}W_{n}(r,l) $$\n$W_{n}(r,l)$ 是关于 $(r-l)$ 的 Wannier 函数. 关于 Wannier 函数的详细内容, 见于Wannier函数.\n先不考虑存在多条能带, 所以我们将能带指标的 $n$ 忽略.\n而又因为一个原胞中存在着两个不等价的碳原子, 所以我们赋给每个碳原子一个Bloch态\n$$ \\varphi_{1}=\\frac{1}{\\sqrt{N}}\\sum_{l}e^{i\\vec{k}\\cdot\\vec{R_{l}^{A}}}\\phi(\\vec{r}-\\vec{R_{l}^{A}}),\\\\ \\varphi_{2}=\\frac{1}{\\sqrt{N}}\\sum_{l}e^{i\\vec{k}\\cdot\\vec{R_{l}^{B}}}\\phi(\\vec{r}-\\vec{R_{l}^{B}}). $$\n$N$ 是体系中原胞总数, $\\vec{R_{l}^{A}}$ 和 $\\vec{R_{l}^{B}}$ 分别代表原胞中两个不等价碳原子的位置.\n在这里我们使用了原子轨道波函数 $\\phi$ 来近似代替局域内的 Wannier 函数 $W$. 这是因为在这里我们只考虑最近邻原子的交叠函数, 所以这两个函数的差异并不大.\n所以系统的波函数就可以写作布洛赫态的线性组合\n$$ \\psi(\\vec{r})=c_{1}\\varphi_{1} + c_{2}\\varphi_{2} = \\frac{c_{1}}{\\sqrt{N}}\\sum_{l}e^{i\\vec{k}\\cdot\\vec{R_{l}^{A}}}\\phi(\\vec{r}-\\vec{R_{l}^{A}}) + \\frac{c_{2}}{\\sqrt{N}}\\sum_{l\u0026rsquo;}e^{i\\vec{k}\\cdot\\vec{R_{l\u0026rsquo;}^{B}}}\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{B}})\\\\ =\\frac{1}{\\sqrt{N}}\\sum_{l,l\u0026rsquo;}\\left[e^{i\\vec{k}\\cdot\\vec{R_{l}^{A}}}c_{1}\\phi(\\vec{r}-\\vec{R_{l}^{A}})+e^{i\\vec{k}\\cdot\\vec{R_{l\u0026rsquo;}^{B}}}c_{2}\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{B}})\\right] $$\n为了得到能量本征值, 我们就需要求解本征方程:\n$$ \\hat{H}|\\psi\\rangle = E|\\psi\\rangle $$\n因为我们采用的近似波函数 $\\varphi$ 满足正交关系\n$$ \\langle\\varphi_{i}|\\varphi_{j}\\rangle=\\delta_{ij} $$\n所以我们将本征方程整理为\n$$ (\\hat{H}-E)|\\psi\\rangle = 0|\\psi\\rangle $$\n从而化为久期方程\n$$ \\left|\\begin{array}{c} H_{11} - E \u0026amp; H_{12} \\\\ H_{21} \u0026amp; H_{22} - E \\\\ \\end{array}\\right|=0 $$\n$H_{ij}=\\langle\\varphi_{i}|\\hat{H}|\\varphi_{j}\\rangle, H_{12} = H_{21}^{*}$\n这是一个关于 $E$ 的二次方程, 解出 $E$ 的形式解:\n$$ E = \\frac{1}{2}\\left[H_{11}+H_{22}\\pm\\sqrt{(H_{11}-H_{22})^2+4|H_{12}|^2}\\right] $$\n所以问题就转换为了计算矩阵元 $H_{ij}$ 的具体值.\n$$ H_{11} = \\langle\\varphi_{1}|\\hat{H}|\\varphi_{1}\\rangle = \\frac{1}{N}\\sum_{l,l\u0026rsquo;}e^{-i\\vec{k}\\cdot(\\vec{R_{l}^{A}}-\\vec{R_{l\u0026rsquo;}^{A}})}\\langle\\phi(\\vec{r}-\\vec{R_{l}^{A}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle $$\n原子轨道波函数 $\\varphi$ 的正交性有 $$ \\langle\\phi(\\vec{r}-\\vec{R_{l}^{A}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle = \\epsilon_{1}\\langle\\phi(\\vec{r}-\\vec{R_{l}^{A}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle = \\epsilon_{1}\\\\ \\delta(\\vec{R_{l}^{A}}-\\vec{R_{l\u0026rsquo;}^{A}}) = \\frac{1}{N}\\sum_{l,l\u0026rsquo;}e^{-i\\vec{k}\\cdot(\\vec{R_{l}^{A}}-\\vec{R_{l\u0026rsquo;}^{A}})} $$\n同理, 我们对 $H_{22}$ 可以求出\n$$ H_{22} = \\langle\\varphi_{2}|\\hat{H}|\\varphi_{2}\\rangle = \\frac{1}{N}\\sum_{l,l\u0026rsquo;}e^{-i\\vec{k}\\cdot(\\vec{R_{l}^{B}}-\\vec{R_{l\u0026rsquo;}^{B}})}\\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{B}})\\rangle = \\epsilon_{2} $$\n而对于交叉项我们有\n$$ H_{12}=\\langle\\varphi_{1}|\\hat{H}|\\varphi_{2}\\rangle = \\frac{1}{N}\\sum_{l,l\u0026rsquo;}e^{i\\vec{k}\\cdot(\\vec{R_{l}^{B}}-\\vec{R_{l\u0026rsquo;}^{A}})}\\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle\\\\ =\\frac{1}{N}\\sum_{l,l\u0026rsquo;}Je^{i\\vec{k}\\cdot(\\vec{R_{l}^{B}}-\\vec{R_{l\u0026rsquo;}^{A}})} $$\n$J = \\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|\\hat{H}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle$, 这就是我们前面所介绍的交叠积分.\n而对于哈密顿量, 我们将其写作 $$ \\hat{H} = \\hat{H_{a}} + V - v_{a} $$\n$\\hat{H_{a}}$ 是原子的哈密顿量, $V$ 是晶格势, $v_{a}$ 是原子势.\n对于 $\\hat{H_a}$, 有 $$ \\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|\\hat{H_{a}}|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle = \\epsilon_{1}\\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle = \\epsilon_{1}\\delta_{AB}\\delta_{l,l\u0026rsquo;} $$ 所以我们就有\n$$ J = \\langle\\phi(\\vec{r}-\\vec{R_{l}^{B}})|(V-v_a)|\\phi(\\vec{r}-\\vec{R_{l\u0026rsquo;}^{A}})\\rangle $$\n因为我们考虑的是紧束缚模型, 即仅考虑最近邻原子的跃迁方向, 即有\n$$ |\\vec{R_{l}^{A}}-\\vec{R_{l\u0026rsquo;}^{B}}|=|\\delta_{i}| $$\n$\\delta_{i}$ 即为最近邻原子的位移矢量: $$ \\vec{\\delta_{1}} = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)a, \\vec{\\delta_{2}} = \\left(\\frac{1}{2},-\\frac{\\sqrt{3}}{2}\\right)a, \\vec{\\delta_{3}} = \\left(0 , -1\\right)a. $$\n于是就有\n$$ H_{12} = \\frac{1}{N}\\sum_{l,l\u0026rsquo;}e^{i\\vec{k}\\cdot(\\vec{R_{l}^{A}}-\\vec{R_{l\u0026rsquo;}^{B}})}J=\\frac{1}{N}(e^{i\\vec{k}\\cdot\\vec{\\delta_{1}}}+e^{i\\vec{k}\\cdot\\vec{\\delta_{2}}}+e^{i\\vec{k}\\cdot\\vec{\\delta_{3}}})NJ\\\\ =J\\left[e^{-ik_{y}\\cdot a}+2\\cos{k_{y}\\left(\\frac{\\sqrt{3}a}{2}\\right)\\cdot e^{ik_{x}\\cdot\\frac{a}{2}}}\\right] $$\n于是将各矩阵元代入到二次方程的解中, 就有\n$$ E(\\vec{k}) = \\epsilon_{1}\\pm J\\sqrt{3+2\\cos{(\\sqrt{3}k_{y}a)}+4\\cos{\\left(\\frac{\\sqrt{3}k_{y}a}{2}\\right)}\\cos{\\left(\\frac{3k_{x}a}{2}\\right)}} $$\n我们可以通过简单的二维格点将其绘制出来.\n% 定义常数 a = 1; % 石墨烯晶格常数 t = 1; % 能带结构参数 kx = linspace(-pi/a,pi/a,200); % kx空间路径 ky = linspace(-pi/a,pi/a,200); % ky空间路径 [kx,ky] = meshgrid(kx,ky); % 计算能带 E1 = t*sqrt(3+2*cos(sqrt(3)*kx*a)+4*cos(sqrt(3)/2*kx*a).*cos(3/2*ky*a)); % 第一条能带 E2 = -E1; % 第二条能带 % 绘制能带图 figure; h1 = surf(kx,ky,E1,\u0026#39;edgecolor\u0026#39;,\u0026#39;none\u0026#39;); hold on; h2 = surf(kx,ky,E2,\u0026#39;edgecolor\u0026#39;,\u0026#39;none\u0026#39;); xlabel(\u0026#39;k_x\u0026#39;,\u0026#39;fontsize\u0026#39;,14); ylabel(\u0026#39;k_y\u0026#39;,\u0026#39;fontsize\u0026#39;,14); zlabel(\u0026#39;E\u0026#39;,\u0026#39;fontsize\u0026#39;,14); title(\u0026#39;能带结构\u0026#39;,\u0026#39;fontsize\u0026#39;,16); set(gca,\u0026#39;fontsize\u0026#39;,14,\u0026#39;linewidth\u0026#39;,2); view([30 30]); % 绘制colorbar hcb = colorbar; set(hcb,\u0026#39;position\u0026#39;,[0.9 0.15 0.03 0.7],\u0026#39;fontsize\u0026#39;,14,\u0026#39;linewidth\u0026#39;,2); colormap(jet); % 设置colorbar颜色 % 调整每个surface对象的颜色数据范围 caxis(h1,[-4 4]); caxis(h2,[-4 4]); % 调整z轴的显示范围，使两个能带大小一致 zlim([-4 4]); 如果你没有本地安装 Matlab, 你可以尝试注册 Matlab 账号并且在 Matlab Online 中执行代码.\n运行代码得到的效果如下:\n可以看到 $E = 0$ 的几个相对锥, 我们称其为狄拉克锥, 锥的顶点被称为狄拉克点. 有关于如何打开狄拉克点的能隙的内容, 具体见于Twisted-Bilayer-Graphene\n从上图可以看到两面能带在 $K$ 和 $K\u0026rsquo;$ 相交, 正是上面所说的狄拉克点. 我们引入波矢差 $\\vec{q} = \\vec{k} - \\vec{K}$, 以此来展开狄拉克点附近的哈密顿量.\n正如\u0026quot;狄拉克锥\u0026quot;的名字那样, 狄拉克点附近的石墨烯电子结构可以被近似处理为线性色散关系\n那么我们就可以得到这样的哈密顿量的描述方式:\n$$ h_{\\vec{K}}(\\vec{q})\\approx\\hbar v_{F} \\begin{bmatrix} 0 \u0026amp; q_{x} - iq_{y} \\\\ q_{x} + iq_{y} \u0026amp; 0 \\\\ \\end{bmatrix} =\\hbar v_{F}\\sigma\\cdot\\vec{q} $$\n$v_{F} = \\frac{3ta}{2}$, 石墨烯中的等效费米速度.\n有关于哈密顿量和泡利矩阵矩阵更详细的关系.\n三维晶格 简单立方堆积($sc$) 求 $s$ 态. 我们不难推测: 该波函数 $\\phi_{s}(\\vec{r})$ 是球对称的.\n而 $sc$ 中最近邻原子有 $6$ 个, 且距离为 $a$. 那么它们共享同一个交叠积分 $J_1$.\n又因为 $s$ 态波具有偶宇称 $\\phi_{s}(\\vec{r}) = \\phi_{s}(-\\vec{r})$, 因此有 $J_{1} \u0026gt; 0$.\n将最近邻格式 $(\\pm a,0,0), (0,\\pm a,0), (0,0,\\pm)$ 代入到交叠积分表达式中, 即有:\n$$ \\epsilon(\\vec{k}) = \\epsilon_{s} - J_{0} - 2J_{1}(\\cos{k_{x}a}+\\cos{k_{y}a}+\\cos{k_{z}a}) $$\n由此可知 $\\epsilon_{s}$ 被扩展为 $2*2*(1+1+1)J_{1} = 12J_{1}$ 带宽的能带.\n体心立方堆积($bcc$) $$ \\epsilon(\\vec{k}) = -\\alpha - 8\\gamma\\cos{\\left(\\frac{1}{2}k_{x}a\\right)}\\cos{\\left(\\frac{1}{2}k_{y}a\\right)}\\cos{\\left(\\frac{1}{2}k_{z}a\\right)} $$\n面心立方堆积($fcc$) $$ \\epsilon(\\vec{k}) = -\\alpha - 4\\gamma\\left[ \\cos{\\left(\\frac{1}{2}k_{y}a\\right)}\\cos{\\left(\\frac{1}{2}k_{z}a\\right)}+ \\cos{\\left(\\frac{1}{2}k_{z}a\\right)}\\cos{\\left(\\frac{1}{2}k_{x}a\\right)}+ \\cos{\\left(\\frac{1}{2}k_{x}a\\right)}\\cos{\\left(\\frac{1}{2}k_{y}a\\right)} \\right] $$\nWannier函数 定义 布洛赫函数本身是关于倒格子点阵的周期函数, 我们可以用下面这个式子描述:\n$$ \\phi_{\\vec{k}}(\\vec{r}) = \\phi_{\\vec{k}+\\vec{G}}(\\vec{r}) $$\n所以将 $\\phi_{\\vec{k}}(\\vec{r})$ 进行傅里叶级数展开:\n$$ \\phi_{\\vec{k}}(\\vec{r}) = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{R}}a(\\vec{R},\\vec{r})e^{i\\vec{k}\\cdot\\vec{R}} $$\n$a(\\vec{R},\\vec{r})$ 即为 Wannier 函数.\n性质 局域性 $$ \\begin{equation} \\begin{aligned} a(\\vec{R},\\vec{r}) \u0026amp; = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{k}}e^{-\\vec{k}\\cdot\\vec{r}}\\phi_{\\vec{k}}(\\vec{r})\\\\ \u0026amp; = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{k}}e^{i\\vec{k}\\cdot(\\vec{r}-\\vec{R})}u_{\\vec{k}}(\\vec{r})\\\\ \u0026amp; = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{k}}e^{i\\vec{k}\\cdot(\\vec{r}-\\vec{R})}u_{\\vec{k}}(\\vec{r}-\\vec{R})\\\\ \u0026amp; \\Rightarrow a(\\vec{R},\\vec{r}) = a(\\vec{r}-\\vec{R}) \\end{aligned} \\end{equation} $$\n所以 Wannier 函数是以正格点为中心的局域函数.\n正交性 $$ \\begin{aligned} \\langle a_{n}(\\vec{r}-\\vec{R})|a_{n\u0026rsquo;}(\\vec{r}-\\vec{R}\u0026rsquo;)\\rangle \u0026amp;=\\frac{1}{N}\\sum_{\\vec{k}}\\sum_{\\vec{k}\u0026rsquo;}e^{i\\vec{k}\\cdot\\vec{R}-\\vec{k}\u0026rsquo;\\cdot\\vec{R}\u0026rsquo;}\\int\\phi_{\\vec{k}}^{n*}(\\vec{r})\\phi_{\\vec{k}\u0026rsquo;}^{n\u0026rsquo;}(\\vec{r})\\mathrm{d}\\vec{r}\\\\ \u0026amp;= \\frac{1}{N}\\sum_{\\vec{k}}\\sum_{\\vec{k}\u0026rsquo;}e^{i(\\vec{k}\\cdot\\vec{R}-\\vec{k}\u0026rsquo;\\cdot\\vec{R}\u0026rsquo;)}\\delta_{nn\u0026rsquo;}\\delta_{\\vec{k}\\vec{k}\u0026rsquo;}\\\\ \u0026amp;= \\frac{1}{N}\\sum_{\\vec{k}}e^{i\\vec{k}\\cdot(\\vec{R}-\\vec{R}\u0026rsquo;)}\\delta_{nn\u0026rsquo;}\\\\ \u0026amp;= \\delta_{\\vec{R}\\vec{R}\u0026rsquo;}\\delta_{nn\u0026rsquo;} \\end{aligned} $$\n完备性 $$ \\sum_{n}\\sum_{\\vec{R}}a_{n}^{*}(\\vec{r}-\\vec{R})a_{n}(\\vec{r}\u0026rsquo;-\\vec{R}) = \\delta_{\\vec{r}\\vec{r}\u0026rsquo;} $$\nTight-Binding Model 中的应用 我们简单回顾一下紧束缚模型的一些基本假设和性质:\n相邻原子的电子波函数有很小的交叠, 这种交叠导致能带的产生.\n适用于内层电子;局域性较强的轨道电子;绝缘体.\n非简并情况 $$ \\left[-\\frac{\\hbar^{2}}{2m}\\nabla^{2}+V_{\\text{atom}}(\\vec{r})\\right]\\varphi = \\epsilon\\varphi $$\n$V_{\\text{atom}}(\\vec{r})$ 是单原子势场, $\\varphi$ 是单原子的总电子波函数.\n基于紧束缚模型, 假设真是电子波函数 $\\phi$ 是所有格点上孤立原子波函数 $\\varphi$ 的线性组合:\n$$ \\phi(\\vec{r}) = \\sum_{\\vec{R}_{m}}a_{m}\\varphi(\\vec{r}-\\vec{R}_{m}) $$\n$\\vec{R}_{m}$ 是正格矢.\n其中的孤立原子的波函数 $\\varphi$ 即为 Wannier 函数.\n孤立原子中的电子波函数 $\\varphi$ 满足\n归一性: $\\langle\\varphi(\\vec{r}-\\vec{R}_{m})|\\varphi(\\vec{r}-\\vec{R}_{m})\\rangle=1$ (近似)正交性: $\\langle\\varphi(\\vec{r}-\\vec{R}_{m})|\\varphi(\\vec{r}-\\vec{R}_{m\u0026rsquo;})\\rangle = 0$ 符合 Wannier 函数的基本性质要求.\n所以我们就有了\n$$ \\phi(\\vec{r}) = \\sum_{\\vec{R}_{m}}a_{m}\\varphi(\\vec{r}-\\vec{R}_{m}) $$\n并且系数 $\\{a_{m}\\}$ 需要使得 $\\phi(\\vec{r})$ 满足\n布洛赫函数条件 $$ \\phi(\\vec{r}-\\vec{R}_{m}) = e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\phi(\\vec{r}) $$\n归一化条件. $$ a_{m} = \\frac{1}{\\sqrt{N}}e^{i\\vec{k}\\cdot\\vec{R}_{m}} $$\n所以完整的紧束缚近似波函数为\n$$ \\phi(\\vec{r}) = \\sum_{\\vec{R}_{m}}\\frac{1}{\\sqrt{N}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\varphi(\\vec{r}-\\vec{R}_{m}) $$\n将其代入平均场近似下的单电子薛定谔方程:\n$$ \\left[-\\frac{\\hbar^{2}}{2m}\\nabla^{2}+V(\\vec{r})\\right]\\phi(\\vec{r}) = E\\phi(\\vec{r}) $$\n薛定谔方程的代入计算 $$ \\begin{aligned} \u0026amp;\\left[-\\frac{\\hbar^{2}}{2m}\\nabla^{2}+V(\\vec{r})\\right]\\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\varphi(\\vec{r}-\\vec{R}_{m}) = E\\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\varphi(\\vec{r}-\\vec{R}_{m})\\\\ \u0026amp;\\Rightarrow\\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\left[-\\frac{\\hbar^{2}}{2m}\\nabla^{2}-E(\\vec{k})+V(\\vec{r})\\right]\\varphi(\\vec{r}-\\vec{R}_{m}) = 0\\\\ \u0026amp;\\Rightarrow\\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}}\\left[\\color{red}{-\\frac{\\hbar^{2}}{2m}\\nabla^{2}}-E(\\vec{k})+V(\\vec{r})+ \\color{red}{V_{\\text{atom}}(\\vec{r}-\\vec{R}_{m})}-V_{\\text{atom}}(\\vec{r}-\\vec{R}_{m})\\right]\\varphi(\\vec{r}-\\vec{R}_{m}) = 0\\\\ \u0026amp;\\Rightarrow \\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\left[\\underbrace{\\color{red}{\\epsilon}}_{\\color{red}{\\text{孤立原子能级}}} - E(\\vec{k}) + \\underbrace{V(\\vec{r})- V_{\\text{atom}}(\\vec{r}-\\vec{R}_{m})}_{\\Delta V(\\vec{r},\\vec{R}_{m})}\\right]\\varphi(\\vec{r}-\\vec{R}_{m}) = 0\\\\ \u0026amp;\\text{左乘}\\varphi^{*}(\\vec{r})\\text{并积分}\\\\ \u0026amp;\\epsilon-E(\\vec{k}) + \\int\\varphi^{*}(\\vec{r}\\Delta V(\\vec{r},\\vec{0}))\\varphi(\\vec{r})\\mathrm{d}\\vec{r} + \\sum_{\\vec{R}_{m}\\neq 0}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\underbrace{\\int\\varphi^{*}(\\vec{r})\\Delta V(\\vec{r},\\vec{R}_{m})\\varphi(\\vec{r}-\\vec{R}_{m})\\mathrm{d}\\vec{r}}_{\\text{Transfer Interals}} = 0\\\\ \u0026amp;\\Rightarrow E(\\vec{k}) = \\epsilon - J(0) - \\sum_{n.n.}J(\\vec{R}_{m})e^{i\\vec{k}\\cdot\\vec{R}_{m}} \\end{aligned} $$ 得到的结果和我们前面推导的只考虑最近邻相互作用的色散结果一样.\n对于具体的计算可见于晶格代入中.\n简并情况 $$ \\phi(\\vec{r}) = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{R}_{m}}\\sum_{j}e^{i\\vec{k}\\cdot\\vec{R}_{m}}c_{j}\\varphi_{j}(\\vec{r}-\\vec{R}_{m}) $$\n非简并复式原胞 石墨烯是一个典型的复式原胞, C 原子经由 $\\text{sp}^{2}$ 杂化形成面内夹角为 $120$° 的轨道.\n$$ \\begin{aligned} \u0026amp;|h_{1}\\rangle = \\frac{1}{\\sqrt{3}}|s\\rangle + \\frac{\\sqrt{2}}{\\sqrt{3}}|p_{x}\\rangle\\\\ \u0026amp;|h_{2}\\rangle = \\frac{1}{\\sqrt{3}}|s\\rangle - \\frac{\\sqrt{2}}{\\sqrt{3}}\\left(\\frac{1}{2}|p_{x}\\rangle - \\frac{\\sqrt{3}}{2}|p_{y}\\rangle\\right)\\\\ \u0026amp;|h_{3}\\rangle = \\frac{1}{\\sqrt{3}}|s\\rangle - \\frac{\\sqrt{2}}{\\sqrt{3}}\\left(\\frac{1}{2}|p_{x}\\rangle + \\frac{\\sqrt{3}}{2}|p_{y}\\rangle\\right) \\end{aligned} $$\n而紧束缚近似波函数 $\\phi(\\vec{r})$ 有\n$$ \\begin{aligned} \\phi(\\vec{r}) \u0026amp;= c_{A}\\phi_{A}(\\vec{r}) + c_{B}\\phi_{B}(\\vec{r})\\\\ \u0026amp; = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{R}_{m}}e^{i\\vec{k}\\cdot\\vec{R}_{m}}\\left[c_{A}\\varphi(\\vec{r}-\\vec{R}_{m}^{A}) + c_{B}\\varphi(\\vec{r}-\\vec{R}_{m}^{B})\\right] \\end{aligned} $$\n也可以将上面这个式子写作以下形式: $$ \\phi(\\vec{r}) = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{R}_{m}}\\left[e^{i\\vec{k}\\cdot\\vec{R}_{m}^{A}}c_{A}\\varphi(\\vec{r}-\\vec{R}_{m}^{A})+ e^{i\\vec{k}\\cdot\\vec{R}_{m}^{B}}c_{B}\\varphi(\\vec{r}-\\vec{R}_{m}^{B})\\right] $$\n工具介绍 紧束缚模型近似下,计算各类基础晶格的能带结构\nPython下计算紧束缚模型近似\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/tight-binding-model/","summary":"布洛赫和 紧束缚近似假定电子受到了很强的束缚作用. 当电子靠近原子实, 将其所在势场近似为库伦势. 因此电子在原子实附近的行为于类氢原子的轨道波函数将会有相似性. 至于其它原子实对电子的作用将被处理为微扰. 原本的轨道波函数是分立的, 引入其它原子实的势场微扰就会使能级产生劈裂. 我们假定电子的","title":"紧束缚模型"},{"content":"本文用作 ITensor 数值求解 Hubbard Model 的前置理论知识.\n背景 因为离子质量远大于电子, 所以可以假定离子构成静态的晶格, 所以我们可以写出哈密顿量:\n$$ H = \\sum_{i = 1}^{N}\\left(\\frac{|\\vec{p_{i}}|^{2}}{2m} + V_{I}(\\vec{x_{i}})\\right)+\\sum_{1\\leq i\u0026lt;j\\leq N} V_{C}(\\vec{x_{i}}-\\vec{x_{j}}) $$\n$N$ 是电子数, $V_{I}(\\vec{x})$ 是离子的周期势, $V_{C}(\\vec{x}) = \\frac{e^2}{||\\vec{x}||}$ 是电子间的库伦排斥作用.\n这个式子虽然已经做出很大程度的近似, 但是仍然由于太过复杂无法进行精确求解. 一种方法是, 对场进行进一步的近似:\n$$ H = \\sum_{i = 1}^{N} \\left(\\frac{|\\vec{p_{i}}|^{2}}{2m} + V(\\vec{x_{i}})\\right) + \\sum_{1\\leq i\u0026lt;j\\leq N} U(\\vec{x_{i}},\\vec{x_{j}}) $$\n$$ V(\\vec{x}) = V_{I}(\\vec{x}) + V_{A}(\\vec{x}) $$ $$ U(\\vec{x}, \\vec{y}) = V_{C}(\\vec{x}-\\vec{y}) - \\frac{1}{N - 1}(V_{A}(\\vec{x}) + V_{A}(\\vec{y})) $$\n$V_{A}(\\vec{x})$ 是辅助势.\nH 的平均场近似, 就相当于令 $U(\\vec{x}, \\vec{y}) = 0$, 这就需要选取合适的 $V_{A}$ 使得单体哈密顿量\n$$ h(\\vec{x}, \\vec{p}) = \\frac{|\\vec{p}|^2}{2m} + V(\\vec{x}) $$\n的本征态之间的有效二体势 $U(\\vec{x}, \\vec{y})$ 很小, 或者 $U(\\vec{x},\\vec{y})$ 在范围和强度上远小于库伦势 $V_{C}(\\vec{x}-\\vec{y})$.\n物理图像 假定大量($N$)个电子都处于哈密顿量 $\\hat{H}$ 的基态 $\\Psi_{0}$, 如果在该体系的局域中放入一个电子, 那么它将感受到离子周期势和其它电子基态的静电势(并且这个静电势受到密度$|\\psi_{0}(\\vec{x_{1}},\\dots,\\vec{x_{N}})|^{2}$ 的影响) 的叠加. 这个势能和离子势同周期且符号相反, 因此会起到屏蔽的作用. 当然实际上, 加入电子也会引起基态密度的微小变化, 但是放入电子只会产生微弱的居于效应这一点是不会改变的. 二次量子化 现在我们尝试使用二次量子化的观点来重写平均场近似下的哈密顿量. 如果要进行二次量子化, 就需要使用合适的基. 在这里我们考虑使用单体哈密顿量 $\\hat{h}$ 的本征态, 因为单体势 $V(\\vec{x})$ 是周期性的, 所以 $\\hat{h}$ 的本征函数必然呈现为布洛赫(Bloch)波的形式:\n$$ \\varphi_{\\alpha,\\vec{k}}(\\vec{x}) = e^{i\\vec{k}\\cdot\\vec{x}}u_{\\alpha, \\vec{k}}(\\vec{x}) $$\n$u_{\\alpha. \\vec{k}}$ 是与晶格同周期的函数, $\\vec{k}$ 是准动量, $\\alpha$ 是能带指标.\n我们将其写作为本征方程的形式:\n$$ \\hat{h}\\varphi_{\\alpha, \\vec{k}}(\\vec{x}) = \\epsilon_{\\alpha, \\vec{k}}\\varphi_{\\alpha, \\vec{k}}(\\vec{x}) $$\n$\\vec{k}$ 遍历整个第一布里渊区, $\\varphi_{\\alpha, \\vec{k}}$ 构成单体态的一组基.\n由Wannier 函数构造方法可知, 存在 $\\phi_{\\alpha}(\\vec{x}-\\vec{R_{i}})$ 提供互补的单体基($\\vec{R_{i}}$ 是格矢)\n$$ \\phi_{\\alpha}(\\vec{x}) = \\frac{1}{\\sqrt{N}}\\sum_{\\vec{k}}\\varphi_{\\alpha, \\vec{k}}(\\vec{x}) $$\n$L$ 代表离子数. Wannier 函数 $\\phi_{\\alpha}(\\vec{x}-\\vec{R_{i}})$ 以 $\\vec{R_{i}}$ 为中心, 不同的 $\\alpha, i$正交.\n所以我们可以通过傅里叶变换的方式将布洛赫波函数表示为 Wannier 函数的线性组合:\n$$ \\varphi_{\\alpha, \\vec{k}} = \\frac{1}{\\sqrt{L}}\\sum_{i}e^{i\\vec{k}\\cdot\\vec{R_{i}}}\\phi_{\\alpha}(\\vec{x}-\\vec{R_{i}}) $$\n对于布洛赫态 $\\varphi_{\\alpha, \\vec{k}}$ 中自旋为 $a$ 的电子, 存在产生算符 $c_{\\alpha,\\vec{k}, a}^{\\dagger}$. 我们写出其傅里叶变换后(即 $c_{\\alpha, i, a}^{\\dagger}$ )的形式:\n$$ c_{\\alpha, i, a}^{\\dagger} = \\frac{1}{\\sqrt{L}}\\sum_{\\vec{k}}e^{-i\\vec{k}\\cdot\\vec{R_{i}}}c_{\\alpha, \\vec{k}, a}^{\\dagger} $$\n所以我们就可以得出场算符的形式:\n$$ \\Psi_{a}^{\\dagger}(\\vec{x}) = \\sum_{\\alpha, \\vec{k}}\\varphi_{\\alpha, \\vec{k}}(\\vec{x})c_{\\alpha, \\vec{k}, a}^{\\dagger} = \\sum_{\\alpha, i}\\phi_{\\alpha}^{*}(\\vec{x} - \\vec{R_{i}})c_{\\alpha, i, a}^{\\dagger} $$\n该算符表示在 $\\vec{x}$ 处产生一个自旋为 $a$ 的电子. $A^{*}$ 表示对 $A$ 取复共轭.\n一般公式 根据以上的推导, 我们可以将原哈密顿量以二次量子化的形式写出来:\n$$ \\hat{H} = \\sum_{a = \\uparrow, \\downarrow}\\iiint\\Psi_{a}^{\\dagger}(\\vec{x})\\hat{h}\\Psi_{a}(\\vec{x})dx^{3} + \\frac{1}{2}\\sum_{a, b = \\uparrow, \\downarrow}\\iiint\\iiint \\Psi_{a}^{\\dagger}(\\vec{x})\\Psi_{b}^{\\dagger}(\\vec{y})U(\\vec{x},\\vec{y})\\Psi_{b}(\\vec{y})\\Psi_{a}(\\vec{x})dx^3 dy^3 $$\n上面的积分符号显得有些冗杂, 你也可以写作下面的形式:\n$$ \\hat{H} = \\sum_{a = \\uparrow, \\downarrow}\\int\\Psi_{a}^{\\dagger}(\\vec{x})\\hat{h}\\Psi_{a}(\\vec{x})dx^{3} + \\frac{1}{2}\\sum_{a, b = \\uparrow, \\downarrow}\\int \\Psi_{a}^{\\dagger}(\\vec{x})\\Psi_{b}^{\\dagger}(\\vec{y})U(\\vec{x},\\vec{y})\\Psi_{b}(\\vec{y})\\Psi_{a}(\\vec{x})dx^3 dy^3 $$\n然后使用 Wannier 基将哈密顿量写作二次量子化的形式：\n$$ \\hat{H} = \\sum_{\\alpha, i, j, a}t_{ij}^{\\alpha}c_{\\alpha,i,a}^{\\dagger}c_{\\alpha,j,a}+\\frac{1}{2}\\sum_{\\alpha,\\beta,\\gamma,\\delta,i,j,k,l}\\sum_{a,b}U_{ijkl}^{\\alpha\\beta\\gamma\\delta}c_{\\alpha,i,a}^{\\dagger}c_{\\beta,j,b}^{\\dagger}c_{\\gamma,k,b}c_{\\delta,l,a} $$\n跃迁矩阵元:\n$$ t_{ij}^{\\alpha} = \\iiint \\phi_{\\alpha}^{*}(\\vec{x}-\\vec{R_{i}})\\hat{h}\\phi_{\\alpha}(\\vec{x}-\\vec{R_{i}})\\mathrm{dx}^{3} = \\frac{1}{L}\\sum_{\\vec{k}}e^{i\\vec{k}\\cdot(\\vec{R_{i}}-\\vec{R_{j}})}\\epsilon_{\\alpha,\\vec{k}} $$\n相互作用参数写作重叠积分形式:\n$$ U_{ijkl}^{\\alpha\\beta\\gamma\\delta} = \\iiint\\iiint\\phi_{\\alpha}^{*}(\\vec{x}-\\vec{R_{i}})\\phi_{\\beta}^{*}(\\vec{y}-\\vec{R{j}})U(\\vec{x},\\vec{y})\\phi_{\\gamma}(\\vec{y}-\\vec{R_{k}})\\phi_{\\delta}(\\vec{x}-\\vec{R_{l}})\\mathrm{dx}^{3}\\mathrm{dy}^{3} $$\n相互作用参数相比于跃迁矩阵元很小时, 在最低阶近似下可以取为0, 而仅在微扰论中考虑. 这种方法就是能带理论.\nHubbard Model Hubbard Model 的得出就是对于二次量子化后的哈密顿量的一些假设, 即原子内的库仑相互作用 $U_{ijkl}^{\\alpha\\beta\\gamma\\delta}$ 相比于原子间相互作用参数很大, 同时相比于跃迁矩阵元不可忽略.\n如果带间的相互作用很弱, 而且 $\\alpha = 1$ 以外的能带都远离费米能级, 我们只关心费米能级附近的区间时, 高能带的影响就可以被视为改变导带中的电子跃迁和相互作用的参数.\n$$ \\hat{H} = \\sum_{ij}t_{ij}c_{i,a}^{\\dagger}c_{j,a} + \\frac{U}{2}\\sum_{i}c_{i,a}^{\\dagger}c_{i,b}^{\\dagger}c_{i,b}c_{i,a} $$\n跃迁矩阵元 $t_{ij}$ 需要在密度泛函理论中才能准确算出. 而 U 的得出更为困难, 需要理论和实验交叉对比得出.\n如果做出进一步的简化要求, 即 Wannier 函数 $\\phi_{\\alpha}(\\vec{x}-\\vec{R_{i}})$ 强局域于 $\\vec{R_{i}}$, 哈密顿量退化为紧束缚模型:\n$$ \\hat{H} = -t\\sum_{\\langle i,j\\rangle}\\hat{c}_{i,a}^{\\dagger}\\hat{c}_{j,a} + U\\sum_{i}\\hat{n}_{i,\\uparrow}\\hat{n}_{i,\\downarrow} $$\n粒子数算符 $$ \\hat{n}_{i,\\uparrow} = \\hat{c}_{i,\\uparrow}^{\\dagger}\\hat{c}_{i,\\uparrow} $$ 和 $$ \\hat{n}_{i,\\downarrow} = \\hat{c}_{i,\\downarrow}^{\\dagger}\\hat{c}_{i,\\downarrow} $$\n$\\langle i,j\\rangle$ 是指对最近邻有序对求和. 最近邻见有着相同的跃迁强度 $-t$.\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/hubbard-model/","summary":"本文用作 ITensor 数值求解 Hubbard Model 的前置理论知识. 背景 因为离子质量远大于电子, 所以可以假定离子构成静态的晶格, 所以我们可以写出哈密顿量: $$ H = \\sum_{i = 1}^{N}\\left(\\frac{|\\vec{p_{i}}|^{2}}{2m} + V_{I}(\\vec{x_{i}})\\right)+\\sum_{1\\leq i\u0026lt;j\\leq N} V_{C}(\\vec{x_{i}}-\\vec{x_{j}}) $$ $N$ 是电子数, $V_{I}(\\vec{x})$ 是离子的周期势, $V_{C}(\\vec{x}) = \\frac{e^2}{||\\vec{x}||}$ 是电子间的库伦排斥作用. 这个式子虽然已经做出很大程度的近似, 但是仍然由于太过复杂无法进行精确求解","title":"强关联模型的基石: Hubbard Model"},{"content":"内容总结于:\n转角石墨烯的实验研究.胡皓东.2022.上海交通大学 氢元素低维纳米结构制备及近场光学表征.吕博赛.2022.上海交通大学 Moiré bands in twisted double-layer graphene.Rafi Bistritzer and Allan H. MacDonald.2011. PNAS 单层石墨烯 晶格 对于单层石墨烯而言, 晶格基矢可以写作\n$$ \\begin{equation} \\vec{a}_{1} = \\frac{a}{2}(3, \\sqrt{3}),\\vec{a}_{2} = \\frac{a}{2}(3,-\\sqrt{3}). \\end{equation} $$\n$a \\approx 1.42 \\overset{\\circ}{A}$ 为碳碳键长度.\n根据倒格矢公式可以计算出倒格基矢\n$$ \\begin{equation} \\vec{b_1} = \\frac{2 \\pi}{3a} ( 1, \\sqrt{3} ), \\vec{b_2} = \\frac{2 \\pi}{3a} ( 1, -\\sqrt{3}). \\end{equation} $$\n而三个最近邻矢量则是\n$$ \\begin{equation} \\delta_{1} = \\frac{a}{2}(1, \\sqrt{3}), \\delta_{2} = \\frac{a}{2}(1, -\\sqrt{3}), \\delta_{3} = a( -1, 0 ) \\end{equation} $$\n用图示来表达这些矢量:\n狄拉克锥即位于$K,K\u0026rsquo;$点.\n在后文中所用到的倒格矢 $\\vec{G_1}, \\vec{G_2}$ 即可从该处导出.\n当我们对倒格矢指标求和从而采取截断时, 我们的方法是采用 $\\vec{0}, \\mathcal{G}^{(2)}, \\mathcal{G}^{(3)}$, 它们对应的是\n虚线圈出的范围是指的旋转前的单层石墨烯的第一布里渊区.\n$\\vec{0}, \\mathcal{G}^{(2)}, \\mathcal{G}^{(3)}$ 连接的是三个等效的狄拉克点. 蓝色圆点表示的是旋转后的上下两层石墨烯的狄拉克点.\n紧束缚模型 只考虑最近邻跃迁,即三个最近邻矢量, 可以写出对应的哈密顿量:\n$$ \\begin{equation} \\hat{H} = t\\sum_{i,j = \\langle i\\rangle}a_{i}^{\\dagger}b_{j} + h.c.. \\end{equation} $$\n$t\\approx 2.7 eV$ 为跃迁系数(最近邻跃迁能量), $a_{i}^{\\dagger}$ 为在 $i$ 位置产生一个电子的产生算符, $b_{j}$ 为在 $j$ 位置湮灭一个电子的湮灭算符.\n使用傅里叶变换将升降算符写成动量空间的形式:\n$$ \\begin{equation} a_{i} = \\sum_{\\vec{k}}e^{i\\vec{k}\\cdot\\vec{r_{i, A}}}a_{\\vec{k}}, \\end{equation} $$\n$$ \\begin{equation} b_{i} = \\sum_{\\vec{k}}e^{i\\vec{k}\\cdot\\vec{r_{i, B}}}b_{\\vec{k}}. \\end{equation} $$\n将上式代入到哈密顿量的式子中, 即有\n$$ \\begin{equation} \\hat{H} = \\sum_{\\vec{k}}h(\\vec{k})=t\\sum_{\\vec{k}}f(\\vec{k})a_{\\vec{k}}^{\\dagger}b_{\\vec{k}} + h.c.. \\end{equation} $$\n$f(\\vec{k}) = e^{i\\vec{k}\\cdot\\delta_{1}} + e^{i\\vec{k}\\cdot\\delta_{2}} + e^{i\\vec{k}\\cdot\\delta_{3}} = \\sum_{i = 1}^{3}e^{i\\vec{k}\\cdot\\delta_{i}}$.\n对这个哈密顿量求本征值, 即有本征能量为\n$$ \\begin{equation} E_{\\pm}(\\vec{k}) = \\pm t|f(\\vec{k})| = \\pm t\\sqrt{3 + 2\\cos\\left(\\sqrt{3}k_{x}a\\right) + 4\\cos\\left(\\frac{\\sqrt{3}}{2}k_{x}a\\right)\\cos\\left(\\frac{3}{2}k_{y}a\\right)} \\end{equation} $$\n更具体的计算方法在紧束缚模型-六方晶格\n超晶格-转角双层石墨烯 Commensuration (共格, 相称) 要产生共格现象, 就需要摩尔超晶格的原胞基矢能够由整数个原晶格基矢组成.\n用公式描述即有\n$$ \\begin{equation} \\vec{A}_{1} = n\\vec{a}_1 + m\\vec{a}_2, \\end{equation} $$\n$$ \\begin{equation} \\vec{A}_{2} = -m\\vec{a}_1 + (n + m)\\vec{a}_2 \\end{equation} $$\n在一个摩尔超晶格中往往会含有上千个原子, 大大超过了密度泛函理论的运算上限, 所以需要使用近似方法.\n紧束缚模型 因为层间距离 $\\approx 0.3 nm$, 大于碳碳键长度 $a \\approx 0.14 nm$, 所以不考虑层间杂化.\n写出紧束缚哈密顿量:\n$$ \\begin{equation} \\hat{H} = \\sum_{i,j}\\omega(i,j)c_{i}^{\\dagger}c_{j} + h.c. \\end{equation} $$\n$i,j$ 是原胞中的原子指标, $c_{i}^{\\dagger}$ 为在 $i$ 位置产生一个电子的产生算符, $c_{j}$ 为在 $j$ 位置湮灭一个电子的湮灭算符, $\\omega(i,j)$ 为跃迁参数.\n描述跃迁参数的公式是这样的:\n$$ \\begin{equation} \\omega(i,j) = V_{\\pi}\\left[1-\\left(\\frac{\\vec{d_{ij}}\\cdot\\hat{z}}{d_{ij}}\\right)^2\\right]e^{-\\frac{d_{ij}-a_{0}}{\\delta}} + V_{\\sigma}\\left(\\frac{\\vec{d_{ij}}\\cdot\\hat{z}}{d_{ij}}\\right)e^{-\\frac{d_{ij}-d_{0}}{\\delta}} \\end{equation} $$\n$\\vec{d_{ij}} = \\vec{r_{i}} - \\vec{r_{j}}$ 是原子间位移矢量. 而 $V_{\\pi} = -2.7 eV$ 为 $\\pi$ 键的跃迁参数, $V_{\\sigma} = 0.48 eV$ 为 $\\sigma$ 键的跃迁参数, $a_{0} = 0.142 nm$ 为碳碳键长度, $d_{0} = 0.335 nm$ 为层间距离, $\\delta = 0.045 nm$ 为衰减长度.\n和单层石墨烯中的计算处理一样, 我们需要将这里的升降算符通过傅里叶变换写成动量空间的形式:\n$$ \\begin{equation} c_{i} = \\sum_{\\vec{k}}e^{i\\vec{k}\\cdot(\\vec{r_{i}} + \\vec{R})}c_{\\vec{k}}^{I} \\end{equation} $$\n$\\vec{R}$ 是包含第i个原子的原胞的原点绝对位置, $\\vec{r}_{i}$ 则是相对于原胞内原点的相对位移, $I = 1,\\dots,N$ 则是指的原胞内第 $i$ 个原子.\n代入后得到哈密顿量的动量形式:\n$$ \\begin{equation} \\hat{H} = \\sum_{\\vec{k}}h(\\vec{k}) = \\sum_{\\vec{k}}\\sum_{I,J}h_{IJ}(\\vec{k})c_{\\vec{k}}^{I,\\dagger}c_{\\vec{k}}^{J} + h.c.. \\end{equation} $$\n$h_{IJ}(\\vec{k}) = \\sum_{\\vec{R}}\\omega(\\vec{r_{I}}+\\vec{R},\\vec{r_{J}})e^{i\\vec{k}\\cdot(\\vec{r_{I}}+\\vec{R}-\\vec{r_{J}})}$ 为跃迁矩阵.\n然而, 对于 $N \\approx 10^4$ 的数据规模进行对角化是十分困难的.\n$N \\approx 10^4$ 这个数字来源于这样的计算:摩尔超晶格原胞面积变为原先的 $\\theta^{-2}$ 倍, 则其中的原子数量也增长了 $\\theta^{-2}$ 倍, 所以对于 $\\theta \\approx 1°$ 的TBG, 超晶格的原胞大约存在 $10^{4}$ 个原子.\n紧束缚模型可以准确给出能带结构, 但是其角度是从原子和原子之间的相互作用出发的, 而并不能和摩尔超晶格联系起来.\n连续模型 在低能条件下, 连续模型不仅适用于共格的摩尔超晶体, 也同样适用于并无共格性的叠加晶体.\n建立这样一个哈密顿量, 其中主对角线上的元素是单层石墨烯的狄拉克哈密顿量, 而副对角线上的元素则是描述层间跃迁的隧穿项.\n对于单层的石墨烯, 其狄拉克哈密顿量是这样表示的:\n$$ \\begin{equation} h_{\\vec{K}}(\\vec{q})=\\hbar v_{F}|\\vec{q}| \\begin{bmatrix} 0 \u0026amp; e^{-i\\theta_{\\vec{q}}} \\\\ e^{i\\theta_{\\vec{q}}} \u0026amp; 0 \\\\ \\end{bmatrix} \\end{equation} $$\n$\\theta_{\\vec{q}} = \\tan^{-1}(q_{y}/q_{x})$\n所以对于相对转角为 $\\theta$ 的双层石墨烯, 其单层的狄拉克哈密顿量可以分别写作:\n$$ \\begin{equation} h_{\\vec{K}}^{1}(\\vec{q})=\\hbar v_{F}|\\vec{q}| \\begin{bmatrix} 0 \u0026amp; e^{-i(\\theta_{\\vec{q}}+\\theta/2)} \\\\ e^{i(\\theta_{\\vec{q}}+\\theta/2)} \u0026amp; 0 \\\\ \\end{bmatrix} =\\hbar v_{F}\\sigma^{\\theta/2}\\cdot\\vec{q}, \\end{equation} $$\n$$ \\begin{equation} h_{\\vec{K}}^{2}(\\vec{q})=\\hbar v_{F}|\\vec{q}| \\begin{bmatrix} 0 \u0026amp; e^{-i(\\theta_{\\vec{q}}-\\theta/2)} \\\\ e^{i(\\theta_{\\vec{q}}-\\theta/2)} \u0026amp; 0 \\\\ \\end{bmatrix} =\\hbar v_{F}\\sigma^{-\\theta/2}\\cdot\\vec{q}. \\end{equation} $$\n它们各自作用在单层石墨烯的 $A$, $B$ 子格上, 所以对于整体的哈密顿量而言, 是作用在 $\\begin{bmatrix} \\alpha_{\\vec{q}} \\ \\beta_{\\vec{q}} \\ \\end{bmatrix}$ 这样一个两分量的旋量上的.\n接下来要解决的时层间隧穿项. 我们将层间跃迁的矩阵元写出来:\n$$ \\begin{equation} T_{\\vec{k}\\vec{p}\u0026rsquo;}^{\\alpha\\beta} = \\langle \\Psi_{\\vec{k}\\alpha}^{(1)}|\\hat{H_{T}}|\\Psi_{\\vec{p}\u0026rsquo;\\beta}^{(2)}\\rangle \\end{equation} $$\n该矩阵元描述的是一个动量为 $\\vec{p}\u0026rsquo;=M(\\theta)\\vec{p}$ 的电子,在第二层的 $\\beta$ 子格上, 通过层间跃迁到第一层的 $\\alpha$ 子格上, 成为动量为 $\\vec{k}$ 的态的过程, $M(\\theta)$ 是一个旋转矩阵.\n我们用紧束缚模型的思路将波函数的形式写出来:\n$$ \\begin{equation} |\\Psi_{\\vec{k}\\alpha}^{(1)}\\rangle=\\frac{1}{\\sqrt{N}}\\sum_{\\vec{R}}e^{i\\vec{k}\\cdot(\\vec{R}+\\vec{\\tau_{\\alpha}})}|\\vec{R}+\\vec{\\tau_{\\alpha}}\\rangle, \\end{equation} $$\n$$ \\begin{equation} |\\Psi_{\\vec{p}\u0026rsquo;\\beta}^{(2)}\\rangle=\\frac{1}{\\sqrt{N}}\\sum_{\\vec{R\u0026rsquo;}}e^{i\\vec{p}\u0026rsquo;\\cdot(\\vec{R\u0026rsquo;}+\\vec{\\tau_{\\beta}}\u0026rsquo;)}|\\vec{R\u0026rsquo;}+\\vec{\\tau_{\\beta}}\u0026rsquo;\\rangle. \\end{equation} $$\n$\\tau_{A} = 0, \\tau_{B} = \\tau$. $\\vec{R}$ 是对所有三角布拉维格子求和的指标.\n我们不妨选取 $AB$ 堆叠处作为原点, 那么就有关系式\n$$ \\begin{equation} \\vec{R\u0026rsquo;} = M(\\theta)(\\vec{R}-\\tau) + d \\end{equation} $$\n$d$ 是层间间距.\n将波函数代入到层间跃迁矩阵元中, 并且采用两中心近似, 就能得到层间跃迁矩阵元:\n$$ \\begin{equation} T_{\\vec{k}\\vec{p}\u0026rsquo;}^{\\alpha\\beta}=\\frac{1}{N} \\sum_{\\vec{R}}\\sum_{\\vec{R}\u0026rsquo;} e^{i[-\\vec{k}(\\vec{R}+\\tau_{\\alpha})+\\vec{p}\u0026rsquo;(\\vec{R}\u0026rsquo;+\\tau_{\\beta}\u0026rsquo;)]} t(\\vec{R}+\\tau_{\\alpha}-\\vec{R}\u0026rsquo;-\\tau_{\\beta}\u0026rsquo;) \\end{equation} $$\n两中心近似, 指的是假设电子只和起始原子和终止原子之间的原子相互作用, 而忽略了其他原子的影响. 用公式可以这样描述: $$ \\begin{equation} \\langle\\vec{R}+\\tau_{\\alpha}|\\hat{H_T}|\\vec{R\u0026rsquo;}+\\tau_{\\beta}\u0026rsquo;\\rangle = t(\\vec{R}+\\tau_{\\alpha}-\\vec{R}\u0026rsquo;-\\tau_{\\beta}\u0026rsquo;) \\end{equation} $$ 因为转角双层石墨烯中碳碳键很小, 所以这个式子用来描述电子跃迁的过程非常好用.\n利用傅里叶变换, 我们可以将两中心近似所用的式子转为动量空间的形式.\n$$ \\begin{equation} T_{\\vec{k}\\vec{p}\u0026rsquo;}^{\\alpha\\beta}=\\frac{1}{N^2} \\sum_{\\vec{R}}\\sum_{\\vec{R}\u0026rsquo;}\\sum_{\\vec{q_1}}\\sum_{\\vec{q_2}} e^{i[-\\vec{k}(\\vec{R}+\\tau_{\\alpha})+\\vec{p}\u0026rsquo;(\\vec{R}\u0026rsquo;+\\tau_{\\beta}\u0026rsquo;)]} e^{i[\\vec{q_1}(\\vec{R}+\\tau_{\\alpha})-\\vec{q_2}(\\vec{R}\u0026rsquo;+\\tau_{\\beta}\u0026rsquo;)]} \\frac{t_{\\vec{q}}}{\\Omega} \\end{equation} $$\n这个式子非常长, 但是我们可以通过一些和式结论来简化这个式子:\n$$ \\begin{equation} \\sum_{\\vec{R}}e^{i(\\vec{q_1}-\\vec{k})\\vec{R}} = N\\delta_{\\vec{q_1}-\\vec{k}, \\vec{G_1}}, \\end{equation} $$\n$$ \\begin{equation} \\sum_{\\vec{R}\u0026rsquo;}e^{-i(\\vec{q_2}-\\vec{p}\u0026rsquo;)(\\vec{R}\u0026rsquo;-\\vec{d}+\\tau\u0026rsquo;)} = N\\delta_{\\vec{q_2}-\\vec{p}\u0026rsquo;, \\vec{G_2}\u0026rsquo;}. \\end{equation} $$\n最后我们就得到了层间跃迁矩阵元:\n$$ \\begin{equation} T_{\\vec{k}\\vec{p}\u0026rsquo;}^{\\alpha\\beta}=\\sum_{\\vec{G_1}\\vec{G_2}}\\frac{t_{\\overline{\\vec{k}}+\\vec{G_1}}}{\\Omega} e^{i[\\vec{G_1}\\tau_{\\alpha}-\\vec{G_2}(\\tau_{\\beta}-\\tau)-\\vec{G_2}\u0026rsquo;\\vec{d}]}\\delta_{\\overline{\\vec{k}}+\\vec{G_1},\\overline{\\vec{p}}\u0026rsquo;+\\vec{G_2}\u0026rsquo;} \\end{equation} $$\n$\\Omega$ 是原胞面积, $t_{\\vec{q}}$ 是隧穿幅值 $t(\\vec{r})$ 的傅里叶变换, $\\vec{G_1}, \\vec{G_2}$ 是倒格矢, 上标代表 $\\vec{G}_i = M(\\theta)\\vec{G}_i$. 而上划线则表示动量起点是布里渊区的中心.\n对于狄拉克点附近的动量而言, 如果要让 $t_q$ 值足够大, 那么可以对层间矩阵元 $T_{\\vec{k}\\vec{p}\u0026rsquo;}^{\\alpha\\beta}$ 中的 $\\vec{G_1}$指标采取截断, 具体来说就是只保留 $\\vec{0},\\mathcal{G}^{(2)}, \\mathcal{G}^{(3)}$ 三项.\n注意到总有关系式 $$ \\begin{equation} \\overline{\\vec{k}} + \\vec{G_1} = \\overline{\\vec{p}}\u0026rsquo; + \\vec{G_2}' \\end{equation} $$ 成立\n所以当 $\\vec{G_1}$ 被选定, 实际上对应的 $\\vec{G_2}\u0026rsquo;$ 可以被选定(这意味着跃迁发生在一层狄拉克点邻域到另一层狄拉克点邻域).\n再回头看看前面晶格部分内容里展示的\n我们假定, 在低能模型下, 只有 $q_b, q_{tr}, q_{tl}$ 对应的三个跃迁过程有意义. 具体到电子态, 即\n$$ |\\vec{k_{\\alpha}}^{(1)}\\rangle \\rightarrow |(\\vec{k}+\\vec{k_{\\theta}})_{\\beta}^{(2)}\\rangle $$\n$$ |\\vec{k_{\\alpha}}^{(1)}\\rangle \\rightarrow |(\\vec{k}+\\vec{k_{\\theta}}-\\vec{G_1})_{\\beta}^{(2)}\\rangle $$\n$$ |\\vec{k_{\\alpha}}^{(1)}\\rangle \\rightarrow |(\\vec{k}+\\vec{k_{\\theta}}-\\vec{G_2})_{\\beta}^{(2)}\\rangle $$\n$$ |k_{\\theta}| = |\\vec{K} - \\vec{K}\u0026rsquo;| = 2k_{D}\\sin{\\frac{\\theta}{2}} $$\n其对应的跃迁矩阵元中的分量即为\n$$ \\begin{equation} T_{1} = \\frac{t_{k_{D}}}{\\Omega} \\begin{bmatrix} 1 \u0026amp; 1\\\\ 1 \u0026amp; 1\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_{2} = \\frac{t_{k_{D}}}{\\Omega}e^{-i\\mathcal{G}^{(2)\u0026rsquo;}\\cdot\\vec{d}} \\begin{bmatrix} e^{-i\\Phi} \u0026amp; 1\\\\ e^{i\\Phi} \u0026amp; e^{-i\\Phi}\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_{3} = \\frac{t_{k_D}}{\\Omega}e^{-i\\mathcal{G}^{(3\u0026rsquo;)}\\cdot\\vec{d}} \\begin{bmatrix} e^{i\\Phi} \u0026amp; 1\\\\ e^{-i\\Phi} \u0026amp; e^{i\\Phi} \\\\ \\end{bmatrix} \\end{equation} $$\n$\\phi = 2\\pi/3$, 该数值来源于 $\\mathcal{G}^{(2)}\\cdot\\tau$\n四个矩阵元分别指代 $AA, AB, BA, BB$ 四种跃迁的子格排布.\n前面我们已经提到, 对于一个超晶格网络上的态 $|(\\vec{k}+m\\vec{G_1}+n\\vec{G_2})^{1}\\rangle$ 对应三个跃迁过程:\n$$ \\begin{equation} |(\\vec{k}+m\\vec{G_1}+n\\vec{G_2})^{(1)}\\rangle\\rightarrow|(\\vec{k}+\\vec{k_{\\theta}}+m\\vec{G_1}+n\\vec{G_2})^{(2)}\\rangle, \\end{equation} $$\n$$ \\begin{equation} |(\\vec{k}+m\\vec{G_1}+n\\vec{G_2})^{(1)}\\rangle\\rightarrow|(\\vec{k}+\\vec{k_{\\theta}}+(m - 1)\\vec{G_1}+n\\vec{G_2})^{(2)}\\rangle, \\end{equation} $$\n$$ \\begin{equation} |(\\vec{k}+m\\vec{G_1}+n\\vec{G_2})^{(1)}\\rangle\\rightarrow|(\\vec{k}+\\vec{k_{\\theta}}+m\\vec{G_1}+(n - 1)\\vec{G_2})^{(2)}\\rangle \\end{equation} $$\n$$ m = -M, \\dots,-1, 0, 1, \\dots, M $$\n$$ n = -N, \\dots,-1, 0, 1, \\dots, N $$\n一般采取 $M = N = 4$ 的截断即可取得理想计算结果.\n使用指标 $\\vec{q}$ 来替换 $\\vec{k}$, 具体来说是\n$$ \\vec{q} = \\vec{k} - \\vec{K} $$\n所以我们就可以定义基底\n$$ \\begin{equation} |q\\rangle= \\begin{bmatrix} |(\\vec{q}-M\\vec{G_1}-N\\vec{G_2})^{(1)}\\rangle\\\\ |(\\vec{q}-(M-1)\\vec{G_1}-N\\vec{G_2})^{(1)}\\rangle\\\\ \\dots\\\\ |(\\vec{q}+M\\vec{G_1}-N\\vec{G_2})^{(1)}\\rangle\\\\ |(\\vec{q}-M\\vec{G_1}-(N-1)\\vec{G_2})^{(1)}\\rangle\\\\ |(\\vec{q}-(M-1)\\vec{G_1}-(N-1)\\vec{G_2})^{(1)}\\rangle\\\\ \\dots\\\\ |(\\vec{q}+M\\vec{G_1}-(N-1)\\vec{G_2})^{(1)}\\rangle\\\\ |(\\vec{q}+M\\vec{G_1}+N\\vec{G_2})^{(1)}\\rangle\\\\ \\dots\\\\ |(\\vec{q}+\\vec{k_{\\theta}}-M\\vec{G_1}-N\\vec{G_2})^{(2)}\\rangle\\\\ \\dots\\\\ |(\\vec{q}+\\vec{k_{\\theta}}+M\\vec{G_1}+N\\vec{G_2})^{(2)}\\rangle\\\\ \\end{bmatrix} \\end{equation} $$\n计算可知该基底长度为 $(2M+1)(2N+1)$\n其中的每个姿态都对应着 $A/B$ 子格的二分量旋量.\n我们写出整个系统的哈密顿量:\n接下来的公式会很长: 确保你的 Markdown 阅读器支持滑轮显示公式, 或者使用带鱼屏.\n$$ \\begin{equation} h^{\\vec{K}}(\\vec{q})=h_{ij}= \\begin{bmatrix} h_{\\vec{K}}^{(1)}(\\vec{q}-M\\vec{G_1}-N\\vec{G_2}) \u0026amp; 0 \u0026amp;\\dots\u0026amp; 0 \u0026amp; T^{1} \u0026amp; 0 \u0026amp; \\dots \u0026amp; 0\\\\ 0 \u0026amp; h_{\\vec{K}}^{(1)}(\\vec{q}-(M - 1)\\vec{G_1}-N\\vec{G_2}) \u0026amp;\\dots \u0026amp; 0 \u0026amp; T^{2} \u0026amp; T^{1} \u0026amp; \\dots \u0026amp; 0\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ 0 \u0026amp; 0 \u0026amp; \\dots \u0026amp; h_{\\vec{K}}^{(1)}(\\vec{q}+M\\vec{G_1}+N\\vec{G_2}) \u0026amp; 0 \u0026amp; 0 \u0026amp; \\dots \u0026amp; T^{1}\\\\ T^{1\\dagger} \u0026amp; T^{2\\dagger} \u0026amp; \\dots \u0026amp; 0 \u0026amp; h_{\\vec{K}}^{(2)}(\\vec{q}+\\vec{k_{\\theta}}-M\\vec{G_1}-N\\vec{G_2}) \u0026amp; 0 \u0026amp; \\dots \u0026amp; 0\\\\ 0 \u0026amp; T^{1\\dagger} \u0026amp; \\dots \u0026amp; 0 \u0026amp; 0 \u0026amp; h_{\\vec{K}}^{(2)}(\\vec{q}+\\vec{k_{\\theta}}-(M - 1)\\vec{G_1}-N\\vec{G_2}) \u0026amp; \\dots \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\dots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\dots \u0026amp; T^{1\\dagger} \u0026amp; 0 \u0026amp; 0 \u0026amp; \\dots \u0026amp; h_{\\vec{K}}^{(2)}(\\vec{q}+\\vec{k_{\\theta}}+M\\vec{G_1}+N\\vec{G_2})\\\\ \\end{bmatrix} \\end{equation} $$\n对角矩阵元是旋转后的单层狄拉克哈密顿量; 非对角元代表态之间的跃迁矩阵. 因为我们只考虑了最近邻跃迁, 所以非对角元只有 $0, T^{1}, T^{2}$ 三种.\n由此得到总哈密顿量\n$$ \\begin{equation} \\hat{H_{ctn}^{\\vec{k}}}=\\sum_{\\vec{q}}h^{\\vec{K}}(\\vec{q})|\\vec{q}\\rangle\\langle\\vec{q}| \\end{equation} $$\n连续模型在这里还需要对进行进一步的修正.\n在上述的模型中， 我们架设了单层石墨烯晶格是刚性的， 即保持参数 $a = 0.142nm$ 和 $d = 0.33nm$ 不变, 但是为了使得系统处于稳定性(也就是 $\\partial_{\\vec{x}}U=0$), 碳原子实际上会尽可能避免靠得太近.\n转角双层石墨烯具有不同的堆叠类型:\n$AA(BB)$ 型: 上下两层子格完全相同, 位置垂直对齐; $AB$ 型: 上层的 $A$ 原子与下层的 $B$ 原子对齐, 而上层的 $B$ 原子与下层的 $A$ 原子并不对齐; $BA$ 型 : 上层的$B$ 原子与下层的 $A$ 原子对齐, 而上层的 $B$ 原子与下层的 $A$ 原子并不对齐. 我们从曹原给出的参考图来体会这三种类型, 以及它们是如何整体体现在晶格网络上的:\n对于转角双层石墨烯, 弛豫效应也会对电子能带产生显著影响.\n弛豫效应\n在这里的语境下指的是材料中的原子位置会因为某些扰动而发生微小位移, 在计算能带的时候需要将这种位移考虑进去.\n$AA$ 堆叠中原子相互靠得很近, 这会使得势能变得更高, 所以会存在一种趋势, 使得 $AA$ 区域发生扭曲与拉伸, 从而接近于 $AB$ 堆叠区域. 这样的趋势会带来两种后果:\n$d_{AA}\u0026gt;d_{AB}=d_{BA}$. 我们将这种行为称为屈伸($\\text{builkling}$)或者褶皱($\\text{corrugation}$); $AA$ 区域面积收缩, 使得 $AA$ 区域转动更大, $AB$ 区域转动更小. 于是就形成了图上右部分的拓扑连接的结构.\n在转角石墨烯中的摩尔能带一文中我们已经知道, 转角双层石墨烯的能谱在 $\\theta\\neq 0$ 时, 与 $\\vec{d}$ 无关. 所以我们可以把 $T_1, T_2, T_3$ 重写一遍:\n$$ \\begin{equation} T_1=w\\begin{bmatrix} 1 \u0026amp; 1\\\\ 1 \u0026amp; 1\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_2=w\\begin{bmatrix} 1 \u0026amp; \\omega^{\\star}\\\\ \\omega \u0026amp; 1\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_3=w\\begin{bmatrix} 1 \u0026amp; \\omega\\\\ \\omega^{\\star} \u0026amp; 1\\\\ \\end{bmatrix}. \\end{equation} $$\n为了引入弛豫效应, 我们引入 $w\u0026rsquo;\u0026lt;w$, 它代表着 $AA$ 堆叠中有着更大的 $a$ 和更小的 堆叠区域面积. 于是我们就有\n$$ \\begin{equation} T_1=\\begin{bmatrix} w\u0026rsquo; \u0026amp; w\\\\ w \u0026amp; w\u0026rsquo;\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_2=\\begin{bmatrix} w\u0026rsquo; \u0026amp; w\\omega^{\\star}\\\\ w\\omega \u0026amp; w\u0026rsquo;\\\\ \\end{bmatrix}, \\end{equation} $$\n$$ \\begin{equation} T_3=\\begin{bmatrix} w\u0026rsquo; \u0026amp; w\\omega\\\\ w\\omega^{\\star} \u0026amp; w\u0026rsquo;\\\\ \\end{bmatrix}. \\end{equation} $$\n$w = \\frac{t_{k_{D}}}{\\Omega}, \\omega = e^{i2\\pi/3}$\n我们分别求解\u0026rsquo;不考虑弛豫效应\u0026rsquo;和\u0026rsquo;考虑弛豫效应\u0026rsquo;的情况下的能带结构, 可以得到其对比图像:\n该图引自:转角石墨烯的实验研究.胡皓东.2022.上海交通大学.\n其中, 我们重点对比 (b) 和 (d)(或者(f)和(h)), (d) 和 (h) 是未考虑弛豫效应的情况. 不难发现, 弛豫效应使得 $\\Gamma$ 点的能隙明显增大, 并且出现了新的能带, 该能带在很大的 $k$ 空间内都是近似相等的, 我们将这种能带称为平带.\n平带使得能量为0时的态密度可以急剧增加, 而态密度会影响热学和电学等诸多性质.\n同样是在转角石墨烯中的摩尔能带中, 作者介绍了狄拉克点速度随着 $\\theta$ 变化的情况.\n$$ \\frac{v^{\\star}}{v}=\\frac{1-3\\alpha^2}{1+6\\alpha^2} $$\n$\\alpha = w/\\hbar vk_{\\theta}$\n$$ \\lim_{\\alpha\\rightarrow 0}\\frac{v^{\\star}}{v} = 1 -9\\alpha^2 $$\n当$1 -9\\alpha^{2}=0$, 这就是\u0026rsquo;魔角\u0026rsquo;$\\theta_{1} \\approx 1.1°$ 的来源.\n对于后续的魔角, 对应的规一化狄拉克点速度图像则是这样的:\n","permalink":"https://Muatyz.github.io/posts/phy/cmp/tbg-nu-cal/","summary":"内容总结于: 转角石墨烯的实验研究.胡皓东.2022.上海交通大学 氢元素低维纳米结构制备及近场光学表征.吕博赛.2022.上海交通大学 Moiré bands in twisted double-layer graphene.Rafi Bistritzer and Allan H. MacDonald.2011. PNAS 单层石墨烯 晶格 对于单层石墨烯而言, 晶格基矢可以写作 $$ \\begin{equation} \\vec{a}_{1} = \\frac{a}{2}(3, \\sqrt{3}),\\vec{a}_{2} = \\frac{a}{2}(3,-\\sqrt{3}). \\end{equation} $$ $a \\approx 1.42 \\overset{\\circ}{A}$ 为碳碳键长度. 根据倒格矢公式可以计算出","title":"转角双层石墨烯的数值计算综述"},{"content":"标记以下心仪的 fumo 的再贩时间.\n名词解释\n受注生产\n\u0026ldquo;受注生产\u0026rdquo; 是指根据顾客的订单进行生产也就是说, Gift 社并不会提前生产一定数量的商品，而是根据订单量进行生产。这种销售方式可以确保商品的品质和数量，同时也可以避免因为生产过剩而导致的库存积压问题。\n通贩\n指通过网络等渠道进行销售的方式。顾客可以在Gift社的官方网站或其他合作伙伴的网站上进行购买，商品会通过快递等方式直接送达顾客手中。这种销售方式方便快捷，可以让顾客在家中就能轻松购买到心仪的商品。\n角色-型号 可能的再贩时间 *芙兰朵露 -20 cm 2023年8月 *蕾米莉亚 -20 cm 2023年8月 *十六夜咲夜 -20 cm 2023年8月 红美铃(v1.5) 时间线:\n2023.05.22 下订单, 选择支付方式为 PayPal; 2023.05.23 收到 AmiAmi 的请款邮件. 由于支付失败, 修改订单支付方式为银联; 2023.05.23 修改订单支付方式失败, 被系统自动改回 PayPal; 2023.05.23 完成 Paypal 支付, 收到支付确认邮件; 2023.05.29 向 AmiAmi 发送发货咨询邮件, 随后收到回复以及当天的发货邮件; ","permalink":"https://Muatyz.github.io/posts/life/fumo-purchase/","summary":"标记以下心仪的 fumo 的再贩时间. 名词解释 受注生产 \u0026ldquo;受注生产\u0026rdquo; 是指根据顾客的订单进行生产也就是说, Gift 社并不会提前生产一定数量的商品，而是根据订单量进行生产。这种销售方式可以确保商品的品质和数量，同时也可以避免因为生产过剩而导致的库存积压问题。 通贩 指通过网络等渠道","title":"fumo购买全流程攻略"},{"content":"","permalink":"https://Muatyz.github.io/posts/life/life/","summary":"","title":"你可能需要特殊手段才能读取里面的内容"},{"content":"扯蛋模型\n导师评价网\n","permalink":"https://Muatyz.github.io/posts/life/interesting/","summary":"扯蛋模型 导师评价网","title":"有趣的网站收藏清单"},{"content":"Moiré bands in twisted double-layer graphene 双层石墨烯出现转角时, 在整体层面会出现摩尔纹.\nAbstract A moiré pattern is formed when two copies of a periodic pattern are overlaid with a relative twist. We address the electronic structure of a twisted two-layer graphene system, showing that in its continuum Dirac model the moiré pattern periodicity leads to moiré Bloch bands. The two layers become more strongly coupled and the Dirac velocity crosses zero several times as the twist angle is reduced. For a discrete set of magic angles the velocity vanishes, the lowest moiré band flattens, and the Dirac-point density-of states and the counterflow conductivity are strongly enhanced.\n译:\n当一个周期性图案的两个副本以一定扭转角的方式叠加在一起时, 就会形成摩尔纹图案.\n我们讨论了扭曲的两层石墨烯系统的电子结构, 表明在其连续的狄拉克模型中, 摩尔纹的周期性导致了摩尔布洛赫带.\n两层石墨烯变得更加强烈的耦合, 并且随着扭曲角度的减小, 狄拉克速度多次过零.\n对于一组离散的魔角, 速度消失, 最低的摩尔带变平, 迪拉克点态密度和逆流电导率强烈增强.\nLow-energy electronic properties of few layer graphene (FLG) systems are known (1–8) to be strongly dependent on stacking arrangement. In bulk graphite 0° and 60° relative orientations of the individual layer honeycomb lattices yield rhombohedral and Bernal crystals, but other twist angles also appear in many samples (9). Small twist angles are particularly abundant in epitaxial graphene layers grown on SiC (10, 11), but exfoliated bilayers can also appear with a twist, and arbitrary alignments between adjacent layers can be obtained by folding a single graphene layer(12, 13)\n译:\n众所周知（1-8）, 少层石墨烯（FLG）系统的能量电子特性在很大程度上取决于堆叠排列.\n在散装石墨中, 单个层蜂窝状晶格的0°和60°相对方向产生斜方体和贝纳尔晶体, 但其他扭曲角也出现在许多样品中（9）.\n在SiC上生长的外延石墨烯层中, 小扭曲角特别多（10, 11）, 但剥离的双层也会出现扭曲, 而且相邻层之间的任意排列可以通过折叠单个石墨烯层获得（12, 13）.\n贝纳尔晶体\n是一种液体流体现象, 它在一定条件下会形成有规律的细胞状结构, 这些细胞状结构有明确的界限, 形状规则, 大小一致, 并且呈现出有序的排列.\nRecent advances in FLG preparation methods have attracted theoretical attention (14–20) to the intriguing electronic properties of systems with arbitrary twist angles, usually focusing on the two-layer case. The geometry of the bilayer system is characterized by a twist angle θ and by a translation vector d. Commensurability is determined only by θ. Sliding one layer with respect to the other in a commensurate structure modifies the unit cell but leaves the bilayer crystalline. In this work we find it convenient to regard the AB stacking as the aligned configuration. The positions of the carbon atoms in the two misaligned layers labeled by R and R\u0026rsquo; are then related by $\\vec{R\u0026rsquo;}=M(θ)(\\vec{R}-\\tau)+\\vec{d}$, where M is a 2-D rotation matrix within the graphene plane, and $\\tau$ is a vector connecting the two atoms in the unit cell.\n译:\n最近FLG制备方法的进展, 吸引了理论界对任意扭曲角下系统的有趣电子特性的关注(14-20).(特别是双层系统的情况)\n双层系统的几何特征是由扭曲角θ和平移矢量d决定的.在这项工作中, 我们发现将AB堆叠视为对齐的配置是很方便的.\n在两个错位的层中, 碳原子的位置由 $R$ 和 $R\u0026rsquo;$ 标记, 然后由 $\\vec{R\u0026rsquo;}=M(θ)(\\vec{R}-\\tau)+\\vec{d}$ 公式进行关联, 其中M是石墨烯平面内的2维旋转矩阵, $\\tau$ 是连接单元格中两个原子的矢量.\nThe problem is mathematically interesting because a bilayer forms a two-dimensional crystal only at a discrete set of commensurate rotation angles; for generic twist angles Bloch’s theorem does not apply microscopically and direct electronic structure calculations are not feasible. For twist angles larger than a few degrees the two layers are electronically isolated to a remarkable degree, except at a small set of angles which yield low-order commensurate structures (16, 19). As the twist angles become smaller, interlayer coupling strengthens, and the quasiparticle velocity at the Dirac point begins to decrease.\n译:\n这个问题在数学上是有趣的, 因为双层晶体只在一组离散的相称旋转角下形成；对于一般的扭转角, 布洛赫定理在显微镜下并不适用, 直接的电子结构计算是不可行的.\n对于大于几度的扭转角, 除了在一小部分产生低阶相称结构的角度外, 两层的电子隔离程度很高（16, 19）.随着扭曲角的变小, 层间耦合加强, 迪拉克点的准粒子速度开始下降.\n人话:\nθ减小的时候,层间相互作用增强,狄拉克点就是能带的零点,零点向动量原点移动,也就是对应的准速度降低了.\nHere we focus on the strongly coupled small twist angle regime. We derive a low-energy effective Hamiltonian valid for any value of d and for θ ≲ 10° irrespective of whether or not the bilayer structure is periodic. We show that it is meaningful to describe the electronic structure using Bloch bands even for incommensurate twist angles and study the dependence of these bands on θ.\n译:\n在此, 我们重点讨论强耦合的小扭曲角机制.\n我们推导出了一个低能量条件下的有效哈密顿量(对任何d值和θ≲10°都有效,无论双层结构是否是周期性的).\n我们证明, 即使对于不相称的扭转角, 用布洛赫带描述电子结构也是有意义的, 并研究了这些能带对θ的依赖性.\nModel We construct a low-energy continuum model Hamiltonian that consists of three terms: two single-layer Dirac–Hamiltonian terms that account for the isolated graphene sheets and a tunneling term that describes hopping between layers. The Dirac–Hamiltonian (21) for a layer rotated by an angle θ with respect to a fixed coordinate system is\n$$ v_k= vk\\begin{bmatrix} 0 \u0026amp; e^{i(θ_{k}-θ)} \\\\ e^{-i(θ_{k}-θ)} \u0026amp; 0 \\\\ \\end{bmatrix} $$\nwhere v is the Dirac velocity, k is momentum measured from the layer’s Dirac point, $θ_k$ is the momentum orientation relative to the x axis, and the spinor Hamiltonian acts on the individual layer’s A and B sublattice degrees-of-freedom. We choose the coordinate system depicted in Fig. 1 for which the decoupled bilayer Hamiltonian is $|1\\rangle h(θ/2)\\langle 1|+|2\\rangle h(-θ/2)\\langle 2|$, where $|i\\rangle\\langle i|$ projects onto layer $i$.\n译:\n我们构建了一个低能连续模型下的哈密顿量, 它由三个项组成：两个单层狄拉克-哈密顿项(代表孤立的石墨烯层), 一个\u0026quot;Tunneling\u0026quot;项(TUNNEL可以理解为隧穿的过程), 描述层间的跳跃.\n相对于固定坐标系, 旋转一个角度θ的层的狄拉克-哈米顿项（21）为\n$$v_k= vk\\begin{bmatrix} 0 \u0026amp; e^{i(θ_{k}-θ)} \\\\ e^{-i(θ_{k}-θ)} \u0026amp; 0 \\\\ \\end{bmatrix} $$\n其中v是狄拉克速度, k是从层的狄拉克点测得的动量, $θ_k$ 是相对于X轴的动量方向, 自旋体哈密尔顿作用于各个层的A和B子晶格自由度.\n我们选择图1中描述的坐标系, 对于该坐标系, 解耦双层哈密顿式为 $|1\\rangle h(θ/2)\\langle 1|+|2\\rangle h(-θ/2)\\langle 2|$, 其中 $|i\\rangle\\langle i|$ 投射到层 $i$.\nWe derive a continuum model for the tunneling term by assuming that the interlayer tunneling amplitude between π-orbitals is a smooth function $t(r)$ of spatial separation projected onto the graphene planes. The matrix element $T_{\\vec{k}\\vec{p\u0026rsquo;}}^{αβ}=\\langle Ψ_{\\vec{k}}^{(1)}|H_{T}|Ψ_{\\vec{p\u0026rsquo;}β}^{(2)}\\rangle$ of the tunneling Hamiltonian HT describes a process in which an electron with momentum $\\vec{p\u0026rsquo;}=M\\vec{p}$ residing on sublattice β in one layer hops to a momentum state $\\vec{k}$ and sublattice α in the other layer. In a π-band tight-binding model the projection of the wave functions of the two layers to a given sublattice are $|\\Psi_{\\vec{k}α}^{(1)}=\\frac{1}{\\sqrt{N}}∑_{\\vec{R}}e^{i\\vec{k}(R+\\tau_{α})}|\\vec{R}+\\tau_{α}\\rangle$ and $|\\Psi_{\\vec{p}β}^{(2)}=\\frac{1}{\\sqrt{N}}∑_{\\vec{R\u0026rsquo;}}e^{i\\vec{p}(R\u0026rsquo;+\\tau_{β}\u0026rsquo;)}|\\vec{R\u0026rsquo;}+\\tau_{β}\\rangle$\n译:\n我们假设π轨道之间的层间跃迁振幅是投射到石墨烯平面上的空间分离的平滑函数$t(r)$, 从而得到了层间跃迁项的连续模型.\n层间跃迁项哈密顿量 $H_{T}$ 的矩阵元素\n$T_{\\vec{k}\\vec{p\u0026rsquo;}}^{αβ}=\\langle Ψ_{\\vec{k}\\alpha}^{(1)}|H_{T}|Ψ_{\\vec{p\u0026rsquo;}β}^{(2)}\\rangle $\n描述了一个过程, 其中一个具有 $\\vec{p\u0026rsquo;}=M\\vec{p}$ 动量的电子在一层的子晶格β上跳到另一层的动量态 $\\vec{k}$ 和子晶格α上. 在一个π带紧-结合模型中, 两层的波函数对一个给定的子晶格的投射为\n$|\\Psi_{\\vec{k}α}^{(1)}\\rangle=\\frac{1}{\\sqrt{N}}∑_{\\vec{R}}e^{i\\vec{k}(R+\\tau_{α})}|\\vec{R}+\\tau_{α}\\rangle$ 和 $|\\Psi_{\\vec{p}β}^{(2)}\\rangle=\\frac{1}{\\sqrt{N}}∑_{\\vec{R\u0026rsquo;}}e^{i\\vec{p}(R\u0026rsquo;+\\tau_{β}\u0026rsquo;)}|\\vec{R\u0026rsquo;}+\\tau_{β}\\rangle$\nHere $\\tau_{A}=0$,$ \\tau_{B}=\\tau$, and $\\vec{R}$ is summed over the triangular Bravais lattice. Substituting Eqs. 2 and 3 in Eq. 1 and invoking the twocenter approximation, $\\langle\\vec{R}+\\tau_{α}|H_{T}|\\vec{R\u0026rsquo;}+\\tau_{α}-\\vec{R\u0026rsquo;}-\\tau\u0026rsquo;_{β}\\rangle$ for the interlayer hopping amplitude in which t depends on the difference between the positions of the two carbon atoms we find that\n$T_{\\vec{k}\\vec{p\u0026rsquo;}}^{αβ}=∑_{\\vec{G_{1}}\\vec{G_{2}}}\\frac{t_{\\overline{k}+\\vec{G}}}{Ω}e^{i[\\vec{G_{1}}\\tau_{α}-\\vec{G_2}(\\tau_{β}-\\tau)-\\vec{G_{2}\u0026rsquo;}\\vec{d}]}δ_{\\overline{k}+\\vec{G_{1}},\\overline{p\u0026rsquo;}+\\vec{G\u0026rsquo;_{2}}}$\n译:\n在这里, $\\tau_{A}=0$, $\\tau_{B}=\\tau$, $\\vec{R}$ 在三角布拉维格子上求和. 将式2和式3代入式1并调用双中心近似中的 $\\langle\\vec{R}+\\tau_{α}|H_{T}|\\vec{R\u0026rsquo;}+\\tau_{α}-\\vec{R\u0026rsquo;}-\\tau\u0026rsquo;_{β}\\rangle$ 表示层间跃迁振幅, 其中$t$取决于两个碳原子的位置差异.\n我们发现\n$T_{\\vec{k}\\vec{p\u0026rsquo;}}^{αβ}=∑_{\\vec{G_{1}}\\vec{G_{2}}}\\frac{t_{\\overline{k}+\\vec{G}}}{Ω}e^{i[\\vec{G_{1}}\\tau_{α}-\\vec{G_2}(\\tau_{β}-\\tau)-\\vec{G_{2}\u0026rsquo;}\\vec{d}]}δ_{\\overline{k}+\\vec{G_{1}},\\overline{p\u0026rsquo;}+\\vec{G_{2}\u0026rsquo;}}$.{#eq5}\nHere $Ω$ is the unit cell area, $t_{\\vec{q}}$ is the Fourier transform of the tunneling amplitude $t(\\vec{r})$, the vectors $\\vec{G_{1}}$ and $\\vec{G_{2}}$ are summed over reciprocal lattice vectors, and $\\vec{G_{2}\u0026rsquo;}=M\\vec{G_{2}}$. The bar notation over momenta in Eq. 5 indicates that momentum is measured relative to the center of the Brillouin zone and not relative to the Dirac point. Note that crystal momentum is conserved by the tunneling process because $t$ depends only on the difference between lattice positions.\n译:\n这里$Ω$是单位晶胞面积, $t_{\\vec{q}}$ 是层间跃迁振幅 $t(\\vec{r})$ 的傅里叶变换, 向量 $\\vec{G_{1}}$ 和 $\\vec{G_{2}}$ 是倒数晶格向量的总和, $\\vec{G_{2}\u0026rsquo;}=M\\vec{G_{2}}$. 公式5中动量的上划线表示:动量是相对于布里渊区的中心而不是相对于狄拉克点(能带零点)测量的.\n注意:晶体动量在层间跃迁过程中是守恒的, 因为$t$只取决于晶格位置的差异.\nThe continuum model for $H_{T}$ is obtained by measuring wave vectors in both layers relative to their Dirac points and assuming that the deviations are small compared to Brillouin-zone dimensions. The model’s utility rests centrally on the observation that, although $t_{q}$ is not precisely known, it should nevertheless fall to zero very rapidly with $q$ on the reciprocal lattice vector scale. This behavior follows from the property that the graphene layer separation $d_{\\perp}$ exceeds the separation between carbon atoms within the layers by more than a factor of 2.\n译:\n$H_{T}$ 的连续模型就可以通过测量两层中相对于其狄拉克点的波矢量(同时假设它与布里渊区尺寸相比偏差很小)得到. 该模型的效用集中体现在这样的观察上： 即使$t_{q}$并不精确, 但它应该随着倒格子矢量尺度上的$q$增大而迅速下降到零.\n这一行为来自于石墨烯层的分离度 $d_{\\perp}$ 超过层内碳原子之间分离度2倍以上的特性.\nBecause the two-center integral $t(r)$ varies with the three-dimensional separation $R = \\sqrt{r^2+d_{\\perp}^2}$ the strong small $r$ hopping processes vary with $r$ on the scale of $d_{\\perp}$. For this reason $t_{q}$ begins to decline rapidly for $qd_{\\perp} \u0026gt; 1$. Fig. 2 plots $t_{q}$ values obtained numerically from the π-band tight-binding models proposed in refs.19, 22, and 23. The largest $t_{q}$ values that enter the tunneling near the Dirac point have $q=k_{D}$, the Brillouin-zone corner (Dirac) wave vector magnitude, and correspond to the three reciprocal vectors $\\vec{0}$, $\\mathcal{G}^{(2)}$ and $\\mathcal{G}^{(3)}$ where the latter two vectors connect a Dirac point with its equivalent first Brillouin-zone counterparts (See Fig. 1).\n译:\n由于两中心积分(指的是计算两个中心之间的积分, 比如原子核或者分子之间.需要用到密度泛函理论) $t(r)$ 随三维分离度 $R=\\sqrt{r^2+d_{\\perp}^2}$ 的变化而变化, 所以强的小的$r$跳跃过程在 $d_{\\perp}$ 的尺度上随$r$变化.\n因此, $t_{q}$ 在 $qd_{\\perp}\u0026gt; 1$ 时开始迅速下降. 图2显示了π带的紧束缚模型(参考文献19、22和23中提出的)中以数值方式计算而来的 $t_{q}$ 值. 在狄拉克点附近进入层间跃迁的最大的 $t_{q}$值是$q=k_{D}$, 即布里渊区角(狄拉克)波矢量大小, 对应于三个倒格子矢量 $\\vec{0}$、$\\mathcal{G}^{(2)}$ 和 $\\mathcal{G}^{(3)}$, 其中后两个矢量分别连接狄拉克点和其等同的第一布里渊区对应点(参见图1).\nWhen only these terms are retained,\n$T^{αβ}(\\vec{r})=w∑_{j=1}^{3}e^{-i\\vec{q_{i}}\\cdot\\vec{r}}T_{j}^{αβ},$\nwhere $w=t_{k_{D}}/Ω$ is the hopping energy,\n$$ T_{1}=\\begin{bmatrix} 1 \u0026amp; 1\\\\ 1 \u0026amp; 1\\\\ \\end{bmatrix}, T_{2}= e^{-i\\mathcal{G}^{(2)\u0026rsquo;}\\cdot\\vec{d}}\\begin{bmatrix} e^{-iϕ} \u0026amp; 1\\\\ e^{iϕ} \u0026amp; e^{-iϕ}\\\\ \\end{bmatrix}, T_{3}= e^{-i\\mathcal{G}^{(3)\u0026rsquo;}\\cdot\\vec{d}}\\begin{bmatrix} e^{iϕ} \u0026amp; 1\\\\ e^{-iϕ} \u0026amp; e^{iϕ}\\\\ \\end{bmatrix},$$\nand $ϕ = 2π∕3$. The three $\\vec{q_{j}}$’s in Eq. 6 are Dirac model momentum transfers that correspond to the three interlayer hopping processes.\n译:\n当只保留这些项时, $T^{αβ}(\\vec{r})=w∑_{j=1}^{3}e^{-i\\vec{q_{i}}\\cdot\\vec{r}}T_{j}^{αβ}$, 其中 $w=t_{k_{D}}/Ω$ 是跃迁动能,\n$$ T_{1}=\\begin{bmatrix} 1 \u0026amp; 1\\\\ 1 \u0026amp; 1\\\\ \\end{bmatrix}, T_{2}= e^{-i\\mathcal{G}^{(2)\u0026rsquo;}\\cdot\\vec{d}}\\begin{bmatrix} e^{-iϕ} \u0026amp; 1\\\\ e^{iϕ} \u0026amp; e^{-iϕ}\\\\ \\end{bmatrix}, T_{3}= e^{-i\\mathcal{G}^{(3)\u0026rsquo;}\\cdot\\vec{d}}\\begin{bmatrix} e^{iϕ} \u0026amp; 1\\\\ e^{-iϕ} \u0026amp; e^{iϕ}\\\\ \\end{bmatrix},$$\n并且 $ϕ = 2π∕3$. 公式6中的三个 $\\vec{q_{j}}$ 是狄拉克模型的动量转移, 对应于三种层间跃迁过程.\nFor $\\vec{d}=0$ and a vanishing twist angle the continuum tunneling matrix is $3wδ_{αA}δ_{βB}$, independent of position. By comparing with the experimentally known (24) electronic structure of an AB stacked bilayer we set $w ≈ 110 meV$ for exfoliated samples, however experiments suggest (25) that $w$ may be smaller in some epitaxial graphene samples. As we show below the spectrum is independent of $\\vec{d}$ for $\\theta\\neq 0$. In the following we therefore set $\\vec{d}=0$.\n译:\n对于 $\\vec{d}=0$ 和扭转角度为零的情况, 连续隧穿矩阵为 $3wδ_{αA}δ_{βB}$, 并且这个量与位置无关. 通过与已知的\u0026quot;AB-堆叠\u0026quot;方式的双层材料的电子结构 (24) 进行比较, 我们设 $w\\approx 110\\text{ meV}$ 用于剥落的样品, 然而实验表明 (25) 在一些外延石墨烯样品中 $w$ 可能更小. 正如我们下面所展示的, 当 $\\theta\\neq 0$, 光谱与 $\\vec{d}$ 无关.因此, 在接下来的讨论中, 我们不妨设 $\\vec{d}=0$.\nResults Moiré Bloch Bands In the continuum model hopping is local and periodic, allowing Bloch’s theorem to be applied at any rotation angle irrespective of whether or not the bilayer is crystalline. We solve numerically for the moiré bands using the plane wave expansion illustrated in Fig. 1. Convergence is attained by truncating momentum space at lattice vectors of the order of $w/\\hbar v$. The dimension of the matrix, which must be diagonalized numerically, is roughly $∼10 \\theta^{-2}$ for small $\\theta$ (measured in degrees), compared to the $∼10^{4} \\theta^{-2}$ matrix dimension of microscopic tight-binding models (14, 16).\n译:\n在连续模型中, 跃迁具有局域性(或者说定域性)和周期性, 这使得布洛赫定理在任何旋转角下都能应用, 无论双层膜是否具有晶体结构. 如图一所示,我们使用平面波级数展开的方式对摩尔纹带进行数值求解. 通过将动量空间截断在大小为 $w/\\hbar v$ 的晶格矢量处, 可以实现收敛. 对于小的 $\\theta$ (单位为度), 该矩阵(数值求解对角化,从而得到摩尔纹带的能带结构)的维数大约为 $∼10 \\theta^{-2}$, 相比于微观紧束缚模型下的 $∼10^{4} \\theta^{-2}$ 的矩阵维数更小 (14, 16).\nUp to a scale factor the moiré bands depend on a single parameter $\\alpha=w/vk_{\\theta}$. We have evaluated the moiré bands as a function of their Brillouin-zone momentum $k$ for many different twist angles; results for $w = 110 meV$, and $θ = 5°$, $1.05°$, and $0.5°$ are summarized in Fig. 3. For large twist angles the low-energy spectrum is virtually identical to that of an isolated graphene sheet, except that the velocity is slightly renormalized. Large interlayer coupling effects appear only near the high energy van Hove singularities discussed by Andrei and coworkers (26). As the twist angle is reduced, the number of bands in a given energy window increases and the band at the Dirac point narrows. This narrowing has previously been expected to develop monotonically with decreasing $θ$.\n译:\n只要不超过某个比例因子,摩尔纹带都将仅取决于唯一参数 $\\alpha=w/vk_{\\theta}$. 我们将摩尔纹带视为其布里渊区动量$k$的函数, 并且对这个函数在许多不同扭曲角下的情况进行了评估. 图3总结了 $w=110 meV$, 且 $θ=5°$,1.05°$和0.5°$的结果. 如果旋转角很大, 低能带几乎与单层石墨烯相同, 只是速度需要略微重整化. 大的层间耦合效应只会出现在高能范霍夫奇点附近(这一观点由Andrei及其合作者讨论得出(26)). 随着扭转角的减少, 在一个给定的能量窗口中, 带的数量增加, 在狄拉克点的带变窄. 这种变窄以前被认为是随着$θ$的减少而单调地发展.\n范霍夫奇点\n晶格的布里渊区边界处的特殊点, 此时电子的态密度会发生突变.这种突变可以是因为在此处出现了能带的极值点, 也可以是因为能带的疏密程度在此处发生了变化.\nAs illustrated in Fig. 3, we instead find that the Dirac-point velocity vanishes already at $θ ≈ 1.05°$, and that the vanishing velocity is accompanied by a very flat moiré band which contributes a sharp peak to the Dirac-point density-of-states (DOS). At smaller twists the Dirac-point velocity has a nonmonotonic dependence on $\\theta$, vanishing repeatedly at the series of magic angles illustrated in Fig. 4.\n译:\n如图3所示, 我们发现狄拉克点速度在 $θ≈1.05°$ 时就已经消失了, 而且速度的消失伴随着一个非常平坦的摩尔带, 为狄拉克点态密度贡献了一个尖锐的峰值. 在更小的旋转角下, 狄拉克点速度对 $\\theta$ 有一个非单调的依赖(实际上就是反复波动,只能看出有多个零点), 在图4所示的一系列魔角处反复为0(也就是所谓的\u0026quot;消失\u0026quot;).\nPartial insight into the origin of these behaviors can be achieved by examining the simplest limit in which the momentum-space lattice is truncated at the first honeycomb shell. Including the sublattice degree of freedom, this truncation gives rise to the Hamiltonian\n$\\mathcal{H_{\\vec{k}}}=\\begin{bmatrix} h_{\\vec{k}}(\\theta/2) \u0026amp; T_{b} \u0026amp; T_{tr} \u0026amp; T_{tl}\\\\ T_{b}^{\\dagger} \u0026amp; h_{\\vec{k_{b}}}(-\\theta/2) \u0026amp; 0 \u0026amp; 0\\\\ T_{tr}^{\\dagger} \u0026amp; 0 \u0026amp; h_{\\vec{k_{tr}}}(-\\theta/2) \u0026amp; 0\\\\ T_{tl}^{\\dagger} \u0026amp; 0 \u0026amp; 0 \u0026amp; h_{\\vec{k_{tl}}}(-\\theta/2)\\\\ \\end{bmatrix}$,\nwhere $\\vec{k}$ is in the moiré Brillouin-zone and $\\vec{k_{j}}=\\vec{k}+\\vec{q_{j}}$. This Hamiltonian acts on four two-component spinors $\\Psi=(\\psi_{0},\\psi_{1},\\psi_{2},\\psi_{3})$. The first ($\\psi_{0}$) is at a momentum near the Dirac point of one layer and the other three $\\psi_{j}$ are at momenta near $\\vec{q_{j}}$ and in the other layer. The dependence of $h(\\theta)$ on angle is parametrically small and can be neglected. We have numerically verified that this approximation reproduces the velocity with reasonable accuracy down to the first magic angle (Fig. 4, Inset).\n译:\n如果采用最简单的截断方法(即选取动量空间晶格中的第一个蜂巢壳处)来取极限, 我们可以对这些特性的起源有部分了解.\n将子晶格的自由度也考虑在内, 这种截断就产生了哈密顿量的表达式:\n$$ \\mathcal{H_{\\vec{k}}}=\\begin{bmatrix} h_{\\vec{k}}(\\theta/2) \u0026amp; T_{b} \u0026amp; T_{tr} \u0026amp; T_{tl}\\\\ T_{b}^{\\dagger} \u0026amp; h_{\\vec{k_{b}}}(-\\theta/2) \u0026amp; 0 \u0026amp; 0\\\\ T_{tr}^{\\dagger} \u0026amp; 0 \u0026amp; h_{\\vec{k_{tr}}}(-\\theta/2) \u0026amp; 0\\\\ T_{tl}^{\\dagger} \u0026amp; 0 \u0026amp; 0 \u0026amp; h_{\\vec{k_{tl}}}(-\\theta/2)\\\\ \\end{bmatrix} $$\n其中 $\\vec{k}$ 处于摩尔布里渊区, $\\vec{k_{j}}=\\vec{k}+\\vec{q_{j}}$.\n这个哈密顿量作用于四个双分量自旋子 $\\Psi=(\\psi_{0},\\psi_{1},\\psi_{2},\\psi_{3})$. 第一个（$\\psi_{0}$）是在一个某层石墨烯狄拉克点附近的动量, 其他三个 $\\psi_{j}$ 则是在 $\\vec{q_{j}}$ 附近的动量, 位置则是在另一层石墨烯中.\n$h(\\theta)$ 对角度的依赖性在参数上很小,所以可以忽略不计.\n我们已经用数值验证了,这种近似方法直到第一个魔转角都能以合理的精度重现了速度.（图4）.\nThe renormalized velocity $v^{\\star}=\\partial_{\\vec{k}}\\epsilon_{\\vec{k}}^{\\star}|^{\\vec{k}=0}$ follows from the spectrum $\\epsilon_{\\vec{k}}^{\\star}$ of the twisted bilayer. The Hamiltonian is expressed as a sum of the $\\vec{k}=0$ term $\\mathcal{H}^{(0)}$ and the k-dependent term $\\mathcal{H}_{\\vec{k}}^{(1)}$ and solved to leading order in $\\vec{k}$. Consider the $\\vec{k}=0$ term in the Hamiltonian. We assume that $\\mathcal{H}^{(0)}$ has zero energy eigenstates and prove our assumption by explicitly finding these states. The zero energy eigenstates must satisfy\n$\\psi_{j}=-h_{j}^{-1}T_{j}^{\\dagger}\\psi_{0}$.\n译:\n我们可以从转角双层石墨烯的能谱 $\\epsilon_{\\vec{k}}^{\\star}$ 得到重整化后的速度 $v^{\\star}=\\partial_{\\vec{k}}\\epsilon_{\\vec{k}}^{\\star}|_{\\vec{k}=0}$.\n该哈密顿量被表示为 $\\vec{k}=0$ 的项 $\\mathcal{H}^{(0)}$ 以及依赖于$k$的项 $\\mathcal{H}{\\vec{k}}^{(1)}$ 的和, 并在 $\\vec{k}$ 的级数展开上求解.\n我们考虑哈密顿量中的 $\\vec{k}=0$ 项. 我们假设 $\\mathcal{H}^{(0)}$ 有零能量的本征态(我们将找到这些态以证明这个假设).\n零能量本征态必须满足:\n$\\psi_{j}=-h_{j}^{-1}T_{j}^{\\dagger}\\psi_{0}$.[9]\nBecause\n$T_{j}h_{j}^{-1}T_{j}^{\\dagger}=0$\nthe equation for the $\\psi_{0}$ spinor is $h_{0}\\psi_{0}=0$, i.e., $\\psi_{0}$ is one of the two zero energy states $\\psi_{0}^{(1)}$ and $\\psi_{0}^{(2)}$ of the isolated layer. The two zero energy eigenstates of $\\mathcal{H}^{(0)}$ then follow from Eq. 9. Given that $|\\psi_{0}^{(j)}|=1$, the wave functions should be normalized by $|\\Psi|^{2}=1+6\\alpha^{2}$. The effective Hamiltonian matrix to leading order in $k$ is therefore\n$\\langle\\Psi^{(i)}|\\mathcal{H}_{\\vec{k}}^{(1)}|\\Psi^{(j)}\\rangle=$\n$\\frac{-v}{1+6\\alpha^2}\\psi_{0}^{(j)\\dagger}[\\sigma\\cdot\\vec{k}+w^2\\sum_{j}T_{j}h_{j}^{-1\\dagger}\\sigma\\cdot\\vec{k}h_{j}^{-1}T_{j}^{\\dagger}]\\psi_{0}^{(j)}$\n$=-v^{\\star}\\psi_{0}^{(j)\\dagger}\\sigma\\cdot\\vec{k}\\psi_{0}^{(j)}$.\n译:\n由于\n$T_{j}h_{j}^{-1}T_{j}^{\\dagger}=0$,\n因此 $\\psi_{0}$ 的自旋轨道满足 $h_{0}\\psi_{0}=0$, 即 $\\psi_{0}$ 是孤立层的两个零能态 $\\psi_{0}^{(1)}$ 和 $\\psi_{0}^{(2)}$ 之一.\n然后, 根据式子[9], 可以得到 $\\mathcal{H}^{(0)}$ 的两个零能量本征态.\n考虑到 $|\\psi_0^{(j)}|=1$, 波函数应当通过 $|\\Psi|^{2}=1+6\\alpha^2$ 进行归一化.\n因此, 在$k$的一阶导数方面的有效哈密顿矩阵为：\n$\\langle\\Psi^{(i)}|\\mathcal{H_{\\vec{k}}^{(1)}|\\Psi^{(j)}}\\rangle= \\frac{-v}{1+6\\alpha^2}\\psi_{0}^{(j)\\dagger}[\\sigma\\cdot\\vec{k}+w^2\\sum_{j}T_{j}h_{j}^{-1\\dagger}\\sigma\\cdot\\vec{k}h_{j}^{-1}T_{j}^{\\dagger}]\\psi_{0}^{(j)}=-v^{\\star}\\psi_{0}^{(j)\\dagger}\\sigma\\cdot\\vec{k}\\psi_{0}^{(j)}$.\nAside from a renormalized velocity\n$\\frac{v^{\\star}}{v}=\\frac{1-3\\alpha^2}{1+6\\alpha^2}$\nthe Hamiltonian is identical to the continuum model Hamiltonian of single-layer graphene. The denominator in Eq. 11 captures the contribution of the $\\Psi_{j}$ ’s to the normalization of the wave function whereas the numerator captures their contribution to the velocity matrix elements. For small $\\alpha$, Eq. 11 reduces to the expression $v^{\\star}/v=1-9\\alpha^2$, first obtained by Lopes dos Santos et al. (15). The velocity vanishes at the first magic angle because it is in the process of changing sign. The eigenstates at the Dirac point are a coherent combination of components in the two layers that have velocities of opposite sign.\n译:\n除了一个经过重整化的速度\n$\\frac{v^{\\star}}{v}=\\frac{1-3\\alpha^2}{1+6\\alpha^2}$,\n哈密顿量与单层石墨烯的连续模型哈密顿量相同. 在方程式11中, 分母体现的是 $\\Psi_j$ 对波函数归一化的贡献, 而分子体现的是到它们对速度矩阵元的贡献. 对于小的 $\\alpha$, 方程式11简化为 $v^\\star/v=1-9\\alpha^2$(该式由Lopes dos Santos等人首次得到). 在第一个魔转角处速度降为0, 因为它正在变号. 在Dirac点处的本征态是两个石墨烯层中速度具有相反符号的组分的相干组合.\n人话:\n每个石墨烯层中只有一个态,而两个石墨烯层进行比较的时候,两个态的速度异号, 在Dirac点处的本征态是这两个态的线性组合.\nCounterflow Conductivity. Counterflow Conductivity\n当两个电子系统在相反方向移动时, 它们之间的电导率.在材料物理学中, 常常通过测量两个相反方向移动的电子系统之间的电导率来研究电子的输运性质.当两个电子系统的速度相等但方向相反时, 它们之间的电导率通常会非常小, 这种现象被称为“counterflow conductivity suppression”.这种效应在石墨烯等二维材料中经常被观察到, 并且对于研究这些材料的电子输运性质非常重要.\nThe distribution of the quasiparticle velocity between the two layers implies exotic transport characteristics for separately contacted layers. Consider a counterflow geometry in which currents in the two layers flow antiparallel to one another. We focus on twist angles $θ ≳ 2°$ for which the eightband model is valid and to the semiclassical regime in which $\\epsilon_{F}\\tau \u0026gt;1$ and find the counterflow conductivity $\\sigma_{CF}$. We assume that the Fermi momentum is much smaller than $k_{\\theta}$ and that $1/\\tau_{0}\u0026lt;\\hbar vk_{\\theta}$, where $\\tau_{0}$ is single particle lifetime. Using the Kubo formula we find that\n$$\\sigma_{CF}=\\frac{4e^{2}}{\\pi}\\sum_{\\vec{k}\\mu}|\\langle\\psi_{k}|v_{VF}^{x}|\\psi_{k}\\rangle|^2[Im\\{G_{k\\mu}^{r}(\\epsilon_{F})\\}]$$\nwhere\n$$ v_{CF}^{x}=-v\\begin{bmatrix} \\sigma_{x} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; -\\sigma_{x} \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -\\sigma_{x} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -\\sigma_{x}\\\\ \\end{bmatrix}, $$\nis the x component of the counterflow velocity operator (we set the electric fields along the x axis), $G_{k\\mu}^{r}(\\omega)=(\\omega-\\epsilon_{k\\mu}^{\\star}+i/2\\tau_{0})^{-1}$ is the retarded Green function with $\\mu$ labeling the two Dirac bands, and $\\epsilon_{k\\mu}^{\\star}=\\mu v^{\\star}k$ is the energy dispersion of the twisted bilayer at small momenta.\n译:\n在两层之间准粒子速度的分布意味着分别接触的层具有奇特的输运特性. 考虑一种反流几何形状, 其中两层中的电流彼此反向流动. 我们关注扭转角 $θ ≳ 2°$, 其中八带模型有效且处于半经典状态, 此时 $\\epsilon_{F}\\tau \u0026gt;1$, 并找到了反流电导 $\\sigma_{CF}$.\n八带模型\n“八带模型”是一种用于描述扭曲双层石墨烯的理论模型.在这个模型中, 每个石墨烯层的两个Dirac点之间的相互作用被考虑在内, 因此会出现四个价带和四个导带, 共计八个带.相比于单层石墨烯的两个带（一个价带和一个导带）, 八带模型提供了更为准确的描述扭转双层石墨烯的方式.在八带模型中, 每个带的色散关系（即能量与动量的关系）由一组非常复杂的解析式给出.八带模型的具体公式实际上就是本文所给出的 $\\sigma_{CF}$ 的表达式.\n我们假设费米动量远小于 $k_{\\theta}$, 并且 $1/\\tau_{0}\u0026lt;\\hbar vk_{\\theta}$, 其中 $\\tau_{0}$ 是单粒子寿命.使用Kubo公式, 我们得到：\n$$\\sigma_{CF}=\\frac{4e^{2}}{\\pi}\\sum_{\\vec{k}\\mu}|\\langle\\psi_{k}|v_{VF}^{x}|\\psi_{k}\\rangle|^2[Im{G_{k\\mu}^{r}(\\epsilon_{F})}]$$\n其中,\n$$ v_{CF}^{x}=-v\\begin{bmatrix} \\sigma_{x} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; -\\sigma_{x} \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -\\sigma_{x} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -\\sigma_{x}\\\\ \\end{bmatrix}, $$\n是反流速度算符的x分量(我们将电场设置在x轴上), $G_{k\\mu}^{r}(\\omega)=(\\omega-\\epsilon_{k\\mu}^{\\star}+i/2\\tau_{0})^{-1}$ 是带有 $\\mu$ 标签的逆变换格林函数, 表示两个Dirac带的能量色散, $\\epsilon_{k\\mu}^{\\star}=\\mu v^{\\star}k$ 是小动量条件下转角双层石墨烯的能量色散.\nFor an electron-doped system the valence band can be neglected and\n$\\sigma_{CF}\\approx e^2g\\tau\\nu^{\\star}(\\epsilon_{F})\\int\\frac{d\\theta_{k}}{2\\pi}|\\langle\\psi_{k\\mu}|\\nu_{CF}^{x}|\\psi_{k\\mu}\\rangle|^2$\nwhere $v^{\\star}$ is the DOS of the twisted bilayer.The vertex function\n$\\langle\\psi_{k}|v_{CF}^{x}|\\psi_{k}\\rangle=v_{CF}\\cos{\\theta_{k}}$,\nwhere $v_{CF}=v(1+3\\alpha^2)/(1+6\\alpha^2)$ follows directly from the previous section if we notice the sign differences between the counterflow velocity operator and the normal velocity operator. The counterflow conductivity is then\n$\\sigma_{CF}=\\sigma_{0}(\\frac{v_{CF}}{v^{\\star}})^2$\nwhere $\\sigma_{0}~e^2\\epsilon_{F}\\tau/\\pi$ is the conductivity of an isolated single graphene layer. As $\\theta$ is reduced from a large value toward 1°, $v^{\\star}$ is reduced and the DOS is correspondingly increased. The counterflow conductivity is enhanced because of an increased density of carriers, which is not accompanied by a decrease in counterflow velocity. For a conventional measurement in which the current in the bilayer is unidirectional $v_{CF}$ in Eq. 16 is replaced by $v^{\\star}$. The increase in the DOS is then exactly compensated by the reduction of the renormalized velocity and the single-layer value of the conductivity is regained.\n译:\n对于一个电子掺杂的系统, 可以忽略价带, 并且\n$\\sigma_{CF}\\approx e^2g\\tau\\nu^{\\star}(\\epsilon_{F})\\int\\frac{d\\theta_{k}}{2\\pi}|\\langle\\psi_{k\\mu}|\\nu_{CF}^{x}|\\psi_{k\\mu}\\rangle|^2$\n其中, $v^{\\star}$ 是双层扭转石墨烯的态密度.顶点函数\n$\\langle\\psi_{k}|v_{CF}^{x}|\\psi_{k}\\rangle=v_{CF}\\cos{\\theta_{k}}$,\n其中, $v_{CF}=v(1+3\\alpha^2)/(1+6\\alpha^2)$ 直接从前面的章节得到, 如果我们注意到反流速度算符和正常速度算符之间的符号差异.反流电导率为\n$\\sigma_{CF}=\\sigma_{0}(\\frac{v_{CF}}{v^{\\star}})^2$\n其中, $\\sigma_{0}~e^2\\epsilon_{F}\\tau/\\pi$ 是单层石墨烯的电导率. 当 $\\theta$ 从一个大的值减小到1°时, $v^{\\star}$ 减小, 态密度相应增加. 反流电导因载流子密度的增加而增加, 而不伴随相对流速的减小. 对于常规测量, 其中双层石墨烯中的电流是单向的, 式子16中的 $v_{CF}$ 被 $v^{\\star}$ 取代. 态密度的增加被粒子速度的减小所精确补偿, 单层的电导率得以恢复.\nDependence of the Spectrum on $\\vec{d}$ We now show that the spectrum of misaligned bilayers is independent of linear translations of one layer with respect to the other using a unitary transformation that makes the Hamiltonian independent of $\\vec{d}$. Consider $H_{\\vec{Q}}$ where $\\vec{Q}$ is a momentum in the first moiré Brillouin zone. With each momentum on the $k$-space triangular Bravais lattice (see Fig. 1)\n$\\vec{k}=\\vec{Q}+n\\vec{q_1}+m\\vec{q_2}$,\nwhere $\\vec{q_1}=k_{\\theta}(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ and $\\vec{q_2}=k_{\\theta}(-\\frac{1}{2},\\frac{\\sqrt{3}}{2})$, we associate the phase\n$\\Phi^{k}=n\\vec{G_{2}\u0026rsquo;}\\cdot\\vec{d}+m\\vec{G_{3}\u0026rsquo;}\\cdot\\vec{d}$.\nThe phase associated with momentum $\\vec{k}-\\vec{k_{\\theta}}\\hat{y}$ on the other sublattice is $\\Phi_{\\vec{k}}$ as well. In terms of the new basis states $e^{i\\Phi_{\\vec{k}}}|\\vec{k}\\alpha\\rangle$ the Hamiltonian $H_{\\vec{Q}}$ is $d$-independent.\nPhysically, the lack of dependence on $\\vec{d}$ can be understood by noticing that varying $\\vec{d}$ just shifts the moiré pattern in space. The bilayer spectrum does depend on $\\vec{d}$ at $\\theta=0$, and at other commensurate angles. We expect that dependence on $\\vec{d}$ will be observable only at short period (large $\\theta$) commensurate angles.\n译:\n我们现在证明错位双层体系的能谱与其中一层的线性平移无关, 通过一个幺正变换使得哈密顿量不依赖于 $\\vec{d}$. 考虑动量 $\\vec{Q}$ 在第一个摩尔布里渊区的哈密顿量 $H_{\\vec{Q}}$ . 对于每个 $k$ 空间三角布拉维格子上的动量为（见图1）\n$\\vec{k}=\\vec{Q}+n\\vec{q_1}+m\\vec{q_2}$,\n其中 $\\vec{q_1}=k_{\\theta}(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$, $\\vec{q_2}=k_{\\theta}(-\\frac{1}{2},\\frac{\\sqrt{3}}{2})$,\n我们关联相位\n$\\Phi^{k}=n\\vec{G_{2}\u0026rsquo;} \\cdot \\vec{d}+m\\vec{G_{3}\u0026rsquo;} \\cdot \\vec{d}$.\n在另一个亚晶格上, 关联于动量 $\\vec{k}-\\vec{k_{\\theta}}\\hat{y}$ 的相位同样是 $\\Phi_{\\vec{k}}$ . 在新的基态 $e^{i\\Phi_{\\vec{k}}}|\\vec{k}\\alpha\\rangle$ 下, 哈密顿量 $H_{\\vec{Q}}$ 并非 $\\vec{d}$ 的函数.\n物理上, 不依赖于 $\\vec{d}$ 可以理解为改变 $\\vec{d}$ 只是在空间中平移moire图案. 只有在 $\\theta=0$ 和其他共格角度时, 双层能谱才会取决于 $\\vec{d}$.\n我们预计只有在短周期（即大 $\\theta$）的共格角度时, 才能观察到 $\\vec{d}$ 的依赖性.\n共格角度Commensurate Angles\n在物理学中, 两个周期性结构的共格是指它们之间存在匹配的空间排列方式.如果两个晶格的晶格常数和晶向满足特定的关系, 则它们的共格就被称为共格结构, 这个特定的关系被称为“共格条件”.如果两个周期性结构的共格条件不被满足, 它们之间的匹配就被称为“不共格”（incommensurate）.\n对于双层石墨烯, 当两层图案之间的角度非常接近特定角度时, 双层石墨烯就会表现出一些特殊的物理性质, 比如出现了长周期的moire图案和扭曲的带结构.这些特殊的角度被称为共格角度（commensurate angles）, 因为在这些角度下, 两层之间的moire图案可以完美地对齐, 形成一种共格结构.\nDiscussion Twisted double-layer graphene is, for most values of $\\theta$, a quasiperiodic structure that has no unit cell. Nevertheless, we find that for $\\theta ≲ 10°$ it is meaningful to describe the electronic structure of the system in terms of Bloch bands. The hidden periodic structure is shown to be related to the moiré pattern of the overlaid layers (27).\nThe leading corrections to the periodic moiré band Hamiltonian involve hopping amplitudes with the smallest momenta $\\vec{g}$ that satisfy the crystal momentum conservation condition in Eq. 5 and are larger than $k_{D}$ . As we showed in ref. 19, real space commensuration between the two rotated hexagonal lattice is concomitant to momentum space commensuration of the Dirac points in the extended-zone scheme (see figures 2 and 3 in ref. 19). The commensurate vector $\\vec{g}$ can therefore be found using the formula for the moiré periodicity if the lattice vector of $\\sqrt{3}a$ (where a is the carbon-carbon distance in a single-layer graphene) is replaced by the reciprocal lattice vector $G$ . It follows that $g(\\theta)\\approx G/\\theta$. For example $g(10°)=24/a$ and $g(2°)$ . As Fig. 2 demonstrates, the hopping amplitudes for these large wave vectors are indeed negligible compared to the value of $t_{k_{D}}$ . We therefore expect the continuum model to be very accurate up to energies of approximately $1 eV$ and up to angles of approximately $10°$.\n译:\n在大多数 $\\theta$ 值下,扭转双层石墨烯都是一种无定晶胞的准周期结构. 然而, 我们发现对于 $\\theta ≲ 10°$ , 用布洛赫能带描述系统的电子结构很有意义. 隐藏的周期性结构被证明与重叠层的moire图案有关(27).\n对周期性moire带哈密顿量的主要修正是这样的:跃迁振幅对应的动量,要同时满足三个条件,即(1)晶体动量守恒条件(方程5);(2)大于 $k_{D}$;(3)满足(1),(2)的同时要尽可能最小.\n正如我们在参考文献19中所示, 转角双层石墨烯结构的实空间共格现象 与 扩展区方案中Dirac点动量空间共格现象是一致的（参见参考文献19中的图2和图3）. 因此, 如果将 $\\sqrt{3}a$ 的晶格矢量（其中a是单层石墨烯中的碳-碳距离）替换为倒易晶格矢量$G$, 就可以使用moire周期公式找到共格矢量 $\\vec{g}$.\n于是就有 $g(\\theta)\\approx G/\\theta$.例如, $g(10°)=24/a$和$g(2°)$.\n正如图2所示, 对于这些大波矢, 跃迁振幅与 $t_{k_{D}}$ 的值相比确实微不足道. 所以我们预计,连续模型在能量达到约 $1eV$ 且 角度达到约 $10°$ 时非常精确.\nThe Bloch band model has a simple and appealing physical interpretation. The hopping Hamiltonian is local in space. At each position, its 4 × 4 matrix, describes sublattice-dependent interlayer hopping, which depends on the local coordination between the atoms in the two layers. In Fig. 5 we have plotted the moiré pattern of atomic positions and the smaller of the two positive eigenvalues of the hopping Hamiltonian as a function of position on the same length scale. At each position, the local interlayer tunneling Hamiltonian, is that of a system in which the local coordination is maintained through all space. At AB and BA points, for example, the tunneling Hamiltonian is that of AB and BA systems, for which tunneling does not produce a gap so that the smallest positive eigenvalue vanishes. On the other hand the gap reaches its maxima ($6w$) at AA points in the moiré pattern.\nIn summary we have formulated a continuum model description of the electronic structure of rotated graphene bilayers. The resulting moiré band structure can be evaluated at arbitrary twist angles, not only at commensurate values. We find that the velocity at the Dirac point oscillates with twist angle, vanishing at a series of magic angles which give rise to large DOS and to large counterflow conductivities. Many properties of the moiré bands are still not understood. For example, although we are able to explain the largest magic angle analytically, the pattern of magic angles at smaller values of θ has so far been revealed only numerically. Additionally the flattening of the entire lowest moiré band at $\\theta\\approx 1.05°$ remains a puzzle. Interesting new issues arise when our theory is extended to graphene stacks containing three or more layers. Finally, we remark that electron-electron interactions neglected in this work are certain to be important at magic twist angles in neutral systems and could give rise to counterflow superfluidity (28, 29), flat-band magnetism (30), or other types of ordered states.\n译:\nBloch带模型有一个简单而有吸引力的物理解释. 跃迁哈密顿量在空间上是局域的.\n在每个位置, 它的 $ 4\\times 4$ 矩阵描述了亚晶格相关的层间跃迁, 这取决于两层原子之间的局部配位.\n在图5中, 我们绘制了原子位置的moire图案和跃迁哈密顿量的两个最小正本征值, 它们在相同的长度尺度上随位置变化.\n在每个位置上, 局部层间隧道哈密顿量都是保持空间中所有位置的局部配位不变的系统的哈密顿量.\n例如, 在AB点和BA点, 隧道哈密顿量是AB和BA系统的哈密顿量, 在这些系统中, 隧道跃迁不会产生能隙, 因此最小正本征值为零. 另一方面, 能隙在moire图案的AA点处达到最大值（$6w$）.\n总之, 我们已经制定了一个连续模型来描述旋转石墨烯双层体系的电子结构. 得到的moire带结构可以在任意扭角下进行评估, 而不仅仅是在共格值处.\n我们发现, 在Dirac点处的速度随旋转角增大而振荡, 在一系列魔角处消失, 这产生了大的态密度和大的反流电导率. moire带的许多性质仍然不为人们所理解. 例如, 虽然我们能够解释最大的魔角, 但在较小的 $\\theta$ 值处的魔角模式到目前为止只能通过数值方法揭示. 此外, 在 $\\theta\\approx 1.05°$ 处的整个最低moire带的平坦化仍然是一个谜. 当我们的理论扩展到包含三个或更多层的石墨烯堆叠时, 会出现一些有趣的新问题. 最后, 我们指出, 本文忽略的电子间相互作用在中性系统的魔角处肯定是重要的, 并且可能会产生反流超流动性、平带磁性或其他类型的有序状态(28,29,30).\n","permalink":"https://Muatyz.github.io/posts/read/moire-bands/","summary":"Moiré bands in twisted double-layer graphene 双层石墨烯出现转角时, 在整体层面会出现摩尔纹. Abstract A moiré pattern is formed when two copies of a periodic pattern are overlaid with a relative twist. We address the electronic structure of a twisted two-layer graphene system, showing that in its continuum Dirac model the moiré pattern periodicity leads to moiré Bloch bands. The two layers become more strongly coupled and the Dirac velocity crosses zero several times as the twist angle is reduced. For a discrete set of magic angles the velocity vanishes, the lowest moiré band flattens, and the Dirac-point density-of states and the counterflow conductivity","title":"[中字]Moiré bands in twisted double-layer graphene"},{"content":"get commit 在当前分支创建一个提交记录\n分支 创建新分支\ngit branch \u0026lt;branch-name\u0026gt; 创建分支后直接使用\ngit commit 并不会在新分支产生提交记录, 这是因为没有切换到新分支.\ngit 工具会使用*来提示你目前所在的分支.\ngit checkout \u0026lt;branch-name\u0026gt; 切换到名为 branch-name 的分支, 这个时候提交就可以在该分支下产生新提交记录了.\n把这两个功能整合起来的命令:\ngit checkout -b \u0026lt;branch-name\u0026gt; 合并 对于同一父节点有着不同的分支, 这两个分支表示各有一个独立提交.\n把branch-name 合并到 main 里:\ngit merge \u0026lt;branch-name\u0026gt; 这会产生一个新节点 C4, 其父节点为 main 和 branch-name 的最新提交记录所表示的结点(C2和C3).\n在此基础上再将 main 合并到 branch-name, 因为此时 main 继承自 branch-name, 所以只会把 branch-name 代表的指针移动到最后产生的结点(C4)\nRebase 这是另一种合并分支的方法, 就是去除一系列的提交记录, 将其在另一个地方逐一执行. 这可以让代码库的提交历史变得更清晰.\n假设 main 和 bugFix 的分支自结点C1, 各自的最新提交记录结点为 C2 和 C3, 目前所在分支是 bugFix.\nC2 和 C3的工作可以是并行的.\n现在使用 rebase 命令实现合并, 这会使得两个分支的功能像是顺序实现的.\ngit rebase main 这会产生一个新结点C3', 其父节点为 C2, main 停留在 C2, bugFix 停留在 C3', 目前所在分支仍然为 bugFix.\n现在我们需要使 main 得到更新:\ngit checkout main;git merge bugFix; 因为 bugFix 继承自 main, 所以git 要做到以上指令, 只需要将 main 指针移动到 C3' 即可.\n目前所在分支为 main.\n分离 如何在提交树上移动?\nHead 是一个对当前分支的符号引用, 它用来指代当前分支的最新提交记录. 这也意味着 Head 会随着你的提交而更新.\n现在我们要让 HEAD 指向 具体的提交记录而并非分支名.\n假设这样一个状态:main*指针指向最新提交记录C1, HEAD 指向 main.\n即\nHEAD -\u0026gt; main -\u0026gt; C1\n我们执行命令:\ngit checkout C1 这样就变成了\nHEAD -\u0026gt; C1\n当然在具体的操作实践中, 结点的记录不会像 C1 这样简单, 而是一个更复杂的哈希值(可以长达40位!).\n相对引用 Git 对于哈希值的处理有一定的智能, 它允许你可以只使用哈希值的前几个字符来指代对应的提交记录, 而无需将哈希值完整写出.\n你可以通过\ngit log 来查看提交记录的哈希值.\n如果是通过相对引用, 就可以不用使用哈希值.\n两种常见的移动方法:\n使用^向上移动一个提交记录\n具体用法是将^加在引用名称的后面, 比如\ngit checkout main^ 将 HEAD 切换到 main 的父节点.\nHEAD 本身也可以作为引用名称的对象.\n使用~\u0026lt;num\u0026gt;向上移动 num 个提交记录\ngit checkout HEAD~4 这将使得 HEAD 指针移到 HEAD 的第四个父节点.\n使用 -f 来让分支指向另一个提交.(-f 代表强制)\ngit branch -f main HEAD~3 这会将 main 分支强制指向 HEAD 的第3级父提交.\n撤销变更 有两种实现方法:\ngit reset\n这会使得提交记录回溯, 原来指向的提交记录会被代码库忽略.\n但是原提交记录所作出变更还在, 只是没有加入暂存区.\n这个只适用于本地代码库, 对于远程分支是无效的.\ngit revert C2\n为了将撤销更改分享给别人, 需要用到这个指令.\n这会产生一个新的提交记录结点C2\u0026rsquo;, 这个更改是用来撤销C2的. 即 C2\u0026rsquo; 状态也就是 C1.\n注意辨别两个指令在使用的时候所使用的坐标是谁.\n整理提交记录 现在我们需要处理更复杂的工作流了.\ngit cherry-pick \u0026lt;commit\u0026gt; 假设 C2 和 C5 分支自共有父节点 C1, 而C2后的提交记录分别是C3, C4.\n现在main指针指向 C5, side 指针指向 C4. 且当前所在分支为main.(git 工具会提示你main*)\n我们执行\ngit cherry-pick C2 C4 这会使得 C5 后依次出现新提交记录 C2' 和 C4', 并且 main* 指向C4'.\n交互式 rebase 在我们并不清楚提交记录的哈希值的时候, git 提供了一个方法.\n--interactive 或者 -i, 这会使 Git 打开一个 UI 界面并列出提交记录的哈希值和提交说明.\n在实际操作中, 这个 UI 窗口可能仅仅只是一个文本编辑器中的界面. VS Code 中的代码管理会比这个更人性化一些.\n具体来说里面有若干个提交记录, 通过鼠标点击拖动来调整或者忽略这些结点顺序.\n只取一个提交记录 为了调试而在代码中添加了一些调试命令, 这部分代码在正式的 使用中显然是不会用到的.\n实际上我们只需要\u0026rsquo;刚好能解决问题并且没有任何调试代码\u0026rsquo;的那一个提交记录就可以了.\n我们可以借助之前所学的命令来达成这一目的.\ngit rebase -i\ngit cherry-pick\ngit checkout main; git cherry-pick bugFix; 或者\ngit rebase -i main bugFix; git branch -f main HEAD 提交的技巧 假设在 newImage 分支进行了一次提交, 又在这个提交基础上创建了 caption 分支, 然后又在 caption 分支上进行了一次提交.\n现在如果要对 newImage 中的提交进行修改, 就需要进行一些修改和排序.\n","permalink":"https://Muatyz.github.io/posts/cs/github-mannual/","summary":"get commit 在当前分支创建一个提交记录 分支 创建新分支 git branch \u0026lt;branch-name\u0026gt; 创建分支后直接使用 git commit 并不会在新分支产生提交记录, 这是因为没有切换到新分支. git 工具会使用*来提示你目前所在的分支. git checkout \u0026lt;branch-name\u0026gt; 切换到名为 branch-name 的分支, 这个时候提交就可以在该分支下产生新提交记录了. 把这两个功能整合起来的命令: git checkout -b \u0026lt;branch-name\u0026gt; 合并 对于","title":"Github基础语法说明"}]